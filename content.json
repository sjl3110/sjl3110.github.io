{"meta":{"title":"个人博客","subtitle":"记录点滴，分享生活","description":"浙江大学航空航天学院","author":"沈建谅","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-07-20T02:28:21.000Z","updated":"2019-07-20T08:04:14.618Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"联系方式电话：15895898063地址：浙江杭州邮箱：jianliang_shen@zju.edu.cn仓库：https://github.com/sjl3110 教育背景本科：南京理工大学硕士：浙江大学 专业技能嵌入式硬件电路设计ARM Linux系统开发操作系统应用软件开发"},{"title":"所有标签","date":"2019-07-20T01:58:15.000Z","updated":"2019-07-20T02:23:10.772Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-07-20T02:00:55.000Z","updated":"2019-07-20T02:23:25.822Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"知乎收藏","slug":"知乎收藏","date":"2019-08-23T03:34:37.000Z","updated":"2019-08-23T03:50:00.281Z","comments":true,"path":"2019/08/23/知乎收藏/","link":"","permalink":"http://yoursite.com/2019/08/23/知乎收藏/","excerpt":"知乎干货类收藏汇总，收藏夹地址：干货 学习技巧有哪些高质量的自学网站？厉害的人是怎么分析问题的？ 问题是什么看问题要把握问题的本质问题是期望与现状的落差部分，没有问题才是最大的问题首先需要弄清楚问题，再想办法解决。问题是需要具体量化出来的，不能是含糊大概的","text":"知乎干货类收藏汇总，收藏夹地址：干货 学习技巧有哪些高质量的自学网站？厉害的人是怎么分析问题的？ 问题是什么看问题要把握问题的本质问题是期望与现状的落差部分，没有问题才是最大的问题首先需要弄清楚问题，再想办法解决。问题是需要具体量化出来的，不能是含糊大概的 如何描述一个问题明确期望值（B）精准定位现状（B’）用期望与现状差值（B’-B）精准描述问题提出一个精准的问题，是你能找到正确答案的第一步，也是最重要的一步！ *一个问题，就像是一盏路灯，只会照亮下方的特定区域。 你想要的答案，就像是一把遗失的钥匙，如果你想要找到它，就必须打开它上方的路灯才行。 但如果你问错了问题，就像是开错了灯，就永远也找不回那把钥匙了。* 如何寻找答案表面问题，只是由本质问题导致的症状，而我们常常把症状当成了问题本身，于是急于去消除它， 而忽略了本质问题。直接对着差值去找办法只能找到浅层的办法不能根治问题。这就要回到对问题的理解上去，看待问题不能只看表面问题，要着重分析问题的本质。从本质出发想办法才是解决问题正确有效的途径。 如何找到问题的本质别盯着问题看，需要做的事掌握足够多的信息来描述问题，这才是第一步； A：为了实现（B）的结果，所使用的方法。如果方法是错误的，目标自然无法达到。 B：期望值。目标设置不当，或者目标设定过高，那么即便完美做到了A，这个目标也无法达成； C：过程中出现的变量。方法和目标都没有问题，可是出现了意料之外的事，也有可能导致目标 无法达成… 校准目标（B）。一个错误的目标，会让你的所有努力，都化为泡影遇。到问题别急着找办法找原因，首先分析看看自己的目标是否正确明朗。没有清晰的目标，问题永远不清晰，接下来怎么去解决更是一头雾水了。 设计目标的SMART原则 Specific 明确的，具体的， 目标是否明确清晰？Measurable 可衡量的，衡量目标的完成度 Achievable 可达到的 目标可达才是有效的目标 Rewarding 满足感 完成一个目标获得与之难度对应的满足感是完成下一个目标的动力 Time-bound 有时间限制的 做任何事设定任何目标一定要有时间限制。不同的时间限制会导致思考和指定计划的完全不同。如果没有时间限制，目标就是一句口号，起不到任何作用目标不对，什么都不对！ 用数据说话，对现象背后的数据分析的越透彻，对问题的理解对深刻*。 区别目标和手段：区分目标和手段 除了目标要遵循「SMART原则」外，你还得注意区分目标和手段。关不关窗是手段，开/关窗后想要达到的结果才是目的。在不伤害其他人的情况下，别纠结手段，达 到目的即可。所以，当你遇到一个问题的时候，第一步应该先检查一下的，你的目标是否符合SMART原则？你是否把手段本身当成了目标？ 重构方法（A）：如果不改变原有的解决方案，现状就很难改变。中国：洋务运动日本：明治维新 想要大幅度改变现状，或者达成全新的目标，就得把原来的（A）一起改了，而不是在（B’）点上转弯*。重复原有的方法，只能得到同样的结果；想要有不同的结果，就需要用不同的方法。 消除变量（C）要建立一个寻找问题的基本思考框架，叫做：象、数、理。任何一个「现象」背后一定有「数据」，任何「数据」的变动，背后一定有「道理」。把现象背后的数据分解的越细，看到的问题就会越精准。如果AB都没有问题，问题依然存在，一定存在着变量，你可以通过「象、数、理」这个基本框架来 寻找它，并通过5Why的提问方法，挖掘真正的原因。 在一秒钟内看到本质的人，和花半 辈子也看不清一件事本质的人，自然是不一样的命运。—-马里奥·普佐《教父》* 研究生新生要怎么看论文？ 如何判断手头的这篇文献和自己的领域相关值得精度？ 那些在阅读中遇到的生单词 (学术专业词汇除外) 真的会对通篇的理解形成严重障碍吗？ “读懂”的定义是什么？没有输出反馈的文献阅读对我们的科研积累到底有没有价值？ 列表： 序号 文献名称 文献类型(期刊、硕论、博论) 发表年份 关键部分（用来记录本篇文章你认为关键的地方，标注好内容和页码） 研究方法（可以看出此类问题，大家都是采用一个什么样的方法去解决的） 存在问题（如前所述） 产生原因（有些文献可能没有，没有即不写） 解决方法（如前所述） 创新点 下一步工作/不足之处（别人论文里的不足可能是你idea的来源） 学会精读和泛读 总结提炼、吸收转化 做review：留心总结论文中用到的求解技巧/算法亲自编程/设计实验仿真再现论文中的结果 没有导师的指导，研究生如何阅读文献、提出创见、写论文？科研大牛们怎么读文献？ 读文献要读人，读典和读新。 读人系统性搜寻文章——文章的阅读与归类——文章的分析和个人思考 读经典（或者优秀的文章） 本领域内大家一直在讨论的、周围的人（导师、同事等等）一直推荐给你的文章，应该都没有太大的问题。 平时要注意关注本领域的一些顶级科学家，比如我所在领域的Chris Voigt，James Collins等等。在谷歌建立的学者页会有列出所有相关的文章，按照引用率的排序，一般引用率比较高的都属于非常好的文章，可以作为经典来读。 同时无论是谷歌学术搜索都会给出某领域或者某杂志的引用率最高的文章排序，这种以引用率为评价标准的一般问题都不大。 读新读新读新则是对所关注领域的最新进展。利用文献订阅工具进行最新文献的获取，例如Google Scholar、Researcher App、Stork以及相关相关杂志网站的订阅服务。 你写论文时发现了哪些神网站？碎片化时代，有哪些高效的学习方法？你用过哪些强大的快捷键？ F4：重复上一次操作； ctrl+P：打印，在无法复制文本的网页中开启打印预览。 有哪些看起来高大上，实际上却很简单的摄影技巧？理工科科研结果展示怎样让 PPT 高大上？有什么书值得推荐给大学生看？ 《如何阅读一本书》《社会心理学》《金字塔原理》《非暴力沟通》《学习之道》《明朝那些事儿》《富爸爸穷爸爸》《我们仨》《围城》《学会提问》《自控力》《平凡的世界》《亲密关系》《高效能人士的七个习惯》《乌合之众》 修仙宝典Linux初学者(学习资料)作为电子信息工程的学生，学完stm32后，是应该学fpga还是Linux?一段鬼畜的代码程序员一般可以从什么平台接私活？火爆网络的《神经网络与深度学习》，有人把它翻译成了中文版！使用hexo，如果换了电脑怎么更新博客？怎样做一个漂亮的 GitHub Pages 首页？大家都是如何刷 LeetCode 的？数据说话：怎样的程序员最抢手？刷 LeetCode 对于国内 IT 企业面试帮助大吗？计算机系学生应该怎样正确管理自己的电脑？编程新手如何提高编程能力？ 要读文档，英文文档做知识输出，用文字总结自己的学习内容。多用命令行；有问题，先文档，再stackoverflow，再技术文章要用实例驱动学习，不要说你会什么，要说你做了什么。 如果大学里你一开始就看了这篇文，离开时已经是高级码农如何用 Github 找到需要的代码？GitHub 上的顶级项目都是做什么的？应聘简历面试官问你的缺点是什么，应该如何回答？ 在谈到自己缺点的时候，尽量避开三观，性格方面的缺点。思维方式作为可选项，但不是优选项。最好还是着眼于知识和技能。因为这两点改进空间大，速度快。 往高处说：能力层次有高有低，请你挑一个与你目前所在层次相隔较远的能力缺陷来说。 往远处说：术业有专攻，找一个与你本职工作间隔较远的专业能力缺陷来说。 高标准、找不足 总得一句话——我的缺点就是有这个岗位的职业病，而有职业病——既说明了我有经验，又说明我比较专业，又符合别人对这个职业人士的人想象，基本无懈可击。一定要举例子！举例子！让狡猾的诚实变得更可信！ 什么时候你觉得自己被面试官套路了？ 三流大学和一流大学学生的简历有什么区别？ 三流简历：信息不完整在简历上直接写自己的重大缺点工作经历是求职重点，但全是口水话 二流简历：建议深度挖掘工作过程中，自己是怎么样思考，怎么样优化工作，以及获得了什么样的数据成果，获得了哪些能力的提升，从而增强简历的说服力。 一流简历:硬性条件：学校、学历、获奖经历都非常优秀工作经历：每一份工作经历的描写，都用到了STAR法则。STAR法则是情境(situation)、任务(task)、行动(action)、结果(result)四项的缩写。具体含义是: Situation*: 事情是在什么情况下发生 Task*: 你是如何明确你的任务的 Action*: 针对这样的情况分析，你采用了什么行动方式 Result*: 结果怎样，在这样的情况下你学习到了什么. 四大HR眼中的好简历是什么样子的？如何评价应届生在面试中说的「虽然我没有经验，但是我非常愿意学习」这句话？奇门遁甲有哪些堪称「神器」，却鲜为人知的软件/网站/互联网服务？ PHOTOZOOM PRO：它的原理是利用插值算法来放大图片，让分辨率较低的图片可以变得很清晰。 PPTMinimizer：这个压缩软件的强大之处在于，专门压缩WORD和POWERPOINT文件，压缩率高到吓死人，最高可以达到98%。 VideoMinimizer：视频压缩软件。 iSlide 插件：iSlide是一款基于PowerPoint的插件工具，功能例如：环形复制、一键裁剪出相同尺寸的图片、一键统一PPT中的字体和段落、超强的图表样式库、支持自定义修改数据。 幕布：和Xmind类似的思维导图软件，兼具清单管理功能。mubu.com 文字云：是一个支持中文的文字云生成工具，操作简单，而且方便！不需要翻墙。文字云地址 素材网页Iconfont-阿里巴巴矢量图标库，以及OfficePLUS，微软Office官方在线模板网站！ PPT遥控器：百度家的，PPT遥控器，只需电脑端安装，以备不时之需。 Collagelt：多图片同尺寸拼接。 Listary：和Everthing相似的文件查找工具，可以搜索软件。 天若OCR：文字识别工具，支持翻译，可以用于文献翻译。 Officelens：微软提供的扫描软件，可以一键生成word文档。 图片云Andrea Mosaic：小图片组合成大图片的软件。 全世界优秀的网站大集合：world68 SpaceSniffer：存储释放。 做PPT时有哪些神操作？你极力推荐的 Chrome 扩展有哪些？配眼镜，如何挑选眼镜框和镜片？有哪些常识或技巧？","categories":[{"name":"网页收藏","slug":"网页收藏","permalink":"http://yoursite.com/categories/网页收藏/"}],"tags":[{"name":"知乎","slug":"知乎","permalink":"http://yoursite.com/tags/知乎/"}]},{"title":"CSDN网页收藏","slug":"CSDN网页收藏","date":"2019-08-21T14:44:09.000Z","updated":"2019-08-23T03:49:34.018Z","comments":true,"path":"2019/08/21/CSDN网页收藏/","link":"","permalink":"http://yoursite.com/2019/08/21/CSDN网页收藏/","excerpt":"整理了CSDN网站上个人收藏的一堆网址！ Linux与操作系统 Linux操作系统 《嵌入式linux应用开发完全手册》核心笔记(全) 嵌入式linux学习路线参考（LINUX学习者必看经典）作为一个新人，怎样学习嵌入式Linux？linux必看书籍推荐 linux下终端分屏使用LINUX和PC之间通过串口传文件 LTP性能测试工具的使用详解LTP(Linux Test Project)学习（二）——LTP下载编译执行 内存稳定性测试软件(MemTest) Linux性能测试工具-UnixBench–安装以及结果分析 LTP–linux稳定性测试 linux性能测试 ltp压力测试 —IBM 的 linux test project Yocto 环境搭建 ubuntu16.04安装matlab2016b Ubuntu 16.04安装Matlab 2016b教程 Ubuntu16.04 Caffe 安装步骤记录（超详尽）secureCRT 实现windows和linux文件互传 vim/vi 如何高效使用(键盘图打印版)Ubuntu环境下安装nodejs和npm 使用Universal USB Installer创建安装Linux U盘系统Source Insight 4.0 最简单的破解安装 Ubuntu18.04（Gnome桌面）主题美化，Mac私人定制","text":"整理了CSDN网站上个人收藏的一堆网址！ Linux与操作系统 Linux操作系统 《嵌入式linux应用开发完全手册》核心笔记(全) 嵌入式linux学习路线参考（LINUX学习者必看经典）作为一个新人，怎样学习嵌入式Linux？linux必看书籍推荐 linux下终端分屏使用LINUX和PC之间通过串口传文件 LTP性能测试工具的使用详解LTP(Linux Test Project)学习（二）——LTP下载编译执行 内存稳定性测试软件(MemTest) Linux性能测试工具-UnixBench–安装以及结果分析 LTP–linux稳定性测试 linux性能测试 ltp压力测试 —IBM 的 linux test project Yocto 环境搭建 ubuntu16.04安装matlab2016b Ubuntu 16.04安装Matlab 2016b教程 Ubuntu16.04 Caffe 安装步骤记录（超详尽）secureCRT 实现windows和linux文件互传 vim/vi 如何高效使用(键盘图打印版)Ubuntu环境下安装nodejs和npm 使用Universal USB Installer创建安装Linux U盘系统Source Insight 4.0 最简单的破解安装 Ubuntu18.04（Gnome桌面）主题美化，Mac私人定制 进程间通信 【Linux】Linux的共享内存进程间通信——共享内存（Shared Memory）消息队列函数(msgget、msgctl、msgsnd、msgrcv)及其范例Linux守护进程Shell脚本宋宝华的blog《Linux设备驱动开发详解》作者Linux内核最新的连续内存分配器(CMA)——避免预留大块内存Linux驱动开发之 三 (那些必须要了解的硬件知识 之 存储器篇) Make Menuconfig详解 （配置内核选择）内核配置与裁剪SSH工作原理FreeRTOS实验_独立看门狗监视多线程Linux 多进程多线程编程检查进程存在的5种方法 网络编程 Linux网络编程：socket文件传输范例Linux下套接字详解（五）—-基于fork多进程的TCP套接字（阻塞/同步/并发）【Linux网络编程】基于TCP多进程（fork）版本客户端/服务器Linux下网络编程（2）——TCP多连接，1个server，多个clientLinux网络编程(2)——采用TCP的基本server的实现sockaddr_in , sockaddr , in_addr区别Socket编程函数集（非常有用）Socket进程间通信 Uboot (3)uboot详解——饿了么，我们来喂“狗”吧 [u-boot分析导读u-boot分析 七 (添加u-boot命令，学习u-boot命令实现原理)【uboot】（第六章）uboot流程——命令行模式以及命令处理介绍 Exynos4412 Uboot 移植（三）—— Uboot添加自定义命令 【ARM-Linux开发】U-Boot启动过程–详细版的完全分析 嵌入式驱动开发 内核与设备树 linux内核空间和用户空间的是怎样区别的，如何交互，如何从用户空间进入内核空间 嵌入式Linux学习步骤 Linux——linux学习全攻略 (转) Linux教程+操作系统教程linux驱动编写（总结篇） ARM Linux 3.x的设备树（Device Tree）24 设备树里描述spi设备 Linux 设备驱动开发 —— 设备树在platform设备驱动中的使用 Linux通过内核查看芯片gpio配置使用情况 linux驱动开发-文件系统与设备文件 linux内核设备树及编译 - storyteller的博客 - CSDN博客LINUX内核目录文件说明以及配置并编译内核的方法嵌入式 Linux开发Kernel移植（二）——kernel内核配置和编译 嵌入式Linux内核配置、裁剪与编译浅析（ARM版）适配ARM处理器的Linux内核 基于arm的Linux内核编译 ubuntu更新内核切换内核启动 串口通信 LINUX 简单的串口读写实例Linux下用C实现串口读写串口通信——接收串口数据并处理（C语言）基于串口uart的 xyzModem协议 的传输文件的命令 SPI Linux Kernl添加spidev的设备节点Linux系统自带spi驱动加载及应用程序编写方法详解63 linux内核的SPI设备驱动模型及应用程序调用SPI控制器的方法 SPI最大传输速率 - 坚持 - CSDN博客SPI 时钟和相位详解，转载！ PCIE接口 2016年12月问题记录与总结–PCIE调试心得 Linux PCI/PCI-E设备配置空间读取与修改 利用 PlxSdk 工具包开发 Linux 下 PCI 设备驱动 PCI接口开发笔记 Xilinx FPGA 的PCIE 设计 PCI-E 1x, 4x, 8x, 16x 接口定义 基于PLX_SDK的Linux下的PCI9054驱动程序的开发 Flash NAND FLASH （三）硬件ECC校验码详解 ECC内存校验算法实现 DDR的原理和时序 EMIF接口 DDR3详解（以Micron MT41J128M8 1Gb DDR3 SDRAM为例） NAND FLASH大页和小页 硬盘基本知识（磁道、扇区、柱面、磁头数、簇、MBR、DBR）Linux当中block块大小的面试题 nand flash 个人觉得写得比较好的文章 SDIO emmc 命令协议 eMMC之分区管理、总线协议和工作模式emmc的读写浅析 开发软件 Github与MarkDown Markdown 语法大全 包括设置字体 颜色 删除github中某个文件夹 Git使用详细教程 git使用详细介绍如何在 GitHub 上找到免费且实用的软件？Hexo个人免费博客(五) 使用自己的域名 C语言 c语言实现系统(Linux)文件权限的修改，以及系统文件的创建，写入和读取数据 读华为C语言编程规范（标识符、变量）C语言变量和函数命名规范 cmake使用示例与整理总结 CMake使用教程 如何编写CMakeListsMakefile经典教程(掌握这些足够) getopt和getopt_long函数 C与C++的区别；面向过程与面向对象的区别； FPGA FPGA 中关于LVDS引脚的配置 （Xilinx）FPGA中LVDS差分高速传输的实现LVDS，接口，时序讲解，很赞的文章 软件问题 node.js安装后输入“node -v”提示’node’ 不是内部或外部命令，也不是可运行的程序的解决方法TensorFlow Bug记录 CUBLAS_STATUS_NOT_INITIALIZED【解决】Invalid configuration aarch64-linux&#39;: machineaarch64’ not recognizeVS2013 编译程序时提示 无法查找或打开 PDB 文件 windows 64位 VS2015 “模块计算机类型“x64”与目标计算机类型“X86”冲突解决方案 联想Y7000装双系统win10+Ubuntu16.04后在Ubuntu上Wifi被禁用的解决办法 Python OpenCV 解决人脸识别报错cascade.detectMultiScale error ubuntu 下Anaconda3出现 conda：未找到命令 【解决方案】module ‘cv2.cv2’ has no attribute ‘xfeatures2d’ opencv VS2017配置opencv教程win10+VS2017下配置openCV3.4.3 Eclipse（Java）配置opencv2.4.11 人工智能 OpenCV-Python 摄像头实时检测人脸 Ubuntu16.04下运行YOLO3及相关环境配置 darknet YOLOv2安装及数据集训练 Ubuntu18.04 Caffe 安装步骤记录（超详尽） 学习TensorFlow，调用预训练好的网络（Alex, VGG, ResNet etc） Ubuntu 16.04 下keras安装和mnist测试 TensorFlow学习笔记（九）：CIFAR-10训练例子报错解决 TensorFlow CNN 测试CIFAR-10数据集【神经网络】VGG、ResNet、GoogleLeNet、AlexNet等常用网络代码及预训练模型 【云计算／大数据／人工智能】都这么火了，我居然还不知道他们是啥？看完全明白了！ubuntu 监视显卡使用情况 Ubuntu16.04下Anaconda3的安装 Linux入门(18)——Ubuntu16.04下安装spyder 华硕笔记本(GTX 1060显卡)安装Ubuntu16.04+Nvidia显卡驱动+Cuda8.0+cudnn6.0+ROS+Opencv3.2+Caffe+TensorflowUbuntu 18.04系统NVIDIA+CUDA9.1+CUDnn7.1+TensorFlow安装","categories":[{"name":"网页收藏","slug":"网页收藏","permalink":"http://yoursite.com/categories/网页收藏/"}],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://yoursite.com/tags/CSDN/"}]},{"title":"VScode WSL开发环境配置","slug":"vscode-wsl开发环境配置","date":"2019-08-10T06:40:08.000Z","updated":"2019-08-20T11:43:18.754Z","comments":true,"path":"2019/08/10/vscode-wsl开发环境配置/","link":"","permalink":"http://yoursite.com/2019/08/10/vscode-wsl开发环境配置/","excerpt":"读研期间日常写文档用windows word，工作时使用linux码代码需要来回切换操作系统，幸亏遇到wsl ubuntu解决一大难题，但配置好开发环境（使用VScode和Cmake搭建嵌入式开发环境），使用windows版本的VScode有一大弊端–无法查看linux的头文件内容，无法跳转相关的函数和变量定义，简直扎心！无意中发现插件中有一个remote wsl的，真的让人awsl！微软真香！具体可以参考搭配 VS Code Remote 远程开发扩展在 WSL 下开发。","text":"读研期间日常写文档用windows word，工作时使用linux码代码需要来回切换操作系统，幸亏遇到wsl ubuntu解决一大难题，但配置好开发环境（使用VScode和Cmake搭建嵌入式开发环境），使用windows版本的VScode有一大弊端–无法查看linux的头文件内容，无法跳转相关的函数和变量定义，简直扎心！无意中发现插件中有一个remote wsl的，真的让人awsl！微软真香！具体可以参考搭配 VS Code Remote 远程开发扩展在 WSL 下开发。 注意事项 在运行remote wsl时，需要重新安装插件，这些插件和Windows VScode不同； 在命令输入remote wsl:new window进入wsl vscode； VScode WSL是在linux下工作的，新建的终端也为linux bash，代码补全、头文件均为linux版本； 关于git中文显示乱码问题，参考：ubuntu下设定系统locale，支持中文zh_CN.UTF-8ubuntu命令行下中文乱码的解决方案语言支持安装：sudo apt install $(check-language-support) --fix-missinggit关闭编码设置：git config --global core.quotepath false","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Cmder美化WSL Ubuntu","slug":"cmder美化wsl-ubuntu","date":"2019-08-10T06:06:52.000Z","updated":"2019-08-10T06:50:19.499Z","comments":true,"path":"2019/08/10/cmder美化wsl-ubuntu/","link":"","permalink":"http://yoursite.com/2019/08/10/cmder美化wsl-ubuntu/","excerpt":"WSL Ubuntu的界面比较简陋，推荐使用cmder改良一下终端。","text":"WSL Ubuntu的界面比较简陋，推荐使用cmder改良一下终端。 下载安装cmder，下载完整版，直接运行即可。 进入wsl ubuntu在setting &gt; start up中添加 %windir%\\system32\\wsl.exe ~ -cur_console:p5，进入linux子系统。-cur_console:p5是最新的为解决vim中无法使用方向键的补丁。 配置大多数配置依照个人习惯，分屏快捷键可以搜索split。 修改ubutnu文件夹底色12345678910111213141516171819202122232425cd ~dircolors -p &gt; .dircolorsvi .dircolors修改DIR的颜色，找到下面这段（编辑器中有配色预览和注释）RESET 0 # reset to \"normal\" color DIR 04;36 # directory LINK 01;36 # symbolic link. (If you set this to 'target' instead of a # numerical value, the color is as for the file pointed to.) MULTIHARDLINK 00 # regular file with more than one link FIFO 40;33 # pipe SOCK 01;35 # socket DOOR 01;35 # door BLK 40;33;01 # block device driver CHR 40;33;01 # character device driver ORPHAN 40;31;01 # symlink to nonexistent file, or non-stat'able file ... MISSING 00 # ... and the files they point to SETUID 37;41 # file that is setuid (u+s) SETGID 30;43 # file that is setgid (g+s)CAPABILITY 30;41 # file with capabilitySTICKY_OTHER_WRITABLE 04;36 # dir that is sticky and other-writable (+t,o+w)OTHER_WRITABLE 04;36 # dir that is other-writable (o+w) and not stickySTICKY 37;44 # dir with the sticky bit set (+t) and not other-writable# This is for files with execute permission:EXEC 01;32 修改bashrc或者zshrc，在bashrc中有如下内容： 12345678910if [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors &amp;&amp; eval \"$(dircolors -b ~/.dircolors)\" || eval \"$(dircolors -b)\" alias ls='ls --color=auto' #alias dir='dir --color=auto' #alias vdir='vdir --color=auto' alias grep='grep --color=auto' alias fgrep='fgrep --color=auto' alias egrep='egrep --color=auto' fi 拷贝至zsh中，重新启动终端，ubutnu显示的文件夹再也不是亮瞎人的绿色。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Linux指令合集","slug":"跟老男孩学Linux运维","date":"2019-08-10T05:19:56.000Z","updated":"2019-08-11T13:53:17.132Z","comments":true,"path":"2019/08/10/跟老男孩学Linux运维/","link":"","permalink":"http://yoursite.com/2019/08/10/跟老男孩学Linux运维/","excerpt":"第一章 Linux命令行简介命令行提示符# 超级用户$ 普通用户 重要快捷键 快捷键 功能 ctrl+k 删除光标到末尾的字符 ctrl+u 删除光标到开头的字符 ctrl+c 删除行或者中断任务 ctrl+l clear 命令行 ctrl+r 搜索历史命令 !! 执行上一条命令","text":"第一章 Linux命令行简介命令行提示符# 超级用户$ 普通用户 重要快捷键 快捷键 功能 ctrl+k 删除光标到末尾的字符 ctrl+u 删除光标到开头的字符 ctrl+c 删除行或者中断任务 ctrl+l clear 命令行 ctrl+r 搜索历史命令 !! 执行上一条命令 查看命令帮助1man 参数选项 命令、文件 注：参数1是用户相关命令；2是系统调用；3是C的库函数相关；4是设备和特殊文件；8是系统管理员和进程。 1命令 --help 关机、重启等12shutdown -r now = rebootshutdown -h now #立即关机 第二章 文件和目录操作命令 名称 功能 备注 pwd 显示当前路径 echo $PWD 可以输出 cd 切换目录 ～ home；.. 上级；- 上次所在目录 tree 树形显示文件目录 tree -L n 显示n层；tree -F 为特殊文件增加标记 tree -L 1 -d 只显示目录 mkdir 创建目录 mkdir -p dir1/{dir1_1,dir1_2}/{dir2_1,dir2_2}/.. 可同时创建多个目录 大括号满足分配率，即1_1和1_2下都各自建立2_1和2_2 touch 创建空文件或改变文件的时间戳属性 时间戳：mtime，最后修改时间；ctime，状态改变时间；atime，最后访问时间 ls 列举目录下的内容 -t按照修改时间排序；-c按照状态改变时间排序；-u按照最后访问排序 ls --time-style=long-iso -lt 令人舒适的时间格式 `ls lrt tail -l` 显示最新更新过的文件 ls -F 显示文件类型 *可执行文件；/目录；=套接字；` cp 复制目录 cp -r递归复制，包括子目录 mv 移动或者重命名 mv A B若B不存在，则将A重命名为B","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/命令/"}]},{"title":"linux内核配置--Device drivers","slug":"linux内核配置-Device-drivers","date":"2019-07-30T15:20:57.000Z","updated":"2019-08-03T15:50:49.138Z","comments":true,"path":"2019/07/30/linux内核配置-Device-drivers/","link":"","permalink":"http://yoursite.com/2019/07/30/linux内核配置-Device-drivers/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核的配置过程依赖Makefile和arch/arm/Kconfig以及其他文件下的Kconfig文件，通过make menuconfig或者桌面环境下的xconfig/gconfig可以手动配置内核所支持的功能。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下为Device drivers启动设置的配置。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核的配置过程依赖Makefile和arch/arm/Kconfig以及其他文件下的Kconfig文件，通过make menuconfig或者桌面环境下的xconfig/gconfig可以手动配置内核所支持的功能。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下为Device drivers启动设置的配置。 Generic Driver Options ---> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/base/Kconfig [Y] Support for uevent helper&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支持uevent（例如热插拔）事件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;早年的内核(切换到基于netlink机制之前),在发生uevent事件(通常是热插拔)时,需要调用用户空间程序(通常是”/sbin/hotplug”),以帮助完成uevent事件的处理.此选项就是用于开启此功能.由于目前的发行版都已不再需要此帮助程序,所以请选”N”.此外,如果你使用了systemd或udev则必须选”N”.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The uevent helper program is forked by the kernel for every uevent. Before the switch to the netlink-based uevent source, this was used to hook hotplug scripts into kernel device events. It usually pointed to a shell script at /sbin/hotplug. This should not be used today, because usual systems create many events at bootup or device discovery in a very short time frame. One forked process per event can create so many processes that it creates a high system load, or on smaller systems it is known to create out-of-memory situations during bootup. ( ) path to uevent helper&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To disable user space helper program execution at by default specify an empty string here. This setting can still be altered via /proc/sys/kernel/hotplug or via /sys/kernel/uevent_helper later at runtime. [Y] Maintain a devtmpfs filesystem to mount at /dev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在系统/dev文件夹下挂载devtmpf文件系统。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devtmpfs是一种基于CONFIG_TMPFS的文件系统(与proc和sys有几分相似).在系统启动过程中,随着各个设备的初始化完成,内核将会自动在devtmpfs中创建相应的设备节点(使用默认的文件名和权限)并赋予正确的主次设备号.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This creates a tmpfs/ramfs filesystem instance early at bootup. In this filesystem, the kernel driver core maintains device nodes with their default names and permissions for all registered devices with an assigned major/minor number. Userspace can modify the filesystem content as needed, add symlinks, and apply needed permissions.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It provides a fully functional /dev directory, where usually udev runs on top, managing permissions and adding meaningful symlinks.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In very limited environments, it may provide a sufficient functional /dev without any further help. It also allows simple rescue systems, and reliably handles dynamic major/minor numbers.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Notice: if CONFIG_TMPFS isn’t enabled, the simpler ramfs file system will be used instead. [Y] Automount devtmpfs at /dev, after the kernel mounted the rootfs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在内核挂载根文件系统的同时，立即自动将devtmpfs挂载到”/dev”目录。因为此时init进程都还尚未启动，所以这就确保在进入用户空间之前，所有设备文件就都已经准备完毕.开启此选项相当于设置内核引导参数”devtmpfs.mount=1”，关闭此选项相当于设置内核引导参数”devtmpfs.mount=0”。开启此项后,你就可以放心的使用”init=/bin/sh”直接进入救援模式，而不必担心”/dev”目录空无一物。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意:此选项并不影响基于initramfs的启动，此种情况下，devtmpfs必须被手动挂载.所以,如果你的系统使用initrd或者有专门的启动脚本用于挂载”/dev”目录(大多数发行版都有这样的脚本)，或者你看了前面的解释，还是不确定，那就选”N”.对于实在想要使用”init=/bin/sh”直接进入救援模式的人来说，还是使用”init=/bin/sh devtmpfs.mount=1”吧!&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This will instruct the kernel to automatically mount the devtmpfs filesystem at /dev, directly after the kernel has mounted the root filesystem. The behavior can be overridden with the commandline parameter: devtmpfs.mount=0|1. This option does not affect initramfs based booting, here the devtmpfs filesystem always needs to be mounted manually after the rootfs is mounted.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;With this option enabled, it allows to bring up a system in rescue mode with init=/bin/sh, even when the /dev directory on the rootfs is completely empty. [Y] Select only drivers that don&#39;t need compile-time external firmware&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只显示那些编译时不需要额外固件支持的驱动程序，除非你有某些怪异硬件，否则请选”Y”。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select this option if you don’t have magic firmware for drivers that need it. If unsure, say Y. [Y] Prevent firmware from being built&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不编译固件(firmware)。固件一般是随硬件的驱动程序提供的，仅在更新固件的时候才需要重新编译。建议选”Y”。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say yes to avoid building firmware. Firmware is usually shipped with the driver and only when updating the firmware should a rebuild be made. If unsure, say Y here. {Y} Userspace firmware loading support&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户空间固件加载支持。如果内核自带的模块需要它，它将会被自动选中。但某些内核树之外的模块也可能需要它，这时候就需要你根据实际情况手动开启了.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option is provided for the case where none of the in-tree modules require userspace firmware loading support, but a module built out-of-tree does. [Y] Include in-kernel firmware blobs in kernel binary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核源码树中包含了许多驱动程序需要的二进制固件(blob),推荐的方法是通过”make firmware_install”将”firmware”目录中所需的固件复制到系统的”/lib/firmware/“目录中,然后由用户空间帮助程序在需要的时候进行加载.开启此项后,将会把所需的”blob”直接编译进内核,这样就可以无需用户空间程序的帮助,而直接使用这些固件了(例如:当根文件系统依赖于此类固件,而你又不想使用initrd的时候).每个需要此类二进制固件的驱动程序,都会有一个”Include firmware for xxx device”的选项,如果此处选”Y”,那么这些选项都将被隐藏.建议选”N”.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Various drivers in the kernel source tree may require firmware, which is generally available in your distribution’s linux-firmware package.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The linux-firmware package should install firmware into /lib/firmware/ on your system, so they can be loaded by userspace helpers on request.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enabling this option will build each required firmware blob specified by EXTRA_FIRMWARE into the kernel directly, where request_firmware() will find them without having to call out to userspace. This may be useful if your root file system requires a device that uses such firmware and you do not wish to use an initrd.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This single option controls the inclusion of firmware for every driver that uses request_firmware(), which avoids a proliferation of ‘Include firmware for xxx device’ options.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say ‘N’ and let firmware be loaded from userspace. ( ) External firmware blobs to build into the kernel binary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定要额外编译进内核的二进制固件(blob).此选项的值是一个空格分隔的固件文件名字符串,这些文件必须位于CONFIG_EXTRA_FIRMWARE_DIR目录中(其默认值是内核源码树下的”firmware”目录).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option allows firmware to be built into the kernel for the case where the user either cannot or doesn’t want to provide it from userspace at runtime (for example, when the firmware in question is required for accessing the boot device, and the user doesn’t want to use an initrd).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option is a string and takes the (space-separated) names of the firmware files – the same names that appear in MODULE_FIRMWARE() and request_firmware() in the source. These files should exist under the directory specified by the EXTRA_FIRMWARE_DIR option, which is by default the firmware subdirectory of the kernel source tree.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For example, you might set CONFIG_EXTRA_FIRMWARE=”usb8388.bin”, copy the usb8388.bin file into the firmware directory, and build the kernel. Then any request_firmware(“usb8388.bin”) will be satisfied internally without needing to call out to userspace.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WARNING: If you include additional firmware files into your binary kernel image that are not available under the terms of the GPL, then it may be a violation of the GPL to distribute the resulting image since it combines both GPL and non-GPL work. You should consult a lawyer of your own before distributing such an image. [N] Fallback user-helper invocation for firmware loading&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在内核自己直接加载固件失败后,作为补救措施,调用用户空间帮助程序(通常是udev)再次尝试加载.通常这个动作是不必要的,因此应该选”N”,如果你使用了udev或systemd,则必须选”N”.仅在某些特殊的固件位于非标准位置时,才需要选”Y”.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option enables / disables the invocation of user-helper (e.g. udev) for loading firmware files as a fallback after the direct file loading in kernel fails. The user-mode helper is no longer required unless you have a special firmware file that resides in a non-standard path. Moreover, the udev support has been deprecated upstream.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you are unsure about this, say N here. [Y] Allow device coredump&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为驱动程序开启core dump机制,仅供调试.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;核心转储（core dump），是操作系统在进程收到某些信号而终止运行时，将此时进程地址空间的内容以及有关进程状态的其他信息写出的一个磁盘文件，这种信息往往用于调试，可以用gdb来调试。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option controls if the device coredump mechanism is available or not; if disabled, the mechanism will be omitted even if drivers that can use it are enabled.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say ‘N’ for more sensitive systems or systems that don’t want to ever access the information to not have the code, nor keep any data.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say Y. [N] Driver Core verbose debug messages&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让驱动程序核心在系统日志中产生冗长的调试信息,仅供调试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here if you want the Driver core to produce a bunch of debug messages to the system log. Select this if you are having a problem with the driver core and want to see more of what is going on.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you are unsure about this, say N here. [N] Managed device resources verbose debug messages&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为内核添加一个”devres.log”引导参数.当被设为非零值时,将会打印出设备资源管理驱动(devres)的调试信息.仅供调试使用.推荐设置为N。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option enables kernel parameter devres.log. If set to non-zero, devres debug messages are printed. Select this if you are having a problem with devres or want to debug resource management for a managed device. devres.log can be switched on and off from sysfs node.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you are unsure about this, Say N here. [N] Test driver remove calls during probe (UNSTABLE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here if you want the Driver core to test driver remove functions by calling probe, remove, probe. This tests the remove path without having to unbind the driver or unload the driver module. This option is expected to find errors and may render your system unusable. You should say N here unless you are explicitly looking to test this functionality. &lt;N&gt; Build kernel module to test asynchronous driver probing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enabling this option produces a kernel module that allows testing asynchronous driver probing by the device core. The module name will be test_async_driver_probe.ko&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure say N. [N] Enable verbose DMA_FENCE_TRACE messages&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable the DMA_FENCE_TRACE printks. This will add extra spam to the console log, but will make it easier to diagnose lockup related problems for dma-buffers shared across multiple devices. [Y] DMA Contiguous Memory Allocator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This enables the Contiguous Memory Allocator which allows drivers to allocate big physically-contiguous blocks of memory for use with hardware components that do not support I/O map nor scatter-gather.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You can disable CMA by specifying “cma=0” on the kernel’s command line.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For more information see &lt;include/linux/dma-contiguous.h&gt;. If unsure, say “n”. ***Default contiguous memory area size:*** (24) Size in Mega Bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default 0 if X86&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines the size (in MiB) of the default memory area for Contiguous Memory Allocator. If the size of 0 is selected, CMA is disabled by default, but it can be enabled by passing cma=size[MG] to the kernel. (C) Selected region size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(X) Use mega bytes value only&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N) Use percentage value only&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N) Use lower value (minimum)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N) Use higher value (maximum) (8) Maximum PAGE_SIZE order of alignment for contiguous buffers Bus Devices ---> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/bus/Kconfig&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总线设备.此类设备仅出现在ARM平台。下列是勾选的： &lt;Y&gt; OMAP INTERCONNECT DRIVER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支持TI的omap开放式多媒体应用平台 &lt;Y&gt; OMAP OCP2SCP DRIVER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ocp/scp协议 &lt;Y&gt; Simple Power-Managed Bus Driver&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;电源管理总线 < > Connector - unified userspace kernelspace linker &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;连接器是一种新的用户态与内核态的通信方式，它使用起来非常方便。本质上，连接器是一种netlink，它的netlink协议号为 NETLINK_CONNECTOR，与一般的 netlink 相比，它提供了更容易的使用接口，使用起来更方便。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Connector driver makes it easy to connect various agents using a netlink based network. One must register a callback and an identifier. When the driver receives a special netlink message with the appropriate identifier, the appropriate callback will be called. Memory Technology Device (MTD) support ---> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;详细参考/drivers/mtd/Kconfig。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MTD子系统是一个闪存转换层。其主要目的是提供一个介于闪存硬件驱动程序与高级应用程序之间的抽象层，以简化闪存设备的驱动。注意：MTD常用于嵌入式系统，而我们常见的U盘/MMC卡/SD卡/CF卡等移动存储设备以及固态硬盘(SSD)，虽然也叫”flash”，但它们并不是使用MTD技术的存储器。仅在你需要使用主设备号为31的MTD块设备(/dev/romX、/dev/rromX、/dev/flashX、/dev/rflashX)，或者主设备号为90的MTD字符设备(/dev/mtdX、/dev/mtdrX)时选”Y”，否则选”N”。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Memory Technology Devices are flash, RAM and similar chips, often used for solid state file systems on embedded devices. This option will provide the generic support for MTD drivers to register themselves with the kernel and for potential users of MTD devices to enumerate the devices which are present and obtain a handle on them. It will also allow you to select individual drivers for particular hardware and users of MTD devices. If unsure, say N. -Y- Device Tree and Open Firmware support ---> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/mtd/Kconfig。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device Tree基础架构与Open Firmware支持，主要用于嵌入式环境。不确定的选”N”。内核中若有其它选项依赖于它，则会自动选中此项。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option enables the device tree infrastructure. It is automatically selected by platforms that need it or can be enabled manually for unit tests, overlays or compile-coverage. < > Parallel port support ----- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/parport/Kconfig。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25针并口(LPT接口)支持，古董级的打印机或扫描仪可能使用这种接口。目前已被淘汰。If you want to use devices connected to your machine’s parallel port (the connector at the computer with 25 holes), e.g. printer, ZIP drive, PLIP link (Parallel Line Internet Protocol is mainly used to create a mini network by connecting the parallel ports of two local machines) etc., then you need to say Y here; please read file:Documentation/parport.txt and file:drivers/parport/BUGS-parport.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For extensive information about drivers for many devices attaching to the parallel port see http://www.torque.net/linux-pp.html on the WWW. It is possible to share a single parallel port among several devices and it is safe to compile all the corresponding drivers into the kernel. To compile parallel port support as a module, choose M here: the module will be called parport. If you have more than one parallel port and want to specify which port and IRQ to be used by this driver at module load time, take a look at file:Documentation/parport.txt.If unsure, say Y. [Y] Block devices块设备，必选。参考：/drivers/block/Kconfig。Say Y here to get to see options for various different block device drivers. This option alone does not add any kernel code.If you say N, all options in this submenu will be skipped and disabled; only do this if you know what you are doing.下列是勾选的： Loopback device support在进行某些测试的时候，往往需要新建一些磁盘分区或者设备（ISO9660镜像文件或者CD-ROM）等，此时对硬盘进行重新划分往往不太方便。在这种情况下，可以通过loop伪设备来实现循环挂载，从而达到目的。在使用之前，循环设备必须与现存文件系统上的文件相关联。这种关联将提供给用户一个应用程序接口，接口将允许文件视为块特殊文件（参见设备文件系统）使用。因此，如果文件中包含一个完整的文件系统，那么这个文件就能如同磁盘设备一般被挂载。这种设备文件经常被用于光盘或是磁盘镜像。通过循环挂载来挂载包含文件系统的文件，便使处在这个文件系统中的文件得以被访问。这些文件将出现在挂载点目录。在Linux中，设备名按照相应设备驱动程序的符号表项进行命名。这些设备被叫做“loop”设备，设备节点通常命名为/dev/loop0、/dev/loop1之类。默认情况下Linux支持的loop设备是8个。如果需要超过8个的loop设备，那么可能会遇到类似的错误“no such device”或“could not find any free loop device”，这是因为超过了可用loop设置设备的最大限制。Saying Y here will allow you to use a regular file as a block device; you can then create a file system on that block device and mount it just as you would mount other block devices such as hard drive partitions, CD-ROM drives or floppy drives. The loop devices are block special device files with major number 7 and typically called /dev/loop0, /dev/loop1 etc.This is useful if you want to check an ISO 9660 file system before burning the CD, or if you want to use floppy images without first writing them to floppy. Furthermore, some Linux distributions avoid the need for a dedicated Linux partition by keeping their complete root file system inside a DOS FAT file using this loop device driver.To use the loop device, you need the losetup utility, found in the util-linux package, see https://www.kernel.org/pub/linux/utils/util-linux/.The loop device driver can also be used to “hide” a file system in a disk partition, floppy, or regular file, either using encryption (scrambling the data) or steganography (hiding the data in the low bits of, say, a sound file). This is also safe if the file resides on a remote file server.There are several ways of encrypting disks. Some of these require kernel patches. The vanilla kernel offers the cryptoloop option and a Device Mapper target (which is superior, as it supports all file systems). If you want to use the cryptoloop, say Y to both LOOP and CRYPTOLOOP, and make sure you have a recent (version 2.12 or later) version of util-linux. Additionally, be aware that the cryptoloop is not safe for storing journaled filesystems.Note that this loop device has nothing to do with the loopback device used for network connections from the machine to itself. To compile this driver as a module, choose M here: the module will be called loop.Most users will answer N here.(8) Number of loop devices to pre-create at init time设置loop分区启动时默认分配的个数。 RAM block device support在内存中开辟一个和普通存储同样支持读写的块设备，一般用于启动时存放一个最小文件系统。详细参考file:Documentation/blockdev/ramdisk.txt，一般选择N。Saying Y here will allow you to use a portion of your RAM memory as a block device, so that you can make file systems on it, read and write to it and do all the other things that you can do with normal block devices (such as hard drives). It is usually used to load and store a copy of a minimal root file system off of a floppy into RAM during the initial install of Linux.Note that the kernel command line option “ramdisk=XX” is now obsolete. For details, read file:Documentation/blockdev/ramdisk.txt.To compile this driver as a module, choose M here: the module will be called brd. An alias “rd” has been defined for historical reasons.Most normal users won’t need the RAM disk functionality, and can thus say N here.(16) Default number of RAM disks设置默认RAM disks的个数。(65536) Default RAM disk size (kbytes)设置默认大小。 Virtio block driverVirtio虚拟块设备驱动，仅可用在基于lguest或QEMU的半虚拟化客户机中(一般是KVM或XEN)。This is the virtual block driver for virtio. It can be used with QEMU based VMMs (like KVM or Xen). Say Y or M. < > NVM Express block device &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NVM Express是专门针对PCI-E接口高性能固态硬盘的标准规范。有了这一标准，操作系统厂商只需要编写一种驱动，就可以支持不同厂商的不同PCI-E SSD设备，以解决过去PCI-E SSD产品形态与规格五花八门，缺乏通用性和互用性的问题。如果你有一块较新的PCIE固态硬盘，那么很大可能就是NVMe接口。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The NVM Express driver is for solid state drives directly connected to the PCI or PCI Express bus. If you know you don’t have one of these, it is safe to answer N. To compile this driver as a module, choose M here: the module will be called nvme. < > NVM Express over Fabrics FC host driver &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This provides support for the NVMe over Fabrics protocol using the FC transport.This allows you to use remote block devices exported using the NVMe protocol set.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To configure a NVMe over Fabrics controller use the nvme-cli tool from https://github.com/linux-nvme/nvme-cli. If unsure, say N. NVMe Target supportThis enabled target side support for the NVMe protocol, that is it allows the Linux kernel to implement NVMe subsystems and controllers and export Linux block devices as NVMe namespaces. You need to select at least one of the transports below to make this functionality useful.To configure the NVMe target you probably want to use the nvmetcli tool from http://git.infradead.org/users/hch/nvmetcli.git. Misc devices —&gt;其他设备。以下是勾选的： Analog Devices Digital PotentiometersIf you say yes here, you get support for the Analog Devices AD5258, AD5259, AD5251, AD5252, AD5253, AD5254, AD5255 AD5160, AD5161, AD5162, AD5165, AD5200, AD5201, AD5203, AD5204, AD5206, AD5207, AD5231, AD5232, AD5233, AD5235, AD5260, AD5262, AD5263, AD5290, AD5291, AD5292, AD5293, AD7376, AD8400, AD8402, AD8403, ADN2850, AD5241, AD5242, AD5243, AD5245, AD5246, AD5247, AD5248, AD5280, AD5282, ADN2860, AD5273, AD5171, AD5170, AD5172, AD5173, AD5270, AD5271, AD5272, AD5274 digital potentiometer chips.See Documentation/misc-devices/ad525x_dpot.txt for the userspace interface.This driver can also be built as a module. If so, the module will be called ad525x_dpot. support I2C bus connectionSay Y here if you have a digital potentiometers hooked to an I2C bus. To compile this driver as a module, choose M here: the module will be called ad525x_dpot-i2c. Integrated Circuits ICS932S401依赖I2C驱动。IDT ICS932S401系列时钟频率控制芯片支持(可能会出现在某些主板上)。If you say yes here you get support for the Integrated Circuits ICS932S401 clock control chips. This driver can also be built as a module. If so, the module will be called ics932s401. Medfield Avago APDS9802 ALS Sensor module依赖I2C驱动。If you say yes here you get support for the ALS APDS9802 ambient light sensor.This driver can also be built as a module. If so, the module will be called apds9802als. Intersil ISL29003 ambient light sensor依赖I2C和SYSFS驱动。If you say yes here you get support for the Intersil ISL29003ambient light sensor. This driver can also be built as a module. If so, the module will be called isl29003.[Y] Generic on-chip SRAM driver许多SoC系统都有芯片内嵌的SRAM。开启此项后，就可以声明将此段内存范围交给通用内存分配器(genalloc)管理。不确定的选”N”。This driver allows you to declare a memory region to be managed by the genalloc API. It is supposed to be used for small on-chip SRAM areas found on many SoCs. PCI Endpoint Test driverPCI相关。Enable this configuration option to enable the host side test driver for PCI Endpoint.EEPROM support —&gt;一些eeprom设备的支持。 I2C EEPROMs / RAMs / ROMs from most vendors-Y- EEPROM 93CX6 support ATA/ATAPI/MFM/RLL support (DEPRECATED) —-已被废弃的IDE硬盘和ATAPI光驱等接口的驱动(已被CONFIG_ATA取代)。 SCSI device support —&gt;如果有SCSI（小型计算机系统接口）设备，例如硬盘、软驱、光驱、打印机以及扫描仪等，就需要勾选。参考：/drivers/scsi/support。If you want to use a SCSI hard disk, SCSI tape drive, SCSI CD-ROM or any other SCSI device under Linux, say Y and make sure that you know the name of your SCSI host adapter (the card inside your computer that “speaks” the SCSI protocol, also called SCSI controller), because you will be asked for it.You also need to say Y here if you have a device which speaks the SCSI protocol. Examples of this include the parallel port version of the IOMEGA ZIP drive, USB storage devices, Fibre Channel, and FireWire storage.To compile this driver as a module, choose M here and read file:Documentation/scsi/scsi.txt. The module will be called scsi_mod.However, do not compile this as a module if your root file system (the one containing the directory /) is located on a SCSI device.下列为勾选的子项：{M} SCSI device supportSCSI协议支持。有任何SCSI/SAS/SATA/USB/Fibre Channel/FireWire设备之一就必须选上，选”Y”。注意USB设备驱动也需要此项支持！[Y] legacy /proc/scsi/ support过时的/proc/scsi/接口。某些老旧的刻录程序可能需要它，建议选”N”。 SCSI disk support使用SCSI/SAS/SATA/PATA/USB/Fibre Channel存储设备的必选，选”Y”。 SCSI CDROM support通过SCSI/FireWire/USB/SATA/IDE接口连接的DVD/CD驱动器(基本上涵盖了所有常见的接口)。 [Y] SCSI low-level drivers —&gt;底层SCSI驱动程序。 Serial ATA and Parallel ATA drivers (libata) —&gt;SATA与PATA(IDE)设备。桌面级PC以及低端服务器的硬盘基本都是此种接口。参考：/drivers/ata/Kconfig。If you want to use an ATA hard disk, ATA tape drive, ATA CD-ROM or any other ATA device under Linux, say Y and make sure that you know the name of your ATA host adapter (the card inside your computer that “speaks” the ATA protocol, also called ATA controller), because you will be asked for it.NOTE: ATA enables basic SCSI support; however, ‘SCSI disk support’, ‘SCSI tape support’, or ‘SCSI CDROM support’ may also be needed, depending on your hardware configuration. [N] Multiple devices driver support (RAID and LVM) —-多设备支持(RAID和LVM)。RAID和LVM的功能是使用多个物理设备组建成一个单独的逻辑设备。参考：drivers/md/Kconfig。Support multiple physical spindles through a single logical device. Required for RAID and logical volume management. Generic Target Core Mod (TCM) and ConfigFS Infrastructure —-通用TCM存储引擎与ConfigFS虚拟文件系统(/sys/kernel/config)支持，看不懂就说明你不需要。参考：drivers/target/Kconfig。Say Y or M here to enable the TCM Storage Engine and ConfigFS enabled control path for target_core_mod. This includes built-in TCM RAMDISK subsystem logic for virtual LUN 0 access. [N] Fusion MPT device support —-Fusion MPT(Message Passing Technology) 是 LSI Logic 公司为了更容易实现SCSI和光纤通道而提出的技术，支持Ultra320 SCSI/光纤通道/SAS。参考：drivers/message/fusion/Kconfig。Say Y here to get to see options for Fusion Message Passing Technology (MPT) drivers.This option alone does not add any kernel code.If you say N, all options in this submenu will be skipped and disabled. IEEE 1394 (FireWire) support —&gt;火线(IEEE 1394)是苹果公司开发的串行接口，类似于USB，但PC上并不常见，算得上是个没有未来的技术了。参考：drivers/firewire/Kconfig。 [Y] Network device support —&gt;网络设备。除非你不想连接任何网络，否则必选”Y”。参考：drivers/net/Kconfig。You can say N here if you don’t intend to connect your Linux box to any other computer at all.You’ll have to say Y if your computer contains a network card that you want to use under Linux. If you are going to run SLIP or PPP over telephone line or null modem cable you need say Y here. Connecting two machines with parallel ports using PLIP needs this, as well as AX.25/KISS for sending Internet traffic over amateur radio links.See also “The Linux Network Administrator’s Guide” by Olaf Kirch and Terry Dawson. Available at http://www.tldp.org/guides.html. If unsure, say Y.下列为勾选的：[Y] Network core driver support如果你不想使用任何高级网络功能(拨号网络/EQL/VLAN/bridging/bonding/team/光纤通道/虚拟网络等)，仅仅是一般性质的联网(普通低端服务器，通过路由器或者局域网上网的常规个人电脑或办公电脑)，可以选”N”。You can say N here if you do not intend to use any of the networking core drivers (i.e. VLAN, bridging, bonding, etc.) Dummy net driver supportDummy网络接口本质上是一个可以配置IP地址的bit-bucket(位桶，所有发送到此设备的流量都将被湮灭)，以使应用程序看上去正在和一个常规的网络接口进行通信。使用SLIP(小猫拨号，目前应该已经绝迹了)或PPP(常用于PPPoE ADSL)的用户需要它。This is essentially a bit-bucket device (i.e. traffic you send to this device is consigned into oblivion) with a configurable IP address. It is most commonly used in order to make your currently inactive SLIP address seem like a real address for local programs.If you use SLIP or PPP, you might want to say Y here. It won’t enlarge your kernel. What a deal. Read about it in the Network Administrator’s Guide, available from http://www.tldp.org/docs.html#guide.To compile this driver as a module, choose M here: the module will be called dummy. MAC-VLAN supportMAC-VLAN是通过MAC地址来划分VLAN的方式,在Linux则用来给网卡添加多个MAC地址。你可以使用”ip link add link [ address MAC ] [ NAME ] type macvlan”命令创建一个虚拟的”macvlan”设备(系统会自动打开网卡的混杂模式)，然后就可以在同一个物理网卡上虚拟出多个以太网口。Docker依赖于它.This allows one to create virtual interfaces that map packets to or from specific MAC addresses to a particular interface.Macvlan devices can be added using the “ip” command from the iproute2 package starting with the iproute2-2.6.23 release:”ip link add link [ address MAC ] [ NAME ] type macvlan”To compile this driver as a module, choose M here: the module will be called macvlan. Virtual eXtensible Local Area Network (VXLAN)“vxlan”虚拟接口可以在第三层网络上创建第二层网络(跨多个物理IP子网的虚拟二层子网)，是一种在UDP中封装MAC的简单机制，主要用于虚拟化环境下的隧道虚拟网络(tunnel virtual network)。This allows one to create vxlan virtual interfaces that provide Layer 2 Networks over Layer 3 Networks. VXLAN is often used to tunnel virtual network infrastructure in virtualized environments.For more information see: http://tools.ietf.org/html/draft-mahalingam-dutt-dcops-vxlan-02To compile this driver as a module, choose M here: the module will be called vxlan. Virtual ethernet pair device该驱动提供了一个本地以太网隧道(设备会被成对的创建)，Docker依赖于它。This device is a local ethernet tunnel. Devices are created in pairs. When one end receives the packet it appears on its pair and vice versa. Virtio network drivervirtio虚拟网卡驱动，仅可用在基于lguest或QEMU的半虚拟化客户机中(一般是KVM或XEN)。This is the virtual network driver for virtio. It can be used with QEMU based VMMs (like KVM or Xen). Say Y or M.[Y] Ethernet driver support —&gt;最常见的以太网卡驱动，针对各厂商。参考：drivers/net/ethernet/Kconfig。This section contains all the Ethernet device drivers-Y- MDIO bus device drivers —-MDIO devices and driver infrastructure code.-Y- PHY Device support and infrastructure —&gt;数据链路层芯片简称为MAC控制器，物理层芯片简称之为PHY，通常的网卡把MAC和PHY的功能做到了一颗芯片中，但也有一些仅含PHY的“软网卡”。此选项就是对这些“软网卡”的支持。请根据实际情况选择其下的子项，参考：drivers/net/phy/Kconfig。Ethernet controllers are usually attached to PHY devices. This option provides infrastructure for managing PHY devices. USB Network Adapters —&gt;USB网络适配器，参考：drivers/net/usb/Kconfig。[Y] Wireless LAN —&gt;无线网卡，参考：drivers/net/wireless/Kconfig。 [N] Open-Channel SSD target support —-Open-channel SSD 是一种遵守NVMe规范且不使用FTL技术的固态硬盘。目前此种SSD由于过于前卫还非常罕见，但是非常有前途。参考：drivers/lightnvm/Kconfig。 Input device support —&gt;输入设备。参考：drivers/input/Kconfig。下列为勾选项：-Y- Generic input layer (needed for keyboard, mouse, …)通用输入层。只要你有任何输入设备(键盘、鼠标、手写板、触摸板、游戏杆、方向盘,游戏键盘…)，就必须选”Y”。Say Y here if you have any input device (mouse, keyboard, tablet, joystick, steering wheel …) connected to your system and want it to be available to applications. This includes standard PS/2 keyboard and mouse.Say N here if you have a headless (no monitor, no keyboard) system.More information is available: file:Documentation/input/input.txtIf unsure, say Y.To compile this driver as a module, choose M here: the module will be called input. Export input device LEDs in sysfs将输入设备上的LED指示灯当作标准的LED类设备导出到sysfs中。不确定的选”Y”。{M} Polled input device skeleton使用轮询机制的输入设备支持，此项主要是为源码树之外的驱动准备的，内核自带的驱动若有需要会自动选中，不确定的选”N”。{M} Matrix keymap support library使用”matrix keymap”的输入设备支持，此项主要是为源码树之外的驱动准备的，内核自带的驱动若有需要会自动选中，不确定的选”N”。 Joystick interface游戏杆(joystick)和游戏键盘(gamepad)支持(/dev/input/jsX)。 Event interface将所有的输入设备事件都通过”/dev/input/eventX”以一种通用的方式进行处理.Xorg需要使用此接口，不确定的选”Y”。Say Y here if you want your input device events be accessible under char device 13:64+ - /dev/input/eventX in a generic way. To compile this driver as a module, choose M here: the module will be called evdev.[Y] Keyboards —&gt;键盘。[Y] Mice —&gt;鼠标。[Y] Touchscreens —&gt;触摸屏。[Y] Miscellaneous devices —&gt;其他杂项输入，支持GPIO、SPI、I2C，参考：drivers/input/misc/Kconfig。Say Y here, and a list of miscellaneous input drivers will be displayed. Everything that didn’t fit into the other categories is here. This option doesn’t affect the kernel. Character devices —&gt;字符设备。下列为勾选项：[Y] Enable TTY字符终端和串口都需要TTY的支持，选”Y”。参考/drivers/tty/Kconfig。Allows you to remove TTY support which can save space, and blocks features that require TTY from inclusion in the kernel. TTY is required for any text terminals or serial port communication. Most users should leave this enabled.[Y] Virtual terminal虚拟终端可以在一个物理终端设备上虚拟出多个”显示器+键盘”的组合(可以使用”Alt+Fn”组合键在多个虚拟终端间切换)，除非是嵌入式系统，否则必选”Y”。If you say Y here, you will get support for terminal devices with display and keyboard devices. These are called “virtual” because you can run several virtual terminals (also called virtual consoles) on one physical terminal. This is rather useful, for example one virtual terminal can collect system messages and warnings, another one can be used for a text-mode user session, and a third could run an X session, all in parallel. Switching between virtual terminals is done with certain key combinations, usually Alt-.The setterm command (“man setterm”) can be used to change the properties (such as colors or beeping) of a virtual terminal. The man page console_codes(4) (“man console_codes”) contains the special character sequences that can be used to change those properties directly. The fonts used on virtual terminals can be changed with the setfont (“man setfont”) command and the key bindings are defined with the loadkeys (“man loadkeys”) command.You need at least one virtual terminal device in order to make use of your keyboard and monitor. Therefore, only people configuring an embedded system would want to say N here in order to save some memory; the only way to log into such a system is then via a serial or network connection.If unsure, say Y, or else you won’t be able to do much with your new shiny Linux system :-)[Y] Enable character translations in console在虚拟控制台(console)上支持字体映射和Unicode转换。[Y] Support for console on virtual terminal内核默认将第一个虚拟终端(/dev/tty0)用作系统控制台(可以通过”console=tty3”这样的参数去修改)，将诸如模块错误/内核错误/启动信息之类的警告信息发送到这里，而且以单用户模式登录时也需要使用这个控制台。若选”N”则会导致黑屏，除非是嵌入式系统，否则必选”Y”。-Y- Support for binding and unbinding console drivers虚拟终端是通过控制台驱动程序与物理终端交互的，但在某些系统上可以使用多个控制台驱动程序(如framebuffer控制台驱动程序)，该选项使得你可以选择其中之一。[Y] Unix98 PTY support伪终端(PTY)是指一个”软件终端”，它是由slave(等价于一个物理终端)和master(被一个诸如xterm之类的进程用来读写slave设备)两部分组成的软设备。图形界面用户与需要支持ssh/telnet远程登录者必选。A pseudo terminal (PTY) is a software device consisting of two halves: a master and a slave. The slave device behaves identical to a physical terminal; the master device is used by a process to read data from and write data to the slave, thereby emulating a terminal. Typical programs for the master side are telnet servers and xterms.Linux has traditionally used the BSD-like names /dev/ptyxx for masters and /dev/ttyxx for slaves of pseudo terminals. This scheme has a number of problems. The GNU C library glibc 2.1 and later, however, supports the Unix98 naming standard: in order to acquire a pseudo terminal, a process opens /dev/ptmx; the number of the pseudo terminal is then made available to the process and the pseudo terminal slave can be accessed as /dev/pts/. What was traditionally /dev/ttyp2 will then be /dev/pts/2, for example.All modern Linux systems use the Unix98 ptys. Say Y unless you’re on an embedded system and want to conserve memory.[Y] Legacy (BSD) PTY support使用过时的BSD风格的/dev/ptyxx作为master，/dev/ttyxx作为slave，这个方案有一些安全问题，建议选”N”。A pseudo terminal (PTY) is a software device consisting of two halves: a master and a slave. The slave device behaves identical to a physical terminal; the master device is used by a process to read data from and write data to the slave, thereby emulating a terminal. Typical programs for the master side are telnet servers and xterms.Linux has traditionally used the BSD-like names /dev/ptyxx for masters and /dev/ttyxx for slaves of pseudo terminals. This scheme has a number of problems, including security. This option enables these legacy devices; on most systems, it is safe to say N.(256) Maximum number of legacy PTY in useThe maximum number of legacy PTYs that can be used at any one time. The default is 256, and should be more than enough. Embedded systems may want to reduce this to save memory. When not in use, each legacy PTY occupies 12 bytes on 32-bit architectures and 24 bytes on 64-bit architectures.[Y] /dev/mem virtual device support“/dev/mem”虚拟设备是整个处理器地址空间的全映射(包括所有物理内存/设备IO空间/总线映射空间)，可以用来直接存取物理内存，常用于访问物理IO设备，例如dmidecode工具可以从中提取系统识别信息(序列号、制造商、型号、等等)，或者Xorg可以用来访问显卡的物理内存或者实现用户空间驱动，同时拥有root权限的攻击者也可以使用它完成很多标准rootkit的行为。如果你需要使用用户空间的驱动或不确定，那么选”Y”。如果你觉得安全特别重要，可以选”N”。Serial drivers —&gt;串口(COM)驱动,串口在台式机主板上正在逐渐消亡,而在笔记本和服务器上早就已经绝迹了.大多数人应该将所有子项都选”N”。但在嵌入式系统仍然使用，参考/drivers/tty/serial/Kconfig。下列为勾选项： 8250/16550 and compatible serial support这是标准串口(COM)驱动，只要你想使用串口，就必选此项。 Support for OMAP internal UART (8250 based driver)TI OMAP平台芯片可选。If you have a machine based on an Texas Instruments OMAP CPU you can enable its onboard serial ports by enabling this option. This driver uses ttyS instead of ttyO.[Y] Replace ttyO with ttyS将ttyO代替为ttyS。This option replaces the “console=ttyO” argument with the matching ttyS argument if the user did not specified it on the command line. This ensures that the user can see the kernel output during boot which he wouldn’t see otherwise. The getty has still to be configured for ttyS instead of ttyO regardless of this option. This option is intended for people who “automatically” enable this driver without knowing that this driver requires a different console= argument. If you read this, please keep this option disabled and instead update your kernel command line. If you prepare a kernel for a distribution or other kind of larger user base then you probably want to keep this option enabled. Otherwise people might complain about a not booting kernel because the serial console remains silent in case they forgot to update the command line. Devicetree based probing for 8250 ports没有相关资料默认选择。This option is used for all 8250 compatible serial ports that are probed through devicetree, including Open Firmware based PowerPC systems and embedded systems on architectures using the flattened device tree format. Broadcom BCM63xx/BCM33xx UART support没有相关资料默认选择。This enables the driver for the onchip UART core found on the following chipsets:BCM33xx (cable modem)BCM63xx/BCM63xxx (DSL)BCM68xx (PON)BCM7xxx (STB) - DOCSIS console Virtio consoleVirtio虚拟控制台设备驱动，此外，该驱动还可以作为普通的串口设备(/dev/vportNpX)，用于客户机和宿主机之间的通信。仅可用在基于lguest或QEMU的半虚拟化客户机中(一般是KVM或XEN)。参考：drivers/char/Kconfig。Also serves as a general-purpose serial device for data transfer between the guest and host. Character devices at /dev/vportNpn will be created when corresponding ports are found, where N is the device number and n is the port number within that device. If specified by the host, a sysfs attribute called ‘name’ will be populated with a name for the port which can be used by udev scripts to create a symlink to the device. Hardware Random Number Generator Core support —&gt;硬件随机数发生器设备(/dev/hw_random)支持。此设备并不会直接向内核的随机数发生器填充(这是”rngd”守护进程的职责)。详情参见”Documentation/hw_random.txt”文档。参考：drivers/char/hw_random/Kconfig。Hardware Random Number Generator Core infrastructure.To compile this driver as a module, choose M here: the module will be called rng-core. This provides a device that’s usually called /dev/hwrng, and which exposes one of possibly several hardware random number generators.These hardware random number generators do feed into the kernel’s random number generator entropy pool.If unsure, say Y.[Y] /dev/port character device参考：drivers/char/KconfigSay Y here if you want to support the /dev/port device. The /dev/port device is similar to /dev/mem, but for I/O ports.I2C support —&gt; -Y- I2C supportI2C与SMBus支持，I2C(读着”I-squared-C”)是用于单片机(又称”微控制器”)的低速串行总线协议,它为微控制器(Microcontroller)与各种不同的低速设备通信提供了一种廉价的总线(因为只需要使用两个引脚,称为”2线”)，因此广泛的应用于嵌入式环境.SMBus(System Management Bus)差不多相当于是I2C的子集，最初的目的是为了管理智能电池，现在常用于硬件监控(电压/风扇转速/温度/电池等)以及内存模块的配置(使用I2C EEPROM)，因此所有PC主板都依赖于SMBus协议。系统硬件监控工具lm_sensors和i2c-tools依赖于此模块，硬件传感器和”Video For Linux”也需要该模块的支持。详情参见”Documentation/i2c/summary”文档及整个”i2c”文件夹。不确定的选”Y”。参考：/drivers/i2c/Kconfig。I2C (pronounce: I-squared-C) is a slow serial bus protocol used in many micro controller applications and developed by Philips. SMBus, or System Management Bus is a subset of the I2C protocol. More information is contained in the directory file:Documentation/i2c/, especially in the file called “summary” there.Both I2C and SMBus are supported here. You will need this for hardware sensors support, and also for Video For Linux support.If you want I2C support, you should say Y here and also to the specific driver for your bus adapter(s) below.This I2C support can also be built as a module. If so, the module will be called i2c-core. [Y] SPI support —&gt;串行外设接口(Serial Peripheral Interface)是一种标准的四线同步双向串行总线，SPI类似于I2C，但比I2C的”2线”稍微复杂一些，SPI需要4个引脚(“4线”)，不但传输速率比I2C更高，还能实现全双工通信。大多数SPI设备不支持动态设备检测，有些甚至是只读或者只写的。SPI常用于微控制器(Microcontroller)与外围设备(RTC、传感器、EEPROM、FLASH、解/编码器、模数转换器、数字信号处理器)之间的通信，MMC和SD卡也可以通过SPI协议访问，而MMC接口的DataFlash卡则必须通过SPI才能访问。仅用于嵌入式环境，PC平台上没有这样的设备。参考：drivers/spi/Kconfig。The “Serial Peripheral Interface” is a low level synchronous protocol. Chips that support SPI can have data transfer rates up to several tens of Mbit/sec. Chips are addressed with a controller and a chipselect. Most SPI slaves don’t support dynamic device discovery; some are even write-only or read-only.SPI is widely used by microcontrollers to talk with sensors, eeprom and flash memory, codecs and various other controller chips, analog to digital (and d-to-a) converters, and more. MMC and SD cards can be accessed using SPI protocol; and for DataFlash cards used in MMC sockets, SPI must always be used.SPI is one of a family of similar protocols using a four wire interface (select, clock, data in, data out) including Microwire (half duplex), SSP, SSI, and PSP. This driver framework should work with most such devices and controllers.重要的子项： User mode SPI device driver supportThis supports user mode SPI protocol drivers. Note that this application programming interface is EXPERIMENTAL and hence SUBJECT TO CHANGE WITHOUT NOTICE while it stabilizes. SPMI support —-系统电源管理接口(SPMI, System Power Management Interface)是一种连接PMIC(Power Management Integrated Circuits)的双线串行接口，仅用于嵌入式环境。参考：drivers/spmi/Kconfig。SPMI (System Power Management Interface) is a two-wire serial interface between baseband and application processors and Power Management Integrated Circuits (PMIC). HSI support —-高速同步串行接口(High speed synchronous Serial Interface)是移动产业处理器接口(MIPI)联盟的高速同步接口工作组发布的一项技术规范。MIPI(Mobile Industry Processor Interface)是2003年由ARM、Nokia、ST、TI等公司成立的一个联盟，目的是把手机内部的接口(如摄像头、显示屏接口、射频/基带接口等)标准化，从而减少手机设计的复杂程度和增加设计灵活性。MIPI联盟下面有不同的工作组，分别定义了一系列的手机内部接口标准，比如摄像头接口CSI，显示接口DSI，射频接口DigRF，麦克风/扬声器接口SLIMbus等。统一接口标准的好处是手机厂商根据需要可以从市面上灵活选择不同的芯片和模组，更改设计和功能时更加快捷方便。目前，MIPI联盟的董事成员包括英特尔、摩托罗拉、诺基亚、三星、意法半导体、德州仪器。参考：drivers/hsi/Kconfig。The “High speed synchronous Serial Interface” is synchronous serial interface used mainly to connect application engines and cellular modems. -Y- PPS support —&gt;秒脉冲(Pulse Per Second)驱动用来控制电流脉冲速率，可用于计时。PPS的精度可以到纳秒级，而且没有累积误差。这通常是GPS天线的一项功能，用于获取GPS卫星的授时。参考：drivers/pps/Kconfig。PPS (Pulse Per Second) is a special pulse provided by some GPS antennae. Userland can use it to get a high-precision time reference.Some antennae’s PPS signals are connected with the CD (Carrier Detect) pin of the serial line they use to communicate with the host. In this case use the SERIAL_LINE client support. Some antennae’s PPS signals are connected with some special host inputs so you have to enable the corresponding client support.To compile this driver as a module, choose M here: the module will be called pps_core.ko. PTP clock support —&gt;精密时间协议(Precision Time Protocol)是IEEE 1588定义的一种基于以太网的高精度时间同步协议。PTP采用硬件与软件结合设计，可以提供比纯软件方式的NTP(网络时间协议)高的多的精度(微秒级)。与GPS授时相比，在提供和GPS相同的精度情况下，PTP不需要为每个设备安装GPS那样昂贵的组件，只需要一个高精度的本地时钟和提供高精度时钟戳的部件，成本较低。一般的PC和服务器上没有PTP硬件。参考：drivers/ptp/Kconfig。The IEEE 1588 standard defines a method to precisely synchronize distributed clocks over Ethernet networks. The standard defines a Precision Time Protocol (PTP), which can be used to achieve synchronization within a few dozen microseconds. In addition, with the help of special hardware time stamping units, it can be possible to achieve synchronization to within a few hundred nanoseconds.This driver adds support for PTP clocks as character devices. If you want to use a PTP clock, then you should also enable at least one clock driver as well.To compile this driver as a module, choose M here: the module will be called ptp. -Y- Pin controllers —&gt;Pin控制器。其下的各选项请根据实际硬件状况选择(皆为低功耗或嵌入式平台)。一般由其他项选中。参考：drivers/pinctrl/Kconfig。 -Y- GPIO Support —&gt;每个芯片都会有至少一个引脚(PIN)，像CPU或者芯片组这种复杂的芯片，其引脚会有成百上千个，这些PIN就是芯片与外部沟通的渠道，每个PIN都会有它特定的功能。GPIO(General Purpose I/O)就是芯片上的一种通用功能的引脚，其功能可由使用者通过编程的方式自定义(所谓”可编程引脚”)，比如使用两条PIN就可以组成I2C，使用4条PIN就可以组成SPI。嵌入式系统经常需要控制结构简单但数量众多的外部设备(比如LED的亮与灭)，使用传统的串口或者并口就太”大炮打蚊子”，而GPIO则非常适合用于控制此类数量众多的简单设备。GPIO在嵌入式设备中使用广泛，但PC平台的芯片组南桥大多也集成有GPIO引脚(但只有BIOS才知道如何使用他们)，以支持某些特殊的定制硬件。详情参见”Documentation/gpio/gpio.txt”文档，不确定的选”N”。一般由其他项选中。参考：drivers/gpio/Kconfig。This enables GPIO support through the generic GPIO library. You only need to enable this, if you also want to enable one or more of the GPIO drivers below.If unsure, say N. Dallas’s 1-wire support —&gt;Dallas公司发明的单总线是比I2C更简单的总线，仅使用一个引脚(1-wire)，使用Master-Slave结构，用于连接慢速的单引脚设备，比如iButton和热传感器。主要用于嵌入式系统。参考：drivers/w1/Kconfig。Dallas’ 1-wire bus is useful to connect slow 1-pin devices such as iButtons and thermal sensors.If you want W1 support, you should say Y here.This W1 support can also be built as a module. If so, the module will be called wire. [Y] Adaptive Voltage Scaling class support —-自适应电压调节(Adaptive Voltage Scaling)技术能够动态的对设备工作电压进行精细的调整，拥有比DVFS更佳的电力利用效率，是一种降低功耗与优化性能并举的电源与性能管理技术。AVS在OMAP设备上也被称为”SmartReflex”，目前仅用于嵌入式领域。参考：drivers/power/avs/Kconfig。AVS is a power management technique which finely controls the operating voltage of a device in order to optimize (i.e. reduce) its power consumption. At a given operating point the voltage is adapted depending on static factors (chip manufacturing process) and dynamic factors (temperature depending performance). AVS is also called SmartReflex on OMAP devices.Say Y here to enable Adaptive Voltage Scaling class support. [Y] Board level reset or power off —&gt;允许通过操作板载的主电源，关闭或重启整个系统。仅用于嵌入式系统。参考：drivers/power/reset/Kconfig。Provides a number of drivers which either reset a complete board or shut it down, by manipulating the main power supply on the board.Say Y here to enable board reset and power off [Y] Power supply class support —&gt;允许用户空间程序通过sysfs/uevent接口对电源(电池、交流电、USB)进行监控。主要用于笔记本与嵌入式设备。参考：drivers/power/supply/Kconfig。Say Y here to enable power supply class support. This allows power supply (batteries, AC, USB) monitoring by userspace via sysfs and uevent (if available) and/or APM kernel interface (if selected below). Hardware Monitoring support —&gt;当前主板大多都有一个监控硬件温度/电压/风扇转速等状况的设备，请按照主板实际使用的芯片选择相应的子项。如果你不知道究竟需要使用哪个驱动，可以使用Superiotool和sensors-detect工具进行检测。另外,某些子项可能还需要CONFIG_I2C的支持。更多详情参见”Documentation/hwmon/userspace-tools”文档。参考：drivers/hwmon/Kconfig。Hardware monitoring devices let you monitor the hardware health of a system. Most modern motherboards include such a device. It can include temperature sensors, voltage sensors, fan speed sensors and various additional features such as the ability to control the speed of the fans. If you want this support you should say Y here and also to the specific driver(s) for your sensors chip(s) below.To find out which specific driver(s) you need, use the sensors-detect script from the lm_sensors package. Read file:Documentation/hwmon/userspace-tools for details.This support can also be built as a module. If so, the module will be called hwmon.下列为勾选项： GPIO fan Hwmon driver that uses channels specified via iio maps National Semiconductor LM90 and compatibles National Semiconductor LM95245 and compatibles NTC thermistor support from Murata PWM fan Texas Instruments INA219 and compatibles Texas Instruments TMP102 -Y- Generic Thermal sysfs driver —&gt;为ACPI规范中定义的”thermal”(发热控制)提供一个通用的sysfs接口，以方便与诸如温度传感器和风扇之类的设备通信。由于目前所有PC和服务器都已支持ACPI，并且发热控制也越来越重要，所以建议选”Y”。详情参见”Documentation/thermal/sysfs-api.txt”文档。参考：drivers/thermal/Kconfig。Generic Thermal Sysfs driver offers a generic mechanism for thermal management. Usually it’s made up of one or more thermal zone and cooling device. Each thermal zone contains its own temperature, trip points, cooling devices.All platforms with ACPI thermal support can use this driver.If you want this support, you should say Y or M here. [Y] Watchdog Timer Support —&gt;选”Y”并选中下面相应的驱动之后，再创建一个主/次设备号为10/130的字符设备”/dev/watchdog”，即可拥有一只看门狗。其工作原理是：当/dev/watchdog设备被打开后，如果喂狗守护进程超过60秒没有喂狗(写入”/dev/watchdog”)，那么底层的看门狗硬件将会触发整个机器硬重启(相当于按下面板上的”RESET”按钮)。这对于提高服务器的在线率来说意义重大。详情参见”Documentation/watchdog/watchdog-api.txt”文档。参考：drivers/watchdog/Kconfig。If you say Y here (and to one of the following options) and create a character special file /dev/watchdog with major number 10 and minor number 130 using mknod (“man mknod”), you will get a watchdog, i.e.: subsequently opening the file and then failing to write to it for longer than 1 minute will result in rebooting the machine. This could be useful for a networked machine that needs to come back on-line as fast as possible after a lock-up. There’s both a watchdog implementation entirely in software (which can sometimes fail to reboot the machine) and a driver for hardware watchdog boards, which are more robust and can also keep track of the temperature inside your computer. For details, read file:Documentation/watchdog/watchdog-api.txt in the kernel source.The watchdog is usually used together with the watchdog daemon which is available from ftp://ibiblio.org/pub/Linux/system/daemons/watchdog/. This daemon can also monitor NFS connections and can reboot the machine when the process table is full.If unsure, say N. Sonics Silicon Backplane —&gt;SSB(Sonics Silicon Backplane)是一种仅在嵌入式环境中使用的总线。参考：drivers/ssb/Kconfig。Support for the Sonics Silicon Backplane bus. You only need to enable this option, if you are configuring a kernel for an embedded system with this bus.It will be auto-selected if needed in other environments.The module will be called ssb.If unsure, say N. {Y} Broadcom specific AMBA —&gt;Broadcom特有的AMBA(Advanced Microcontroller Bus Architecture)总线支持，仅用于嵌入式环境。参考：drivers/bcma/Kconfig。Bus driver for Broadcom specific Advanced Microcontroller Bus Architecture. [Y] ChipCommon-attached serial flash support参考：drivers/bcma/Kconfig。Some cheap devices have serial flash connected to the ChipCommon instead of independent SPI controller. It requires using a separated driver that implements ChipCommon specific interface communication.Enabling this symbol will let bcma recognize serial flash and register it as platform device. [Y] BCMA Broadcom GBIT MAC COMMON core driver参考：drivers/bcma/Kconfig。Driver for the Broadcom GBIT MAC COMMON core attached to Broadcom specific Advanced Microcontroller Bus.If unsure, say N [Y] BCMA GPIO driver参考：drivers/bcma/Kconfig。Driver to provide access to the GPIO pins of the bcma bus.If unsure, say N [N] BCMA debugging参考：drivers/bcma/Kconfig。This turns on additional debugging messages.If unsure, say N Multifunction device drivers —&gt;MFD(多功能设备)的含义是”在单个芯片上集成多个功能(GPIO、触摸屏、键盘、电流调节、电源管理…)”。此种芯片通常通过一个或多个IRQ线和低速数据总线(SPI/I2C/GPIO)与主CPU进行通信。对于主系统来说，它们通过数据总线显示为一个单独的MFD设备。但透过MFD框架，又可以拥有多个相互独立的子设备(子功能)。参考：drivers/mfd/Kconfig。 -Y- Voltage and Current Regulator Support —&gt;通用的电压与电流调节器框架，除了提供通用的电压与电流调节接口外，还能通过sysfs向用户空间提供电压与电流的状态信息。目的在于通过动态调节电压和电流，降低能耗，延长电池寿命。主要用于嵌入式环境。一般由其他项选中。参考：drivers/regulator/Kconfig。Generic Voltage and Current Regulator support.This framework is designed to provide a generic interface to voltage and current regulators within the Linux kernel. It’s intended to provide voltage and current control to client or consumer drivers and also provide status information to user space applications through a sysfs interface.The intention is to allow systems to dynamically control regulator output in order to save power and prolong battery life. This applies to both voltage regulators (where voltage output is controllable) and current sinks (where current output is controllable).This framework safely compiles out if not selected so that client drivers can still be used in systems with no software controllable regulators.If unsure, say no. Remote Controller support —&gt;参考：drivers/media/rc/Kconfig。Enable support for Remote Controllers on Linux. This is needed in order to support several video capture adapters, standalone IR receivers/transmitters, and RF receivers.Enable this option if you have a video capture board even if you don’t need IR, as otherwise, you may not be able to compile the driver for your adapter.Say Y when you have a TV or an IR device. Multimedia support —&gt;多媒体设备：摄像头、视频采集、模拟电视、数字电视、机顶盒、收音机、遥控器、数字视频广播(DVB)…内核多媒体子系统由LinuxTV项目负责维护。参考：drivers/media/Kconfig。If you want to use Webcams, Video grabber devices and/or TV devices enable this option and other options below. Additional info and docs are available on the web at https://linuxtv.org Graphics support —&gt;图形设备/显卡支持，对于不需要使用图形界面的服务器环境来说，必须的最小选项集取决于平台(BIOS/UEFI)和引导程序(GRUB/LILO/GRUB4DOS)的设置(全选”N”则屏幕将无任何显示)。参考：drivers/gpu。 Sound card support —&gt;声卡支持。参考：sound/KconfigIf you have a sound card in your computer, i.e. if it can say more than an occasional beep, say Y. Be sure to have all the information about your sound card and its configuration down (I/O port, interrupt and DMA channel), because you will be asked for it.You want to read the Sound-HOWTO, available from http://www.tldp.org/docs.html#howto.General information about the modular sound system is contained in the files file:Documentation/sound/oss/Introduction.The file file:Documentation/sound/oss/README.OSS contains some slightly outdated but still useful information as well. Newer sound driver documentation is found in file:Documentation/sound/alsa/*.If you have a PnP sound card and you want to configure it at boot time using the ISA PnP tools (read http://www.roestock.demon.co.uk/isapnptools/), then you need to compile the sound card support as a module and load that module after the PnP configuration is finished.To do this, choose M here and read file:Documentation/sound/oss/README.modules; the module will be called soundcore. HID support —&gt;HID(人机接口设备)是一种定义计算机如何与人类交互的规范，常与USB或蓝牙搭配使用，常见的设备有：键盘、鼠标、触摸板、游戏杆、遥控器、蓝牙耳机、游戏手柄、手写板等等。不过HID设备不一定要有人机接口，只要符合HID规范，就是HID设备。参考：drivers/hid/KconfigA human interface device (HID) is a type of computer device that interacts directly with and takes input from humans. The term “HID” most commonly used to refer to the USB-HID specification, but other devices (such as, but not strictly limited to, Bluetooth) are designed using HID specification (this involves certain keyboards, mice, tablets, etc). This option adds the HID bus to the kernel, together with generic HID layer code. The HID devices are added and removed from the HID bus by the transport-layer drivers, such as usbhid (USB_HID) and hidp (BT_HIDP).For docs and specs, see http://www.usb.org/developers/hidpage/If unsure, say Y. [Y] USB support —&gt;通用串行总线(Universal Serial Bus)的目标是统一电脑的外设接口，目前几乎找不到没有USB接口的电脑，而且各种智能设备也大多带有USB接口。不要犹豫，选”Y”。参考：drivers/usb/Kconfig。This option adds core support for Universal Serial Bus (USB). You will also need drivers from the following menu to make use of it.下列为勾选项： Support for Host-side USB主机端(Host-side)USB支持。通用串行总线(USB)是一个串行总线子系统规范，它比传统的串口速度更快并且特性更丰富(供电、热插拔、最多可接127个设备等)，其目标是统一PC外设接口。USB总体上呈现一种树型结构，USB的”Host”(主设备)被称为”根”(也可以理解为是主板上的USB控制器)，USB的”Slave”(从设备)被称为”叶子”，而内部的节点则称为”hub”(集线器)。Universal Serial Bus (USB) is a specification for a serial bus subsystem which offers higher speeds and more features than the traditional PC serial port. The bus supplies power to peripherals and allows for hot swapping. Up to 127 USB peripherals can be connected to a single USB host in a tree structure.The USB host is the root of the tree, the peripherals are the leaves and the inner nodes are special USB devices called hubs. Most PCs now have USB host ports, used to connect peripherals such as scanners, keyboards, mice, modems, cameras, disks, flash memory, network links, and printers to the PC.Say Y here if your computer has a host-side USB port and you want to use USB devices. You then need to say Y to at least one of the Host Controller Driver (HCD) options below. Choose a USB 1.1 controller, such as “UHCI HCD support” or “OHCI HCD support”, and “EHCI HCD (USB 2.0) support” except for older systems that do not have USB 2.0 support. It doesn’t normally hurt to select them all if you are not certain.If your system has a device-side USB port, used in the peripheral side of the USB protocol, see the “USB Gadget” framework instead.After choosing your HCD, then select drivers for the USB peripherals you’ll be using. You may want to check out the information provided in file:Documentation/usb/ and especially the links given in file:Documentation/usb/usb-help.txt.To compile this driver as a module, choose M here: the module will be called usbcore.[Y] PCI based USB host interfaceA lot of embeded system SOC (e.g. freescale T2080) have both PCI and USB modules. But USB module is controlled by registers directly, it have no relationship with PCI module.When say N here it will not build PCI related code in USB driver.[Y] USB announce new devices在syslog中记录每个新接入系统的USB设备的详细标识信息，主要用于系统调试.不确定的选”N”。[Y] Enable USB persist by default根据USB规范，当USB总线被挂起(休眠)后，它必须继续提供挂起电流(1-5毫安)，以确保USB设备能保持其内部状态，并且USB集线器(HUB)能够检测连接变化(设备插入和拔出)。这在技术上被称为”电力会话”(power session)。如果一个USB设备的电力会话被中断，那么系统必须按照该设备已经被拔出进行处理，这是一种保守的做法。因为没有挂起电流，计算机不可能知道外围设备究竟发生了什么变化：也许依然保持连接，也许已经被拔出并在同一端口上插入了一个新设备。系统必须做最坏的打算，默认情况下，Linux的行为符合USB规范的要求。当整个电脑进入休眠状态(例如挂起到硬盘)时，包括USB总线在内所有总线都将掉电，然后当系统被唤醒，所有USB设备都会被当做在休眠前就已经被拔出来处理。这样做始终是安全的，并且也是”官方正确”的做法。对于大多数USB设备来说，这样做没有任何问题，但是对于USB存储设备(例如移动硬盘/U盘)来说，如果在休眠前有尚未卸载的文件系统(特别是根文件系统)，当系统被唤醒之后，由于无法访问该文件系统，系统可能会立即崩溃！其实不只有掉电，只要”power session”被中断(例如BIOS在唤醒过程中重置了USB控制器)，都会导致这种故障。此选项(USB-persist)就是为了解决这个问题而设置的，虽然解决的不甚完美(参见”Documentation/usb/persist.txt”)，但是依然推荐选”Y”，除非你确实有选”N”的理由。当然，最保险的做法是在休眠之前先卸载所有USB设备上的文件系统，而如果根文件系统位于USB设备上，就根本不使用任何休眠功能(不论是挂起到硬盘还是挂起到内存)。 xHCI HCD (USB 3.0) supportxHCI(eXtensible Host Controller Interface)就是当下大红大紫的USB3.0主机控制器规范。 EHCI HCD (USB 2.0) supportEHCI(Enhanced Host Controller Interface)就是渐成昨日黄花的USB2.0(HighSpeed USB)主机控制器规范。 OHCI HCD (USB 1.1) supportOHCI(Open Host Controller Interface)是主要用于嵌入式环境的USB1.1(主机控制器规范，但也存在于某些老旧的SiS芯片组的PC上。 USB Modem (CDC ACM) supportUSB接口的猫或ISDN适配器，基本没人用的东西。 USB Mass Storage supportUSB存储设备(U盘、USB硬盘、USB软盘、USB光盘、USB磁带、记忆棒、数码相机、读卡器[包括某些笔记本内置的SD卡读卡器]等等)。该选项依赖于CONFIG_SCSI和CONFIG_BLK_DEV_SD选项。选”Y”，除非你确实知道自己在干什么。 Ultra Wideband devices —-UWB(Ultra Wideband)是一种高带宽，低能耗，点对点,抗干扰性能强的无载波通信技术。UWB在较宽的频谱(3.1-10.6GHz)上，使用极低的功率(约为蓝牙的1/20)，以时间间隔极短(小于1ns)的脉冲信号进行通信。UWB主要应用于室内通信(2米范围内实现480Mbps速率，10米范围内实现110Mbps速率)，例如作为WUSB(Wireless USB)协议的传输层。如果你有UWB无线控制器，可以选”Y”，不确定的选”N”。详见”Documentation/usb/WUSB-Design-overview.txt”文档。参考：/drivers/uwb/Kconfig。UWB is a high-bandwidth, low-power, point-to-point radio technology using a wide spectrum (3.1-10.6GHz). It is optimized for in-room use (480Mbps at 2 meters, 110Mbps at 10m). It serves as the transport layer for other protocols, such as Wireless USB (WUSB).The topology is peer to peer; however, higher level protocols (such as WUSB) might impose a master/slave relationship.Say Y here if your computer has UWB radio controllers (USB or PCI) based. You will need to enable the radio controllers below. It is ok to select all of them, no harm done.For more help check the UWB and WUSB related files in file:Documentation/usb/.To compile the UWB stack as a module, choose M here. MMC/SD/SDIO card support —&gt;MMC(MultiMediaCard)/SD(Secure Digital)/SDIO(Secure Digital I/O)主机控制器。[提示]虽然许多笔记本上有SD卡插槽,但其实它们大多使用的是CONFIG_USB_STORAGE驱动,而不是这里的驱动。参考：/drivers/mmc/Kconfig。This selects MultiMediaCard, Secure Digital and Secure Digital I/O support.If you want MMC/SD/SDIO support, you should say Y here and also to your specific host controller driver. Sony MemoryStick card support —-Sony记忆棒是一种Sony专用的存储设备。参考：drivers/memstick/Kconfig。Sony MemoryStick is a proprietary storage/extension card protocol.If you want MemoryStick support, you should say Y here and also to the specific driver for your MemoryStick interface. [Y] LED Support —&gt;发光二级管(LED)支持.[提示]标准键盘上的LED灯不在此列(由input子系统控制)。参考：drivers/leds/Kconfig。Say Y to enable Linux LED support. This allows control of supported LEDs from both userspace and optionally, by kernel events (triggers).下列为勾选项： LED Class Support LED Support for GPIO connected LEDs PWM driven LED Support LED driver for TLC59108 and TLC59116 controllers [N] Accessibility support —-无障碍(Accessibility)支持。各种帮助残疾人使用计算机的软硬件技术，例如：盲文设备、语音合成、键盘映射等等。参考：drivers/accessibility/Kconfig。Accessibility handles all special kinds of hardware devices or software adapters which help people with disabilities (e.g. blindness) to use computers.That includes braille devices, speech synthesis, keyboard remapping, etc.Say Y here to get to see options for accessibility.This option alone does not add any kernel code.If you say N, all options in this submenu will be skipped and disabled.If unsure, say N. InfiniBand support —-InfiniBand是一种低延迟/高带宽数据中心互联架构，采用远程直接内存存取(RDMA)实现高性能处理器间通信(IPC)，同时对虚拟化技术也提供了良好的支持。主要用于服务器集群与高性能计算(HPC)领域。参考：drivers/infiniband/Kconfig。Core support for InfiniBand (IB). Make sure to also select any protocols you wish to use as well as drivers for your InfiniBand hardware. EDAC (Error Detection And Correction) reporting —&gt;在电磁环境比较恶劣的情况下，一些大规模集成电路常常会受到干扰，特别是像RAM这种利用双稳态进行存储的器件，往往会在强干扰下发生翻转，使原来存储的”0”变为”1”，或者”1”变为”0”，造成严重的后果(例如控制程序跑飞，关键数据出错)。随着芯片集成度的增加，发生错误的可能性也在增大，这已经成为一个不能忽视的问题。错误检测与纠正(EDAC)技术的目标就是发现并报告甚至纠正在计算机系统中发生的错误，这些错误是由CPU或芯片组报告的底层错误(内存错误/缓存错误/PCI错误/温度过高等等)，建议选”Y”。如果这些代码报告了一个错误，请到http://bluesmoke.sourceforge.net/和http://buttersideup.com/edacwiki查看更多信息。详见&quot;Documentation/edac.txt&quot;文档。参考：drivers/edac/Kconfig。EDAC is a subsystem along with hardware-specific drivers designed to report hardware errors. These are low-level errors that are reported in the CPU or supporting chipset or other subsystems: memory errors, cache errors, PCI errors, thermal throttling, etc..If unsure, select ‘Y’.The mailing list for the EDAC project is linux-edac@vger.kernel.org.下列为勾选项：[Y] EDAC legacy sysfs Texas Instruments DDR3 ECC Controller [Y] Real Time Clock —&gt;通用RTC(实时时钟)类支持。所有的PC机主板都包含一个电池动力的实时时钟芯片，以便在断电后仍然能够继续保持时间，RTC通常与CMOS集成在一起，因此BIOS可以从中读取当前时间(精度一般是秒级)。选中此项后你就可以在操作系统中使用一个或多个RTC设备(你还必须从下面启用一个或多个RTC接口)。[注意]Clock与Timer没有任何关系，Timer是定时器(用于计量时长)，Clock是时钟(用于记录当前的时刻”年-月-日 时：分：秒”)。参考：drivers/rtc/Kconfig。Generic RTC class support. If you say yes here, you will be allowed to plug one or more RTCs to your system. You will probably want to enable one or more of the interfaces below.下列为主要勾选项：[Y] Set system time from RTC on startup and resume[Y] Set the RTC time based on NTP synchronization[Y] RTC debug support[Y] RTC non volatile storage support[Y] /sys/class/rtc/rtcN (sysfs)[Y] /proc/driver/rtc (procfs for rtcN)[Y] /dev/rtcN (character devices) Dallas/Maxim DS1307/37/38/39/40/41, ST M41T00, EPSON RX-8025, ISL12057 TI Palmas RTC driver TI TPS6586X RTC driver TI TPS65910 RTC driver EFI RTC TI OMAP Real Time Clock [Y] DMA Engine support —&gt;DMA引擎(DMA Engine)可以看做是传统DMA控制器(DMA controller)的新生。在DMA引擎的协助下，CPU只需初始化一个传输动作，其余的动作就可以由DMA引擎独立完成(完成后以中断的方式通知CPU)，这对于高速传输大量数据以及”分散-收集”操作大有益处，可以节约大量的CPU资源(有时也可节约大量的内存操作)。目前，DMA引擎有两个用途：(1)卸载高速网络栈中的内存COPY操作，(2)加速CONFIG_MD_RAID456驱动中的RAID操作。”DMA引擎”只是一个统称，在不同场合对应着不同的技术，例如Intel I/OAT(PC平台)和AHB(嵌入式)。参考：drivers/dma/Kconfig。DMA engines can do asynchronous data transfers without involving the host CPU. Currently, this framework can be used to offload memory copies in the network stack and RAID operations in the MD driver. This menu only presents DMA Device drivers supported by the configured arch, it may be empty in some cases. DMABUF options —&gt;以下为勾选项：-Y- Explicit Synchronization Framework参考：drivers/dma-buf/Kconfig。The Sync File Framework adds explicit syncronization via userspace. It enables send/receive ‘struct dma_fence’ objects to/from userspace via Sync File fds for synchronization between drivers via userspace components. It has been ported from Android.The first and main user for this is graphics in which a fence is associated with a buffer. When a job is submitted to the GPU a fence is attached to the buffer and is transferred via userspace, using Sync Files fds, to the DRM driver for example. More details at Documentation/sync_file.txt. [N] Auxiliary Display support —-辅助显示设备。例如基于KS0108控制器的Crystalfontz CFAG12864B单色液晶屏(分辨率:128x64)。仅用于嵌入式系统。参考：drivers/auxdisplay/Kconfig。Say Y here to get to see options for auxiliary display drivers. This option alone does not add any kernel code.If you say N, all options in this submenu will be skipped and disabled. Userspace I/O drivers—&gt;UIO(Userspace I/O)是运行在用户空间的I/O技术，它为开发用户空间的驱动提供了一个简单的架构(/dev/uioN)。使用uio的设备一般都属于嵌入式系统，不确定的选”N”。[提示]lsuio工具可以列出所有UIO的模块和其映射的内存地址。参考：drivers/uio/Kconfig。Enable this to allow the userspace driver core code to be built. This code allows userspace programs easy access to kernel interrupts and memory locations, allowing some drivers to be written in userspace. Note that a small kernel driver is also required for interrupt handling to work properly.If you don’t know what to do here, say N. VFIO Non-Privileged userspace driver framework —-VFIO是一套无特权用户空间I/O驱动框架，需要有IOMMU虚拟化硬件支持(AMD-Vi/Intel VT-d)。此选项仅用于宿主机内核，VFIO的目标是在IOMMU硬件的帮助下，取代CONFIG_UIO和CONFIG_KVM_DEVICE_ASSIGNMENT。VFIO主要用于编写高效的用户态驱动，以及在虚拟化环境的属主机中高效的实现设备直通(passthrough)且无须root特权，可用于详见”Documentation/vfio.txt”文档。[提示]QEMU 1.3以上版本才能利用VFIO特性。不玩KVM虚拟化的选”N”。参考：drivers/vfio/Kconfig。VFIO provides a framework for secure userspace device drivers. See Documentation/vfio.txt for more details.If you don’t know what to do here, say N. [N] Virtualization drivers —-这个选项仅对PowerPC架构有意义。参考：drivers/virt/Kconfig。Say Y here to get to see options for device drivers that support virtualization environments.If you say N, all options in this submenu will be skipped and disabled. Virtio drivers —&gt;仅可用于客户机内核的Virtio驱动。Virtio的目标是为各种半虚拟化的虚拟机管理程序(特别是KVM)提供一组通用的模拟设备,目前已实现：network/block/balloon/console/hw_random，未来还会实现更多。下列驱动仅可用在基于lguest或QEMU的半虚拟化客户机中(一般是KVM或XEN)。参考：drivers/virtio/Kconfig。This option is selected by any driver which implements the virtio bus, such asCONFIG_VIRTIO_PCI,CONFIG_VIRTIO_MMIO,CONFIG_RPMSG,CONFIG_S390_GUEST.下列为勾选项： PCI driver for virtio devices半虚拟化PCI设备驱动，VMM(虚拟机管理程序)必须要有相应的”PCI virtio backend”。基于QEMU的VMM(KVM,Xen)一般都支持该驱动。[提示]由于目前的ABI尚不稳定,建议使用时注意版本匹配。 Platform bus driver for memory mapped virtio devices支持使用内存映射机制的virtio设备驱动。 Microsoft Hyper-V guest support —-仅在将此Linux内核作为微软Hyper-V虚拟机的来宾操作系统运行时，才需要开启这里的选项。参考：/drivers/hv/Kconfig。Select this option to run Linux as a Hyper-V client operating system. [N] Staging drivers —-尚在开发中或尚未完成的，目前尚不完善的驱动，切勿用于生产环境。仅供测试人员或者开发者试用。参考：drivers/staging/Kconfig。This option allows you to select a number of drivers that are not of the “normal” Linux kernel quality level. These drivers are placed here in order to get a wider audience to make use of them. Please note that these drivers are under heavy development, may or may not work, and may contain userspace interfaces that most likely will be changed in the near future.Using any of these drivers will taint your kernel which might affect support options from both the community, and various commercial support organizations.If you wish to work on these drivers, to help improve them, or to report problems you have with them, please see the driver_name.README file in the drivers/staging/ directory to see what needs to be worked on, and who to contact.If in doubt, say N here. [N] Platform support for Goldfish virtual devices —-参考：drivers/platform/goldfish/KconfigSay Y here to get to see options for the Goldfish virtual platform.This option alone does not add any kernel code. Unless you are building for the Android Goldfish emulator say N here. [N] Platform support for Chrome hardware —-专用于Google公司的Chromebook笔记本/Chromebox迷你机的设备驱动。参考：drivers/platform/chrome/Kconfig。Say Y here to get to see options for platform support for various Chromebooks and Chromeboxes. This option alone does not add any kernel code.If you say N, all options in this submenu will be skipped and disabled.Common Clock Framework —&gt;CCF(Common Clock Framework)是从3.4内核开始引入的新时钟框架，用于取代原有的”Clock Framework”。详见”Documentation/clk.txt”文档。参考：drivers/clk/Kconfig。The common clock framework is a single definition of struct clk, useful across many platforms, as well as an implementation of the clock API in include/linux/clk.h. Architectures utilizing the common struct clk should select this option.下列为勾选项： Clock driver for TI Palmas devicesThis driver supports TI Palmas devices 32KHz output KG and KG_AUDIO using common clock framework. [Y] Hardware Spinlock drivers —&gt;硬件自旋锁驱动。目前仅出现在嵌入式处理器上，自旋锁是保护共享资源的一种锁机制，与互斥锁比较类似，都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个持有者。也就是说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同，对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起申请者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直在循环中”忙等”(占用CPU但无事可做)，直到该自旋锁被释放。”自旋”一词就是因此而得名。自旋锁的使用非常方便，但仅适用于需要极短时间锁定的场合(例如1毫秒)，以避免消耗太多的CPU空等时间。参考：drivers/hwspinlock/Kconfig。下列为勾选项： OMAP Hardware Spinlock deviceSay y here to support the OMAP Hardware Spinlock device (firstly introduced in OMAP4).If unsure, say N. Clock Source drivers —&gt;“时钟源”驱动，主要面向嵌入式设备。参考：drivers/clocksource/Kconfig。下列为勾选项：[Y] Enable ARM architected timer event stream generation by defaultThis option enables support by default for event stream generation based on the ARM architected timer. It is used for waking up CPUs executing the wfe instruction at a frequency represented as a power-of-2 divisor of the clock rate. The behaviour can also be overridden on the command line using the clocksource.arm_arch_timer.evtstream parameter. The main use of the event stream is wfe-based timeouts of userspace locking implementations. It might also be useful for imposing timeout on wfe to safeguard against any programming errors in case an expected event is not generated.This must be disabled for hardware validation purposes to detect any hardware anomalies of missing events. -Y- Mailbox Hardware Support —&gt;Mailbox硬件支持。这里的”Mailbox”是一个框架，通过消息队列和中断驱动信号，控制芯片上的多个处理器之间的通信。仅用于嵌入式环境。参考：drivers/mailbox/Kconfig。Mailbox is a framework to control hardware communication between on-chip processors through queued messages and interrupt driven signals. Say Y if your platform supports hardware mailboxes.下列为勾选项：{Y} OMAP2+ Mailbox framework support(256) Mailbox kfifo default buffer size (bytes) [Y] IOMMU Hardware Support —&gt;IOMMU硬件主要出现在带有I/O虚拟化技术的硬件上，例如带有AMD-Vi或VT-d技术的芯片。IOMMU主要作用：(1)内存地址转换(例如DMA地址转换，scatter-gather)，(2)中断重映射，(3)对设备读取和写入的进行权限检查。这对于提高虚拟化性能和安全性，以及在64位系统上更好的使用32位设备，意义重大。[提示]此选项仅对宿主机有意义，如果此内核要作为来宾操作系统运行，请选”N”。参考：drivers/iommu/Kconfig。Say Y here if you want to compile device drivers for IO Memory Management Units into the kernel. These devices usually allow to remap DMA requests and/or remap interrupts from other devices on the system.下列为勾选项：[Y] OMAP IOMMU Support[Y] Export OMAP IOMMU internals in DebugFS Remoteproc drivers —&gt;现代的SoC芯片一般都会以AMP(非对称多处理器)方式集成多个不同的处理器(例如OMAP5432就在单个芯片上集成了2个Cortex-A15处理器，2个Cortex-M4处理器，1个C64x DSP)，这样就可在不同的处理器上分别运行多个不同的操作系统实例(例如，在2个Cortex-A9处理器上以SMP(对称多处理器)方式运行Linux，在2个Cortex-M3和1个C64x上分别运行不同的实时操作系统)。而Remoteproc驱动对此种场合下的处理器间通信非常有用，详见”Documentation/remoteproc.txt”和”Documentation/rpmsg.txt”文档。目前仅对嵌入式系统有意义，不确定的选”N”。参考：drivers/remoteproc/Kconfig。下列为勾选项： Support for Remote Processor subsystem OMAP remoteproc support TI PRUSS remoteproc support Rpmsg drivers —&gt;此项和上面的Remoteproc紧密相关。参考：drivers/rpmsg/Kconfig。下列为勾选项： Virtio RPMSG bus driver rpmsg Remote Procedure Call driver PRU RPMsg Communication driver SOC (System On Chip) specific Drivers —&gt;专用于单片机的设备驱动，皆为嵌入式系统。下列为勾选项：[Y] TI SOC drivers support参考：drivers/soc/ti/Kconfig [N] Generic Dynamic Voltage and Frequency Scaling (DVFS) support —-DVFS(动态电压与频率调整)可以根据系统负载动态调节设备的运行频率和电压(对于同一芯片，频率越高，需要的电压也越高)，从而达到节能目的。此选项提供了一个类似CPUfreq(CONFIG_CPU_FREQ)的通用DVFS框架(devfreq)。目前DVFS技术进在嵌入式设备(例如Exynos4/Exynos5)上普遍存在，不确定的选”N”。参考：drivers/devfreq/Kconfig。A device may have a list of frequencies and voltages available. devfreq, a generic DVFS framework can be registered for a device in order to let the governor provided to devfreq choose an operating frequency based on the device driver’s policy.Each device may have its own governor and policy. Devfreq can reevaluate the device state periodically and/or based on the notification to “nb”, a notifier block, of devfreq.Like some CPUs with CPUfreq, a device may have multiple clocks. However, because the clock frequencies of a single device are determined by the single device’s state, an instance of devfreq is attached to a single device and returns a “representative” clock frequency of the device, which is also attached to a device by 1-to-1. The device registering devfreq takes the responsibility to “interpret” the representative frequency and to set its every clock accordingly with the “target” callback given to devfreq.When OPP is used with the devfreq device, it is recommended to register devfreq’s nb to the OPP’s notifier head. If OPP is used with the devfreq device, you may use OPP helper functions defined in devfreq.h. -Y- External Connector Class (extcon) support —&gt;extcon(外部连接器类)允许用户空间通过sysfs和uevent监控外部连接器，同时也支持多状态外部连接器(也就是拥有多个连接线缆的外部连接器)。例如，一端连接到主机USB端口的多状态外部连接器，一端可以同时连接一条HDMI线缆和一个AC适配器。30针的PDMI连接器也是多状态外部连接器的常见例子。不确定的选”N”。参考：drivers/extcon/Kconfig。Say Y here to enable external connector class (extcon) support. This allows monitoring external connectors by userspace via sysfs and uevent and supports external connectors with multiple states; i.e., an extcon that may have multiple cables attached. For example, an external connector of a device may be used to connect an HDMI cable and a AC adaptor, and to host USB ports. Many of 30-pin connectors including PDMI are also good examples.下列为勾选项： Palmas USB EXTCON support USB GPIO extcon support -Y- Memory Controller drivers —&gt;内存控制器驱动。这里所说的”内存控制器”仅指嵌入式SoC系统中的各种控制器，不确定的选”N”。参考：drivers/memory/Kconfig。 Industrial I/O support —&gt;IIO子系统为各种不同总线(i2c、spi等)的嵌入式传感器驱动提供了一个统一的框架。例如：(1)模数转换器，(2)加速度传感器，(3)陀螺仪，(4)惯性测量仪，(5)电容-数字转换器，(6)压力/温度/光线传感器等等。主要用于工业领域和嵌入式领域，不确定的选”N”。参考：Industrial I/O support rivers。The industrial I/O subsystem provides a unified framework for drivers for many different types of embedded sensors using a number of different physical interfaces (i2c, spi, etc).下列为主要勾选项：-Y- Enable buffer support within IIO-Y- Industrial I/O buffering based on kfifo-Y- Enable IIO configuration via configfs-Y- Enable triggered sampling support Enable software triggers support其他勾选项以各类芯片为主。 Non-Transparent Bridge support —-PCI-E非透明桥是一个点对点PCI-E总线，用于连接两条对等的PCI-E总线。例如英特尔 Atom S1200处理器， Xeon C5500/C3500 嵌入式处理器等。具体支持的设备号(PCI_DEVICE_ID)可以查看”drivers/ntb/ntb_hw.h”文件或NTB驱动数据库，不确定的选”N”。参考：drivers/ntb/Kconfig。The PCI-E Non-transparent bridge hardware is a point-to-point PCI-E busconnecting 2 systems. When configured, writes to the device’s PCImapped memory will be mirrored to a buffer on the remote system. Thentb Linux driver uses this point-to-point communication as a method totransfer data from one system to the other.If unsure, say N. [N] VME bridge support —-VME(VersaModule Eurocard)总线是一种通用的计算机总线，主要用于工业控制/军用系统/航空航天/交通运输/医疗等嵌入式领域。而VME桥则是其他总线(例如PCI/PCI-E)到VME总线之间的转换芯片，不确定的选”N”。参考：drivers/vme/Kconfig。If you say Y here you get support for the VME bridge Framework. -Y- Pulse-Width Modulation (PWM) Support —&gt;PWM(脉宽调制)是将模拟信号转换为脉波的一种技术，在计算机领域，这项技术常被用于控制风扇转速和背光显示器的亮度。很多微型处理器内部都包含有PWM控制器，此选项为所有PWM控制器驱动提供了一个统一的框架，不确定的选”N”。参考：drivers/pwm/Kconfig。Generic Pulse-Width Modulation (PWM) support.In Pulse-Width Modulation, a variation of the width of pulses in a rectangular pulse signal is used as a means to alter the average power of the signal. Applications include efficient power delivery and voltage regulation. In computer systems, PWMs are commonly used to control fans or the brightness of display backlights.This framework provides a generic interface to PWM devices within the Linux kernel. On the driver side it provides an API to register and unregister a PWM chip, an abstraction of a PWM controller, that supports one or more PWM devices. Client drivers can request PWM devices and use the generic framework to configure as well as enable and disable them.This generic framework replaces the legacy PWM framework which allows only a single driver implementing the required API. Not all legacy implementations have been ported to the framework yet. The framework provides an API that is backward compatible with the legacy framework so that existing client drivers continue to work as expected.If unsure, say no.下列为勾选项： Freescale FlexTimer Module (FTM) PWM support ECAP PWM support EHRPWM PWM support IRQ chip support —-参考：/drivers/irqchip/Kconfig。没有选择项。 IndustryPack bus support —-IndustryPack是工业控制领域常用的一种总线，不确定的选”N”。参考：drivers/ipack/Kconfig。This option provides support for the IndustryPack framework. There are IndustryPack carrier boards, which interface another bus (such as PCI) to an IndustryPack bus, and IndustryPack modules, that are hosted on these buses. While IndustryPack modules can provide a large variety of functionality, they are most often found in industrial control applications.Say N if unsure. [Y] Reset Controller Support —&gt;为GPIO总线或者芯片内置的重启控制器提供通用支持，仅用于嵌入式设备。不确定的选”N”。参考：drivers/reset/Kconfig。Generic Reset Controller support.This framework is designed to abstract reset handling of devices via GPIOs or SoC-internal reset controller modules.If unsure, say no.下列为勾选项： TI SYSCON Reset DriverThis enables the reset driver support for TI devices with memory-mapped reset registers as part of a syscon device node. If you wish to use the reset framework for such memory-mapped devices, say Y here. Otherwise, say N. FMC support —-FMC(FPGA Mezzanine Carrier)是一个定义如何将FPGA夹层卡(FPGA Mezzanine Card)连接到主机电路板的接口标准，仅用于嵌入式环境。参考：drivers/fmc/Kconfig。FMC (FPGA Mezzanine Carrier) is a mechanical and electrical standard for mezzanine cards that plug into a carrier board. This kernel subsystem supports the matching between carrier and mezzanine based on identifiers stored in the internal I2C EEPROM, as well as having carrier-independent drivers.The framework was born outside of the kernel and at this time the off-tree code base is more complete. Code and documentation is at git://ohwr.org/fmc-projects/fmc-bus.git . PHY Subsystem —&gt;PHY子系统。参考：drivers/phy/Kconfig。下列为勾选项：-Y- PHY Core为内核中的所有PHY设备提供一个通用的PHY框架，不确定的选”N”。内核中若有其他部分依赖它，会自动选上。This framework is designed to provide a generic interface for PHY devices present in the kernel. This layer will have the generic API by which phy drivers can create PHY using the phy framework and phy users can obtain reference to the PHY. All the users of this framework should select this config.其他为部分芯片的选项。 [N] Generic powercap sysfs driver —-“power capping”的意思是允许用户把设备的总功耗限定在指定的范围内，此选项允许内核子系统将”power capping”的设置以sysfs的方式导出到用户空间，不确定的选”N”。参考：drivers/powercap/Kconfig。The power capping sysfs interface allows kernel subsystems to expose power capping settings to user space in a consistent way. Usually, it consists of multiple control types that determine which settings may be exposed and power zones representing parts of the system that can be subject to power capping.If you want this code to be compiled in, say Y here. MCB support —-MCB(MEN Chameleon Bus)是专用于德国MEN Mikro Elektronik公司的FPGA设备的总线，MEN Mikro Elektronik公司的嵌入式计算主要是为航空/航海/铁路及陆地车辆的应用，以及自动化/电力/能源和医疗用途。不确定的选”N”。参考：drivers/mcb/Kconfig。The MCB (MEN Chameleon Bus) is a Bus specific to MEN Mikroelektronik FPGA based devices. It is used to identify MCB based IP-Cores within an FPGA and provide the necessary framework for instantiating drivers for these devices.If build as a module, the module is called mcb.ko Performance monitor support —&gt;专用于ARM架构的CPU性能监控框架。参考：drivers/perf/Kconfig。下列为勾选项：[Y] ARM PMU frameworkSay y if you want to use CPU performance monitors on ARM-based systems. -Y- Reliability, Availability and Serviceability (RAS) features —-RAS(可靠、可用、可维护)是一个计算机硬件术语，可靠性描述系统能够持续正确工作多长时间，可用性描述系统能够正确工作的时间百分比，可维护性描述系统从错误恢复到正常需要多长时间。具有高等级RAS的硬件会有一系列额外的技术保障数据的可靠性与正确性。参考：drivers/ras/Kconfig。Reliability, availability and serviceability (RAS) is a computer hardware engineering term. Computers designed with higher levels of RAS have a multitude of features that protect data integrity and help them stay available for long periods of time without failure.Reliability can be defined as the probability that the system will produce correct outputs up to some given time. Reliability is enhanced by features that help to avoid, detect and repair hardware faults.Availability is the probability a system is operational at a given time, i.e. the amount of time a device is actually operating as the percentage of total time it should be operating.Serviceability or maintainability is the simplicity and speed with which a system can be repaired or maintained; if the time to repair a failed system increases, then availability will decrease.Note that Reliability and Availability are distinct concepts: Reliability is a measure of the ability of a system to function correctly, including avoiding data corruption, whereas Availability measures how often it is available for use, even though it may not be functioning correctly. For example, a server may run forever and so have ideal availability, but may be unreliable, with frequent data corruption. Android —&gt;安卓平台专用驱动。参考：drivers/android/Kconfig。Enable support for various drivers needed on the Android platform。 NVDIMM (Non-Volatile Memory Device) Support —-NVDIMM(非易失性内存)支持。参考：drivers/nvdimm/Kconfig。Generic support for non-volatile memory devices including ACPI-6-NFIT defined resources. On platforms that define an NFIT, or otherwise can discover NVDIMM resources, a libnvdimm bus is registered to advertise PMEM (persistent memory) namespaces (/dev/pmemX) and BLK (sliding mmio window(s)) namespaces (/dev/ndblkX.Y). A PMEM namespace refers to a memory resource that may span multiple DIMMs and support DAX (see CONFIG_DAX). A BLK namespace refers to an NVDIMM control region which exposes an mmio register set for windowed access mode to non-volatile memory. DAX: direct access to differentiated memory —-参考：drivers/dax/Kconfig。 -Y- NVMEM Support —-NVMEM(非易失性存储器)设备支持，包括：EEPROM、EFUSES……不确定的选”N”。参考：drivers/nvmem/Kconfig。Support for NVMEM(Non Volatile Memory) devices like EEPROM, EFUSES…This framework is designed to provide a generic interface to NVMEM from both the Linux Kernel and the userspace.This driver can also be built as a module. If so, the module will be called nvmem_core.If unsure, say no. System Trace Module devices仅供调试使用。参考：drivers/hwtracing/stm/Kconfig。A System Trace Module (STM) is a device exporting data in System Trace Protocol (STP) format as defined by MIPI STP standards.Examples of such devices are Intel(R) Trace Hub and Coresight STM.Say Y here to enable System Trace Module device support. Intel(R) Trace Hub controller仅供调试使用。参考：drivers/hwtracing/intel_th/Kconfig。Intel(R) Trace Hub (TH) is a set of hardware blocks (subdevices) that produce, switch and output trace data from multiple hardware and software sources over several types of trace output ports encoded in System Trace Protocol (MIPI STPv2) and is intended to perform full system debugging.This option enables intel_th bus and common code used by TH subdevices to interact with each other and hardware and for platform glue layers to drive Intel TH devices.Say Y here to enable Intel(R) Trace Hub controller support. FPGA Configuration Framework —-FPGA配置框架支持，仅用于嵌入式系统。参考：drivers/fpga/Kconfig。Say Y here if you want support for configuring FPGAs from the kernel. The FPGA framework adds a FPGA manager class and FPGA manager drivers. FSI support —&gt;参考：drivers/fsi/Kconfig。FSI - the FRU Support Interface - is a simple bus for low-level access to POWER-based hardware. Trusted Execution Environment support针对移动端的安全威胁产生的可信执行环境技术。参考：drivers/tee/Kconfig。This implements a generic interface towards a Trusted Execution Environment (TEE).TEE drivers —&gt; OP-TEE参考：drivers/tee/optee/Kconfig。This implements the OP-TEE Trusted Execution Environment (TEE) driver.","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"kernel","slug":"kernel","permalink":"http://yoursite.com/tags/kernel/"}]},{"title":"Linux内核Kconfig解读","slug":"Linux内核Kconfig解读","date":"2019-07-28T12:55:44.000Z","updated":"2019-07-28T14:04:22.194Z","comments":true,"path":"2019/07/28/Linux内核Kconfig解读/","link":"","permalink":"http://yoursite.com/2019/07/28/Linux内核Kconfig解读/","excerpt":"内核的编译过程arch=arm，tisdk_am57xx-evm-rt_defconfig确定了.config中的配置，主目录的Makefile按照.config文件中的选择遍历所有文件中的Kconfig（首先是arch/arm/Kconfig），按照Kconfig文件中的依赖关系编译文件，再回到顶层目录生成目标文件。 123Kconfig ---&gt; （每个源码目录下）提供选项.config ---&gt; （源码顶层目录下）保存选择结果Makefile---&gt; （每个源码目录下）根据.config中的内容来告知编译系统如何编译","text":"内核的编译过程arch=arm，tisdk_am57xx-evm-rt_defconfig确定了.config中的配置，主目录的Makefile按照.config文件中的选择遍历所有文件中的Kconfig（首先是arch/arm/Kconfig），按照Kconfig文件中的依赖关系编译文件，再回到顶层目录生成目标文件。 123Kconfig ---&gt; （每个源码目录下）提供选项.config ---&gt; （源码顶层目录下）保存选择结果Makefile---&gt; （每个源码目录下）根据.config中的内容来告知编译系统如何编译 配置过程–以驱动为例新建Kconfig在/drivers/test下建立Kconfig： 1234config TEST bool &quot;Test driver&quot; help This driver is for test kernel making. 这里定义了TEST选项，也就是.config中的CONFIG_TEST，Test driver是显示在menuconfig中的名称。 新建Makefile建立编译规则，例如CONFIG_TEST=y，目录下源码编译进内核；CONFIG_TEST=m，目录下源码编译为模块。 1obj-$(CONFIG_TEST) += test.o 配置上层Makefile和Kconfig修改Kconfig，增加test子项，在drivers/Kconfig中添加： 1source &quot;drivers/test/Kconfig&quot; 修改Makefile，添加编译规则： 1obj-y += test/ Kconfig详细语法关键词以下面为例： 123456789101112config SMP bool &quot;Symmetric Multi-Processing&quot; depends on CPU_V6K || CPU_V7 depends on GENERIC_CLOCKEVENTS depends on HAVE_SMP depends on MMU || ARM_MPU select IRQ_WORK help This enables support for systems with more than one CPU. If you have a system with only one CPU, say N. If you have a system with more than one CPU, say Y. ...... 关键词 功能 config 紧跟句柄，SMP即为CONFIG_SMP bool 表示选择，0或1 [Y] “name” 在menuconfig中显示的字符串，没有则不显示 depends on 表示依赖某一项，支持 ` select 表示选中后，也会选择select指定的项（被选择的无法取消，符号为-Y-或者{Y}） help 打印帮助，menuconfig可以用shift+？查看 tristate 模块选项，&lt;M&gt;或者&lt;Y&gt;或者&lt;N&gt;（三态） int/hex/string 选项值为整型数或十六进制数或字符串 range 整型数的范围 default 默认值，数值或者布尔y/n或者字符串或者choice中的选项 prompt 出现在choice中的菜单文字 source 引入子目录的Kconfig 补充： 无depends on，default 为y：默认为y，一般用于必须要设置的选项，此时不要设置prompt； 有depends on，default 为y：所依赖的条目己设置，则默认为y；所依赖的条目未设置，则为n； 有depends on，default 为n：所依赖的条目己设置，则默认为n；所依赖的条目未设置，则为n； 无depends on，default 为n：在为设置prompt的情况下，此选项想要被设置，需要由其他选项来select它。 结构语法if…endif123456789if ARCH_S5PC100 ---&gt;如果ARCH_S5PC100选项选中了，则在endif范围内的选项才会被选config CPU_S5PC100 bool &quot;选项名&quot; select S5P_EXT_INT select SAMSUNG_DMADEV help Enable S5PC100 CPU supportendif choice…endchoice1234567891011121314151617choice ---&gt;表示选择列表 prompt &quot;Default I/O scheduler&quot; //主目录名字 default DEFAULT_CFQ //默认CFQ help Select the I/O scheduler which will be used by default for all block devices. config DEFAULT_DEADLINE bool &quot;Deadline&quot; if IOSCHED_DEADLINE=y config DEFAULT_CFQ bool &quot;CFQ&quot; if IOSCHED_CFQ=y config DEFAULT_NOOP bool &quot;No-op&quot;endchoice menu123456789101112menu &quot;Boot options&quot; ----&gt; menu表示该选项是`不可选`的菜单，其后是在选择列表的菜单名config USE_OF bool &quot;Flattened Device Tree support&quot; select IRQ_DOMAIN select OF select OF_EARLY_FLATTREE help Include support for flattened device tree machine descriptions.....endmenu ----&gt; menu菜单结束 menuconfig12345menuconfig TEST ---&gt; menuconfig表示TEST是一个`可选`菜单，其选中后是CONFIG_TEST bool &quot;菜单名&quot;if TEST...endif # TEST menu 和 choice 的区别：menu可以多选；choice为单选。 menuconfig 和 menu 的区别：menuconfig本身是可以选中，而menu只能进入子菜单选择，一般menuconfig的句柄是子项的依赖项，而menu是子项的汇总。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"kernel","slug":"kernel","permalink":"http://yoursite.com/tags/kernel/"}]},{"title":"linux内核配置--Boot options","slug":"linux内核配置-Boot-options","date":"2019-07-24T12:21:19.000Z","updated":"2019-07-30T15:46:37.784Z","comments":true,"path":"2019/07/24/linux内核配置-Boot-options/","link":"","permalink":"http://yoursite.com/2019/07/24/linux内核配置-Boot-options/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核的配置过程依赖Makefile和arch/arm/Kconfig以及其他文件下的Kconfig文件，通过make menuconfig或者桌面环境下的xconfig/gconfig可以手动配置内核所支持的功能。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下为Boot options启动设置的配置。","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核的配置过程依赖Makefile和arch/arm/Kconfig以及其他文件下的Kconfig文件，通过make menuconfig或者桌面环境下的xconfig/gconfig可以手动配置内核所支持的功能。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下为Boot options启动设置的配置。 -Y- Flattened Device Tree support&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支持设备树。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Include support for flattened device tree machine descriptions. [Y] Support for the traditional ATAGS boot data passing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支持传统的ATAGS启动数据传递。除非仅依赖设备树，否则建议选择。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ATAGS是传统的linux内核接收参数的方式，另一种是DTB。设备启动时，BOOT向内核传递三个参数，其中R0寄存器内容为一个“0”，R1是机器码（与内核匹配），R3为ATAGS或者DTB传递的地址。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is the traditional way of passing data to the kernel at boot time. If you are solely relying on the flattened device tree (or the ARM_ATAG_DTB_COMPAT option) then you may unselect this option to remove ATAGS support from your kernel binary. If unsure, leave this to y. [N] Provide old way to pass kernel parameters&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供传递内核参数的旧方法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This was deprecated in 2001 and announced to live on for 5 years. Some old boot loaders still use this way. (0x0) Compressed ROM boot loader base address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default “0”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存放基地址，对zImage压缩镜像启动很重要。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The physical address at which the ROM-able zImage is to be placed in the target. Platforms which normally make use of ROM-able zImage formats normally set this to a suitable value in their defconfig file.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If ZBOOT_ROM is not enabled, this has no effect. (0x0) Compressed ROM boot loader BSS address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default “0”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引导的BSS地址。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The base address of an area of read/write memory in the target for the ROM-able zImage which must be available while the decompressor is running. It must be large enough to hold the entire decompressed kernel plus an additional 128 KiB.Platforms which normally make use of ROM-able zImage formats normally set this to a suitable value in their defconfig file.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If ZBOOT_ROM is not enabled, this has no effect. [Y] Use appended device tree blob to zImage (EXPERIMENTAL)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将附加的设备树blob用于zImage（实验）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;With this option, the boot code will look for a device tree binary (DTB) appended to zImage (e.g. cat zImage .dtb &gt; zImage_w_dtb).This is meant as a backward compatibility convenience for those systems with a bootloader that can’t be upgraded to accommodate the documented boot protocol using a device tree. Beware that there is very little in terms of protection against this option being confused by leftover garbage in memory that might look like a DTB header after a reboot if no actual DTB is appended to Image. Do not leave this option active in a production kernel if you don’t intend to always append a DTB.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Proper passing of the location into r2 of a bootloader provided DTB is always preferable to this option. [Y] Supplement the appended DTB with traditional ATAG information&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用传统的ATAG信息补充附加的DTB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some old bootloaders can’t be updated to a DTB capable one, yet they provide ATAGs with memory configuration, the ramdisk address, the kernel cmdline string, etc.Such information is dynamically provided by the bootloader and can’t always be stored in a static DTB. To allow a device tree enabled kernel to be used with such bootloaders, this option allows zImage to extract the information from the ATAG list and store it at run time into the appended DTB. [C] Kernel command line type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核命令行类型。 [X] Use bootloader kernel arguments if available&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优先使用bootloader（uboot）参数，如果没有就使用DTB ARGS。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为通过uboot修改环境变量比修改内核容易得多，因此使用bootloader更方便。造成的问题是内核配置的变量可能被覆盖。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uses the command-line options passed by the boot loader instead of the device tree bootargs property. If the boot loader doesn’t provide any, the device tree bootargs property will be used. [N] Extend with bootloader kernel arguments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用DTB ARGS，bootloader提供的追加在其之后。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The command-line arguments provided by the boot loader will be appended to the the device tree bootargs property. (N) Default kernel command string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认的内核命令行字符串。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;On some architectures (EBSA110 and CATS), there is currently no way for the boot loader to pass arguments to the kernel. For these architectures, you should supply some command-line options at build time by entering them here. As a minimum, you should specify the memory size and the root device (e.g., mem=64M root=/dev/nfs). [N] Build kdump crash kernel (EXPERIMENTAL)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支持core dump的内核调试工具。Kdump是系统崩溃时，通过kexec工具转储内存（运行在一个主内核不占用的额外的内存区域）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate crash dump after being started by kexec. This should be normally only set in special crash dump kernels which are loaded in the main kernel with kexec-tools into a specially reserved region and then later executed after a crash by kdump/kexec. The crash dump kernel must be compiled to a memory address not used by the main kernel. For more details see Documentation/kdump/kdump.txt -Y- Auto calculation of the decompressed kernel image address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动计算解压缩的内核映像地址。如果选择，开机后内核地址为0xf8000000，即在前128MB的位置（0x8000000=12810241024）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZRELADDR is the physical address where the decompressed kernel image will be placed. If AUTO_ZRELADDR is selected, the address will be determined at run-time by masking the current IP with 0xf8000000. This assumes the zImage being placed in the first 128MB from start of memory. [Y] UEFI runtime support&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此选项提供对UEFI固件提供的运行时服务的支持（例如非易失性变量，实时时钟和平台重置）。还提供UEFI存根以允许内核作为EFI应用程序引导。这仅适用于可能在具有UEFI固件的系统上运行的内核。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option provides support for runtime services provided by UEFI firmware (such as non-volatile variables, realtime clock, and platform reset). A UEFI stub is also provided to allow the kernel to be booted as an EFI application. This is only useful for kernels that may run on systems that have UEFI firmware. [Y] Enable support for SMBIOS (DMI) tables&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This enables SMBIOS/DMI feature for systems. This option is only useful on systems that have UEFI firmware. However, even with this option, the resultant kernel should continue to boot on existing non-UEFI platforms.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NOTE: This does NOT enable or encourage the use of DMI quirks, i.e., the the practice of identifying the platform via DMI to decide whether certain workarounds for buggy hardware and/or firmware need to be enabled. This would require the DMI subsystem to be enabled much earlier than we do on ARM, which is non-trivial.","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"kernel","slug":"kernel","permalink":"http://yoursite.com/tags/kernel/"}]},{"title":"编译内核用到的图形界面工具","slug":"编译内核用到的图形界面工具","date":"2019-07-22T09:48:33.000Z","updated":"2019-08-10T05:26:12.183Z","comments":true,"path":"2019/07/22/编译内核用到的图形界面工具/","link":"","permalink":"http://yoursite.com/2019/07/22/编译内核用到的图形界面工具/","excerpt":"menuconfig运行在没有桌面环境的主机上，可以查看选项功能，不支持搜索，需要安装终端的图形包。 12$ make menuconfig $ sudo apt-get install libncurses5-dev","text":"menuconfig运行在没有桌面环境的主机上，可以查看选项功能，不支持搜索，需要安装终端的图形包。 12$ make menuconfig $ sudo apt-get install libncurses5-dev xconfig可以查看选项功能，支持搜索功能，需要安装QT依赖包。 12345$ make xconfig$ CHECK qt$ Could not find Qt via pkg-config.$ Please install either Qt 4.8 or 5.x. and make sure it&apos;s in PKG_CONFIG_PATH$ apt-get install qt4-dev-tools 安装后运行如下： gconfig可以查看选项功能，需要安装gtk的包。 123456$ make gconfig$ Unable to find the GTK+ installation. Please make sure that$ the GTK+ 2.0 development package is correctly installed...$ You need gtk+-2.0, glib-2.0 and libglade-2.0.$ sudo apt-get install libgtk2.0-dev libglib2.0-dev libglade2-dev 安装后运行如下：","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/categories/嵌入式/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"kernel","slug":"kernel","permalink":"http://yoursite.com/tags/kernel/"}]},{"title":"使用VScode和Cmake搭建嵌入式开发环境","slug":"使用VScode和Cmake搭建嵌入式开发环境","date":"2019-07-22T09:45:53.000Z","updated":"2019-07-28T12:54:48.694Z","comments":true,"path":"2019/07/22/使用VScode和Cmake搭建嵌入式开发环境/","link":"","permalink":"http://yoursite.com/2019/07/22/使用VScode和Cmake搭建嵌入式开发环境/","excerpt":"配置主机开发环境1) 安装Ubuntu 16.04操作系统，双系统、虚拟机、单系统或windows子系统2) 安装TI SDK并配置交叉编译环境，并配置环境变量3) 安装SecureCRT或者minicom等串口软件，运行secureCRT或者minicom均需要超级权限sudo。4) 配置有线以太网地址（ipv4） 1234Address:192.168.111.101Netmask:255.255.255.0Gateway:192.168.111.1DNS:4.4.4.4","text":"配置主机开发环境1) 安装Ubuntu 16.04操作系统，双系统、虚拟机、单系统或windows子系统2) 安装TI SDK并配置交叉编译环境，并配置环境变量3) 安装SecureCRT或者minicom等串口软件，运行secureCRT或者minicom均需要超级权限sudo。4) 配置有线以太网地址（ipv4） 1234Address:192.168.111.101Netmask:255.255.255.0Gateway:192.168.111.1DNS:4.4.4.4 配置项目工程Linux可以使用许多IDE，甚至可以脱离集成开发环境通过撰写Makefile管理项目文件。 Makefile假设工程文件中包括main.c、spi.c以及head.h，为了生成可执行文件，需要生成main.c和spi.c的链接文件main.o和spi.o，而main.o和spi.o也需要编译生成。这个过程就是makefile的执行过程。以下为Makefile的内容： 12345678910CC=gcc //gcc或者交叉编译gccOBJ=main.o spi.o //OBJ是生成的链接文件目标，作为变量方便main: $(OBJ) //main可执行文件的生成需要OBJ中的两个文件 $(CC) -o $@ $^ // -o表示生成可执行文件 $@表示目标文件（main）；$^表示所有依赖文件（OBJ）spi.o: spi.c head.h $(CC) -c $&lt; // $&lt; 表示第一个依赖文件（spi.c）main.o: main.c head.h $(CC) -c $&lt;clean: //make clean删除通过make指令生成的文件 rm main $(OBJ) VScode + Cmake当项目内容比较多时，可以通过CMake工具自动生成Makefile。Cmake主要配置CMakeLists.txt实现工程管理。推荐通过VScode生成CMake项目模板，过程如下：安装CMake插件；Ctrl+Shift+P，输入CMAKE QUICK START，选择gcc的kit，一般会自己查询到gcc或者交叉编译工具gcc，输入工程名称，再选择生成可执行文件。这样VScode就会生成项目模板。项目主要分为src、include、bin、build等文件夹，文件夹内容如下： 123456789101112|——zhx_cmake_prj #ZHX项目主要软件 |——bin #可执行文件夹目录 |——build #build目录 |——include #头文件目录 |——src #项目源文件 |——driver #设备驱动源文件目录 |——spi |——uart |... |——main.c |——CMakeLists.txt |——CMakeLists.txt CMakeLists主目录下的配置： 12345678cmake_minimum_required (VERSION 3.0.0)SET(CMAKE_C_COMPILER \"/usr/local/arm_gcc/bin/arm-linux-gnueabihf-gcc\") //配置CMAKE GCCSET(CMAKE_CXX_COMPILER \"/usr/local/arm_gcc/bin/arm-linux-gnueabihf-g++\")project(ZHX VERSION 0.1.0)MESSAGE (STATUS \"This is the binary dir: \" $&#123;PROJECT_BINARY_DIR&#125;)MESSAGE (STATUS \"This is the source dir: \" $&#123;PROJECT_SOURCE_DIR&#125;)INCLUDE_DIRECTORIES (include) //添加include路径ADD_SUBDIRECTORY(src) //添加src子目录 二级CMakeLists.txt（src文件夹下）： 123456AUX_SOURCE_DIRECTORY(. SRC_LIST) //添加当前目录为源码编译目录AUX_SOURCE_DIRECTORY(./driver/spi/ SRC_LIST)AUX_SOURCE_DIRECTORY(./driver/i2c/ SRC_LIST)AUX_SOURCE_DIRECTORY(../include/ SRC_LIST) //添加include为源码编译目录ADD_EXECUTABLE(main $&#123;SRC_LIST&#125; ) //通过源码目录中的所有依赖文件生成可执行文件mainSET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin) //将main输出至bin文件夹下 文件编译方式1234$ cd ($PRJ)/build $ cmake .. $ make$ cd ($PRJ)/bin 配置开发板制作SD卡运行$tisdk/bin/creat-sdcard.sh，替换zImage以及设备树文件。 远程登录与传递文件123$ ifconfig eth0 192.168.111.100$ ssh root@192.168.111.100$ scp file root@192.168.111.100:~ 如果显示ssh无法登陆，原因是当前ip地址与开发板的上一次刷的系统配置的ip地址冲突，使用以下命令删除旧的配置： 1$: ssh-keygen –f “/home/usr-name/.ssh/known_hosts” –R “192.168.111.100” 固定目标板的IP地址修改/etc/systemd/network/目录下的10-eth.network文件： 1234567[Match]Name=eth0KernelCommandLine=!root=/dev/nfs[Network]Address=192.168.111.100/24Gateway=192.168.111.1 串口收发文件目标板没有安装ssh时，通过TCP/IP无法传输文件，在文件容量较小的情况下可以使用lrzsz工具。Lrzsz工具解压后使用./configure命令配置makefile，在主机中需要将bin、src以及根目录下的makefile中的CC均改为交叉编译链，再在主目录中make，最后将src/lrz和src/lsz拷贝至目标板的/bin文件夹下。1) 主机向从机发送文件：从机运行lrz，主机选择通过zModem发送，（minicom中通过Ctrl+A-Z-S进入）文件将保存在从机当前目录下；2) 从机向主机发送文件：主机运行lrz（使用主机的gcc编译），从机运行： 1$ lsz file","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/categories/嵌入式/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"vscode","slug":"vscode","permalink":"http://yoursite.com/tags/vscode/"}]},{"title":"ARM Linux开发命令","slug":"ARM Linux开发命令","date":"2019-07-22T09:45:47.000Z","updated":"2019-07-23T07:14:30.268Z","comments":true,"path":"2019/07/22/ARM Linux开发命令/","link":"","permalink":"http://yoursite.com/2019/07/22/ARM Linux开发命令/","excerpt":"使用开发板版本：TI AM5728 EVM使用SDK版本：ti-processor-sdk-linux-rt-am57xx-evm-05.02.00.10官方软件支持：RT-Linux-software官方软件使用说明(更新至6.00.00.07,2019年7月)：TISDKTI中文社区：e2echina.ti创龙论坛：51ele","text":"使用开发板版本：TI AM5728 EVM使用SDK版本：ti-processor-sdk-linux-rt-am57xx-evm-05.02.00.10官方软件支持：RT-Linux-software官方软件使用说明(更新至6.00.00.07,2019年7月)：TISDKTI中文社区：e2echina.ti创龙论坛：51ele 内核编译命令1234make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- tisdk_am57xx-evm-rt_defconfig make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage -j16make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean 生成的zImage替换/rootfs/boot下的zImage文件。 内核源码内核功能裁剪思路设备树改写命令1make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- am57xx-evm-reva3.dtb -j8 源码位置：$tisdk/arch/arm/boot/dts/am57xx-beagle-x15-common.dtsi等。生成的am57xx-evm-reva3.dtb替换/rootfs/boot下的设备树文件。 编译模块12make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modules -j16sudo make ARCH=arm INSTALL_MOD_PATH=../rootfs modules_install 模块的版本要与内核一致，所以要编译模块。加载模块指令：insmod。卸载模块指令。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/categories/嵌入式/"}],"tags":[{"name":"arm","slug":"arm","permalink":"http://yoursite.com/tags/arm/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"如何利用hexo和github搭建免费个人博客","slug":"如何利用hexo和github搭建免费个人博客","date":"2019-07-19T14:30:53.524Z","updated":"2019-08-10T05:25:29.178Z","comments":true,"path":"2019/07/19/如何利用hexo和github搭建免费个人博客/","link":"","permalink":"http://yoursite.com/2019/07/19/如何利用hexo和github搭建免费个人博客/","excerpt":"文章转载来自使用 Hexo + Github 搭建自己的博客（图文教程）替换主题参考Hexo 安装和替换主题、自定义博客主题","text":"文章转载来自使用 Hexo + Github 搭建自己的博客（图文教程）替换主题参考Hexo 安装和替换主题、自定义博客主题 搭建过程安装git node.js查看版本命令用 12$ npm -v$ node -v 新建仓库新建一个repository，名称为 name.github.io 安装Hexo1234567$ npm install hexo -g$ hexo -v$ hexo init$ npm install$ hexo g$ hexo s #查看本地新建的hexo$ npm install hexo-deployer-git --save 修改_config.yml1234deploy: type: git repository: git@github.com:sjl3110/sjl3110.github.io.git branch: master 建立ssh密钥1ssh-keygen -t rsa -C \"mail@xx.com\" 并将默认保存位置的id_rsa.pub内容存放到github网站中的SSH密钥中。 维护过程12$ hexo new post \"blog-name\"$ hexo d -g","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"基于TCP/IP网络socket通信","slug":"基于TCP-IP网络socket通信","date":"2019-07-19T13:55:15.200Z","updated":"2019-08-10T05:25:19.390Z","comments":true,"path":"2019/07/19/基于TCP-IP网络socket通信/","link":"","permalink":"http://yoursite.com/2019/07/19/基于TCP-IP网络socket通信/","excerpt":"网络传输文件现有的工具为ssh或者tcp指令，ssh中的scp指令如下： 1$ scp file name@IP:file_path 测试在百兆带宽的情况下，可以达到5~6MB/s。SSH的用户层工作原理，除去登陆密码以及公钥或者私钥的建立，底层的工作模式也需要考虑。","text":"网络传输文件现有的工具为ssh或者tcp指令，ssh中的scp指令如下： 1$ scp file name@IP:file_path 测试在百兆带宽的情况下，可以达到5~6MB/s。SSH的用户层工作原理，除去登陆密码以及公钥或者私钥的建立，底层的工作模式也需要考虑。 网络设备驱动网络层次七层又可以分为应用层（应用层、表示层与会话层）、传输层、网络层、数据链路层以及物理层。网络设备驱动负责将数据包写入网络或者从网络中读取数据包，从而完成上层的请求，与其他接口开发的不同是 网络设备不在/dev下创建设备文件； 底层采用中断的工作方式，并将中断传递给上层应用程序（这与UART类似）。 内核配置—&gt; Networking support &gt; Networking options网络功能选择：在内核中配置EtherNet网口支持的功能。 内核选项 含义 Packet socket 支持Socket通信 Unix domain sockets Socket进程间通信 TCP/IP networking TCP/TP网络协议 IP:multicasting 组播，多目标发送 IP:advanced router 高级路由，流量控制 IP:kernel level autoconfiguration 内核启动时自动获取IP IP:DHCP suppo DHCP 获取动态IP协议 IP:BOOTP support DHCP的前身 IP:RARP support 反向地址转换协议 — &gt; Device Drivers &gt; Network device support ─ Ethernet driver support配置芯片驱动：选择对应厂商的芯片，若没有需要写适配的驱动源码！ 设备树配置直接引用dra7.dtsi设备树源文件中的以太网寄存器配置。 12345678&amp;davinci_mdio &#123; phy0: ethernet-phy@1 &#123; reg = &lt;1&gt;; &#125;; phy1: ethernet-phy@2 &#123; reg = &lt;2&gt;; &#125;;&#125;; 传输协议数据传输协议 服务端accept()函数为阻塞函数，主进程执行至accept后进程阻塞，直到客户端发出连接请求； 接收请求后使用fork()函数创建子进程，这样就可以通过不同的子进程连接多个客户端； Send()函数将指定长度数据发送至内存缓冲队列，发送后等待对方确认（客户端确认和服务端重新发送在底层完成）； recv()函数也是阻塞函数，在队列中没有数据时，recv()进程进入阻塞，recv()成功读取则返回读取长度。 文件传输协议 缓冲区长度有限，若客户端不执行recv()则服务端发送一定量的数据包后停止发送； 客户端需要加入文件末尾判断的语句； 若 T1&gt;T2，则recv()函数并不能一次读取设定长度的数据，即有多少读多少，增加了客户端读取循环的次数，降低了传输效率； 测试与改进实际测试：文件长度50160000，约50MB；网络带宽100Mb，上限约12.5MB/s。设每次发送10000Byte，测得：服务端发送5016个数据包，客户端每次接收1000–10000长度不等的包，实际接收了13000个数据包，最终传输速率为2MB/s。改进：每次recv()先与对方确认包的长度，并将内容读满再返回，配置MSG_WAITALL。测试结果：服务端发送5016个数据包，客户端接收了5016个数据包，最终传输速率为10–12MB/s。 配置数据包 在应用层编写实现类似底层包的组帧结构的协议，可以完成多个文件的收发； 由于组包与解包的加入，速度略有牺牲，测试速度约为4~5MB/s。 应用程序服务端 server.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/shm.h&gt;#include &lt;time.h&gt;#define PORT 8888#define QUEUE_SIZE 10#define BUFFER_SIZE 10000//传进来的sockfd，就是互相建立好连接之后的socket文件描述符//通过这个sockfd，可以完成 [服务端]&lt;---&gt;[客户端] 互相收发数据void transfer_file(int sockfd)&#123; FILE *fp; int ch; time_t t_start, t_end; int send_num; long length = 0; //char name[LEN]; // storage for output filename int count = 0; fp = fopen(\"test.txt\", \"r\"); if (fp == NULL) &#123; fprintf(stderr, \"couldn't open the file \\n\"); exit(EXIT_FAILURE); &#125; fseek(fp, 0L, SEEK_END); //将文件指针移到末尾 length = ftell(fp); //获取文件长度 printf(\"%ld\\n\", length); char str[10]; sprintf(str, \"%ld\", length); //将文件长度转换为字符串str send(sockfd, str, sizeof(str), 0); //将文件长度发送给client char buffer1[BUFFER_SIZE]; recv(sockfd, buffer1, sizeof(buffer1), 0); //等待对方读取完长度后返回“ready” if (strcmp(buffer1, \"ready\") == 0) &#123; fseek(fp, 0L, SEEK_SET); //文件指针移到开头 // char buffer[1]; // copy data // while ((ch = getc(fp)) != EOF) // &#123; // buffer[0] = ch; // send(sockfd, buffer, 1, 0); // &#125; t_start = time(NULL); //获取开始时间 char buffer[BUFFER_SIZE]; //新建缓存 send_num = 0; //计算发送包的个数 while (fread(buffer, sizeof(buffer), 1, fp)) //fread 读文件到缓存，读到末尾会EOF（-1） &#123; //printf(\"send%d %ld\\n\",send_num,sizeof(buffer)); send(sockfd, buffer, sizeof(buffer), 0); //发送一个文件包 send_num++; //break; &#125; t_end = time(NULL); //获取结束时间 printf(\"send %d times\\n\", send_num); printf(\"speed: %.02f MB/s\\n\", length / 1024 / 1024 / difftime(t_end, t_start)); if (fclose(fp) != 0) //关闭文件 fprintf(stderr, \"Error in closing files\\n\"); &#125; else &#123; printf(\"cannot get start!\\n\"); &#125;&#125;int str_echo(int sockfd) //回环函数&#123; char buffer[BUFFER_SIZE]; //新建内存缓冲区 pid_t pid = getpid(); while (1) &#123; memset(buffer, 0, sizeof(buffer)); //将内存缓冲区清0，初始化 int len = recv(sockfd, buffer, sizeof(buffer), 0); printf(\"pid:%d receive:\\n\", pid); fputs(buffer, stdout); if (strcmp(buffer, \"exit\\n\") == 0) &#123; printf(\"child process: %d exited.\\n\", pid); printf(\"the server shutdown.\\n\"); break; &#125; if (strcmp(buffer, \"send\\n\") == 0) &#123; printf(\"start transfer.\\n\"); transfer_file(sockfd); printf(\"transfer end.\\n\"); //sleep(10); //printf(\"the server shutdown.\\n\"); continue; &#125; send(sockfd, buffer, len, 0); &#125; close(sockfd); return -1;&#125;int main(int argc, char **argv)&#123; //定义IPV4的TCP连接的套接字描述符 int server_sockfd = socket(AF_INET, SOCK_STREAM, 0); //定义sockaddr_in struct sockaddr_in server_sockaddr; server_sockaddr.sin_family = AF_INET; server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY); server_sockaddr.sin_port = htons(PORT); //bind成功返回0，出错返回-1 if (bind(server_sockfd, (struct sockaddr *)&amp;server_sockaddr, sizeof(server_sockaddr)) == -1) &#123; perror(\"bind\"); exit(1); //1为异常退出 &#125; printf(\"bind success.\\n\"); //listen成功返回0，出错返回-1，允许同时帧听的连接数为QUEUE_SIZE if (listen(server_sockfd, QUEUE_SIZE) == -1) &#123; perror(\"listen\"); exit(1); &#125; printf(\"listen success.\\n\"); for (;;) &#123; struct sockaddr_in client_addr; socklen_t length = sizeof(client_addr); //进程阻塞在accept上，成功返回非负描述字，出错返回-1 int conn = accept(server_sockfd, (struct sockaddr *)&amp;client_addr, &amp;length); if (conn &lt; 0) &#123; perror(\"connect\"); exit(1); &#125; printf(\"new client accepted.\\n\"); pid_t childid; if (childid = fork() == 0) //子进程 &#123; printf(\"child process: %d created.\\n\", getpid()); close(server_sockfd); //在子进程中关闭监听 if (str_echo(conn) &lt; 0) //处理监听的连接 &#123; exit(0); //对方发送exit，返回-1，关闭子进程，主进程继续accep &#125; &#125; &#125; printf(\"closed.\\n\"); close(server_sockfd); printf(\"end\\n\"); exit(0); return 0;&#125; 客户端编译后执行： 12$ ifconfig eth0 192.168.111.101$ ./server 客户端 client.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/shm.h&gt;#include &lt;time.h&gt;#define PORT 8888#define BUFFER_SIZE 10000int main(int argc, char **argv)&#123; if (argc != 2) &#123; printf(\"usage: client IP \\n\"); exit(0); &#125; //定义IPV4的TCP连接的套接字描述符 int sock_cli = socket(AF_INET, SOCK_STREAM, 0); FILE *out; time_t t_start, t_end; long i, receive_length, file_length, length; int receive_num; //定义sockaddr_in struct sockaddr_in servaddr; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = inet_addr(argv[1]); servaddr.sin_port = htons(PORT); //服务器端口 //连接服务器，成功返回0，错误返回-1 if (connect(sock_cli, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) &#123; perror(\"connect\"); exit(1); &#125; printf(\"connect server(IP:%s).\\n\", argv[1]); char sendbuf[BUFFER_SIZE]; char recvbuf[BUFFER_SIZE]; memset(sendbuf, 0, sizeof(sendbuf)); memset(recvbuf, 0, sizeof(recvbuf)); //客户端将控制台输入的信息发送给服务器端，服务器原样返回信息 while (fgets(sendbuf, sizeof(sendbuf), stdin) != NULL) //捕获命令行的字符串到sendbuf &#123; memset(recvbuf, 0, sizeof(recvbuf)); send(sock_cli, sendbuf, strlen(sendbuf), 0); ///发送 if (strcmp(sendbuf, \"exit\\n\") == 0) &#123; printf(\"client exited.\\n\"); break; &#125; if (strcmp(sendbuf, \"send\\n\") == 0) &#123; if ((out = fopen(\"out.txt\", \"w\")) == NULL) &#123; // open file for writing fprintf(stderr, \"Can't create output file.\\n\"); exit(3); &#125; recv(sock_cli, recvbuf, sizeof(recvbuf), 0); file_length = atoi(recvbuf); memset(recvbuf, 0, sizeof(recvbuf)); //获取文件长度 memset(sendbuf, 0, sizeof(sendbuf)); send(sock_cli, \"ready\", 5, 0); //发送就绪 printf(\"receive file start.\\n\"); t_start = time(NULL); length = 0; receive_num = 0; while (length &lt; file_length) &#123; receive_length = recv(sock_cli, recvbuf, sizeof(recvbuf), MSG_WAITALL); ///接收 //MSG_WAITALL是强行等待缓冲满再结束 //sleep(1); //printf(\"%d length %d\\n\", receive_num,receive_length); //fputs(recvbuf, stdout); //printf(\"run dot1\\n\"); //for (i = 0; i &lt; receive_length; i++) //&#123; //putc(recvbuf[i], out); //&#125; fprintf(out, \"%s\", recvbuf); //memset(sendbuf, 0, sizeof(sendbuf)); memset(recvbuf, 0, sizeof(recvbuf)); //printf(\"run\\n\"); length = length + receive_length; receive_num++; //break; &#125; printf(\"receive %d times\\n\", receive_num); if (fclose(out) != 0) fprintf(stderr, \"Error in closing files\\n\"); t_end = time(NULL); printf(\"time : %.2f s\\n\", difftime(t_end, t_start)); printf(\"speed: %.02f MB/s\\n\", file_length / 1024 / 1024 / difftime(t_end, t_start)); printf(\"receive file end.\\n\"); continue; &#125; printf(\"client receive:\\n\"); recv(sock_cli, recvbuf, sizeof(recvbuf), 0); ///接收 fputs(recvbuf, stdout); memset(sendbuf, 0, sizeof(sendbuf)); &#125; close(sock_cli); return 0;&#125; 服务端编译后执行： 12345$ ifconfig eth0 192.168.111.100$ ./client 192.168.111.101$ mesg //对方回环$ send //对方发送文件$ exit //对方关闭服务子进程，客户端退出","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/categories/嵌入式/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"}]},{"title":"Windows系统配置Linux子系统开发ARM","slug":"Windows系统配置Linux子系统开发ARM","date":"2019-07-19T11:42:09.451Z","updated":"2019-07-23T07:14:34.386Z","comments":true,"path":"2019/07/19/Windows系统配置Linux子系统开发ARM/","link":"","permalink":"http://yoursite.com/2019/07/19/Windows系统配置Linux子系统开发ARM/","excerpt":"Win10可以支持Ubuntu子系统，再也不需要虚拟机！ 安装系统系统要求：最新版win10，打开应用商店安装Ubuntu应用软件，需要系统开启虚拟机功能以及LINUX子系统功能。安装完成后如下：","text":"Win10可以支持Ubuntu子系统，再也不需要虚拟机！ 安装系统系统要求：最新版win10，打开应用商店安装Ubuntu应用软件，需要系统开启虚拟机功能以及LINUX子系统功能。安装完成后如下： 配置 Ubuntu换源等操作。 12345678910111213141516$ cd /etc/apt$ sudo cp sources.list sources.list.bak$ sudo vi sources.list$ add deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse$ sudo apt-get update$ sudo apt-get upgrade 安装 gcc 交叉编译工具命名规则交叉编译工具链的命名规则为：arch [-vendor] [-os] [-(gnu)eabi] arch - 体系架构，如ARM，MIPS vendor - 工具链提供商 os - 目标操作系统 eabi - 嵌入式应用二进制接口（Embedded ApplicationBinary Interface） 根据对操作系统的支持与否，ARM GCC可分为支持和不支持操作系统，如arm-none-eabi：这个是没有操作系统的，自然不可能支持那些跟操作系统关系密切的函数，比如fork()。使用的是newlib这个专用于嵌入式系统的C库。arm-none-linux-eabi：用于Linux的，使用Glibc。比如:arm-none-eabi-gcc：用于编译 ARM 架构的裸机系统（包括 ARM Linux 的 boot、kernel，不适用编译 Linux 应用 Application）。arm-none-linux-gnueabi-gcc：主要用于基于 ARM 架构的 Linux 系统，可用于编译 ARM 架构的 u-boot、Linux内核、Linux应用等。arm-eabi-gcc：Android ARM 编译器。armcc ARM：公司推出的编译工具，功能和 arm-none-eabi 类似。arm-none-uclinuxeabi-gcc：用于uCLinux，使用Glibc。arm-none-symbianelf-gcc：用于symbian。下载链接: gcc-toolchain 123$ tar xvf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf.tar.xz -C /usr/local/arm_gcc$ sudo vim /etc/profile$ export PATH=/usr/local/arm_gcc/bin/:$PATH 安装 Minicom12$ sudo apr-get install minicom$ sudo minicom -D /dev/ttySx 编译代码需要在CMakelists.txt中set gcc和g++路径，其余与Linux正常。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"arm","slug":"arm","permalink":"http://yoursite.com/tags/arm/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]}]}