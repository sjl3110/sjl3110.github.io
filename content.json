{"meta":{"title":"个人博客","subtitle":"记录点滴，分享生活","description":"浙江大学航空航天学院","author":"沈建谅","url":"http://yoursite.com","root":"/"},"pages":[{"title":"所有分类","date":"2019-07-20T02:00:55.000Z","updated":"2019-07-20T02:23:25.822Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-07-20T01:58:15.000Z","updated":"2019-07-20T02:23:10.772Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-07-20T02:28:21.000Z","updated":"2019-07-20T08:04:14.618Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"联系方式电话：15895898063地址：浙江杭州邮箱：jianliang_shen@zju.edu.cn仓库：https://github.com/sjl3110 教育背景本科：南京理工大学硕士：浙江大学 专业技能嵌入式硬件电路设计ARM Linux系统开发操作系统应用软件开发"}],"posts":[{"title":"linux内核配置--Boot options","slug":"linux内核配置-Boot-options","date":"2019-07-24T12:21:19.000Z","updated":"2019-07-25T12:11:32.691Z","comments":true,"path":"2019/07/24/linux内核配置-Boot-options/","link":"","permalink":"http://yoursite.com/2019/07/24/linux内核配置-Boot-options/","excerpt":"内核的配置过程依赖Makefile和arch/arm/Kconfig以及其他文件下的Kconfig文件，通过make menuconfig或者桌面环境下的xconfig/gconfig可以手动配置内核所支持的功能。以下为Boot options启动设置的配置。","text":"内核的配置过程依赖Makefile和arch/arm/Kconfig以及其他文件下的Kconfig文件，通过make menuconfig或者桌面环境下的xconfig/gconfig可以手动配置内核所支持的功能。以下为Boot options启动设置的配置。 -Y- Flattened Device Tree support支持设备树。Include support for flattened device tree machine descriptions. [Y] Support for the traditional ATAGS boot data passing支持传统的ATAGS启动数据传递。除非仅依赖设备树，否则建议选择。ATAGS是传统的linux内核接收参数的方式，另一种是DTB。设备启动时，BOOT向内核传递三个参数，其中R0寄存器内容为一个“0”，R1是机器码（与内核匹配），R3为ATAGS或者DTB传递的地址。This is the traditional way of passing data to the kernel at boot time. If you are solely relying on the flattened device tree (or the ARM_ATAG_DTB_COMPAT option) then you may unselect this option to remove ATAGS support from your kernel binary. If unsure, leave this to y. [N] Provide old way to pass kernel parameters提供传递内核参数的旧方法。This was deprecated in 2001 and announced to live on for 5 years. Some old boot loaders still use this way. (0x0) Compressed ROM boot loader base addressdefault “0”存放基地址，对zImage压缩镜像启动很重要。The physical address at which the ROM-able zImage is to be placed in the target. Platforms which normally make use of ROM-able zImage formats normally set this to a suitable value in their defconfig file.If ZBOOT_ROM is not enabled, this has no effect. (0x0) Compressed ROM boot loader BSS addressdefault “0”引导的BSS地址。The base address of an area of read/write memory in the target for the ROM-able zImage which must be available while the decompressor is running. It must be large enough to hold the entire decompressed kernel plus an additional 128 KiB.Platforms which normally make use of ROM-able zImage formats normally set this to a suitable value in their defconfig file.If ZBOOT_ROM is not enabled, this has no effect. [Y] Use appended device tree blob to zImage (EXPERIMENTAL)将附加的设备树blob用于zImage（实验）。With this option, the boot code will look for a device tree binary (DTB) appended to zImage (e.g. cat zImage .dtb &gt; zImage_w_dtb).This is meant as a backward compatibility convenience for those systems with a bootloader that can’t be upgraded to accommodate the documented boot protocol using a device tree. Beware that there is very little in terms of protection against this option being confused by leftover garbage in memory that might look like a DTB header after a reboot if no actual DTB is appended to Image. Do not leave this option active in a production kernel if you don’t intend to always append a DTB.Proper passing of the location into r2 of a bootloader provided DTB is always preferable to this option. [Y] Supplement the appended DTB with traditional ATAG information用传统的ATAG信息补充附加的DTBSome old bootloaders can’t be updated to a DTB capable one, yet they provide ATAGs with memory configuration, the ramdisk address, the kernel cmdline string, etc.Such information is dynamically provided by the bootloader and can’t always be stored in a static DTB. To allow a device tree enabled kernel to be used with such bootloaders, this option allows zImage to extract the information from the ATAG list and store it at run time into the appended DTB. [C] Kernel command line type内核命令行类型。 [X] Use bootloader kernel arguments if available优先使用bootloader（uboot）参数，如果没有就使用DTB ARGS。因为通过uboot修改环境变量比修改内核容易得多，因此使用bootloader更方便。造成的问题是内核配置的变量可能被覆盖。Uses the command-line options passed by the boot loader instead of the device tree bootargs property. If the boot loader doesn’t provide any, the device tree bootargs property will be used. [N] Extend with bootloader kernel arguments使用DTB ARGS，bootloader提供的追加在其之后。The command-line arguments provided by the boot loader will be appended to the the device tree bootargs property. (N) Default kernel command string默认的内核命令行字符串。On some architectures (EBSA110 and CATS), there is currently no way for the boot loader to pass arguments to the kernel. For these architectures, you should supply some command-line options at build time by entering them here. As a minimum, you should specify the memory size and the root device (e.g., mem=64M root=/dev/nfs). [N] Build kdump crash kernel (EXPERIMENTAL)支持core dump的内核调试工具。Kdump是系统崩溃时，通过kexec工具转储内存（运行在一个主内核不占用的额外的内存区域）。Generate crash dump after being started by kexec. This should be normally only set in special crash dump kernels which are loaded in the main kernel with kexec-tools into a specially reserved region and then later executed after a crash by kdump/kexec. The crash dump kernel must be compiled to a memory address not used by the main kernel. For more details see Documentation/kdump/kdump.txt -Y- Auto calculation of the decompressed kernel image address自动计算解压缩的内核映像地址。如果选择，开机后内核地址为0xf8000000，即在前128MB的位置（0x8000000=12810241024）。ZRELADDR is the physical address where the decompressed kernel image will be placed. If AUTO_ZRELADDR is selected, the address will be determined at run-time by masking the current IP with 0xf8000000. This assumes the zImage being placed in the first 128MB from start of memory. [Y] UEFI runtime support此选项提供对UEFI固件提供的运行时服务的支持（例如非易失性变量，实时时钟和平台重置）。还提供UEFI存根以允许内核作为EFI应用程序引导。这仅适用于可能在具有UEFI固件的系统上运行的内核。This option provides support for runtime services provided by UEFI firmware (such as non-volatile variables, realtime clock, and platform reset). A UEFI stub is also provided to allow the kernel to be booted as an EFI application. This is only useful for kernels that may run on systems that have UEFI firmware. [Y] Enable support for SMBIOS (DMI) tablesThis enables SMBIOS/DMI feature for systems. This option is only useful on systems that have UEFI firmware. However, even with this option, the resultant kernel should continue to boot on existing non-UEFI platforms.NOTE: This does NOT enable or encourage the use of DMI quirks, i.e., the the practice of identifying the platform via DMI to decide whether certain workarounds for buggy hardware and/or firmware need to be enabled. This would require the DMI subsystem to be enabled much earlier than we do on ARM, which is non-trivial.","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"kernel","slug":"kernel","permalink":"http://yoursite.com/tags/kernel/"}]},{"title":"编译内核用到的图形界面工具","slug":"编译内核用到的图形界面工具","date":"2019-07-22T09:48:33.000Z","updated":"2019-07-23T07:13:49.515Z","comments":true,"path":"2019/07/22/编译内核用到的图形界面工具/","link":"","permalink":"http://yoursite.com/2019/07/22/编译内核用到的图形界面工具/","excerpt":"menuconfig运行在没有桌面环境的主机上，可以查看选项功能，不支持搜索，需要安装终端的图形包。 12$ make menuconfig $ sudo apt-get install libncurses5-dev","text":"menuconfig运行在没有桌面环境的主机上，可以查看选项功能，不支持搜索，需要安装终端的图形包。 12$ make menuconfig $ sudo apt-get install libncurses5-dev xconfig可以查看选项功能，支持搜索功能，需要安装QT依赖包。 12345$ make xconfig$ CHECK qt$ Could not find Qt via pkg-config.$ Please install either Qt 4.8 or 5.x. and make sure it&apos;s in PKG_CONFIG_PATH$ apt-get install qt4-dev-tools 安装后运行如下： gconfig可以查看选项功能，需要安装gtk的包。 123456$ make gconfig$ Unable to find the GTK+ installation. Please make sure that$ the GTK+ 2.0 development package is correctly installed...$ You need gtk+-2.0, glib-2.0 and libglade-2.0.$ sudo apt-get install libgtk2.0-dev libglib2.0-dev libglade2-dev 安装后运行如下：","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/categories/嵌入式/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"kernel","slug":"kernel","permalink":"http://yoursite.com/tags/kernel/"}]},{"title":"使用VScode和Cmake搭建嵌入式开发环境","slug":"使用VScode和Cmake搭建嵌入式开发环境","date":"2019-07-22T09:45:53.000Z","updated":"2019-07-28T12:54:48.694Z","comments":true,"path":"2019/07/22/使用VScode和Cmake搭建嵌入式开发环境/","link":"","permalink":"http://yoursite.com/2019/07/22/使用VScode和Cmake搭建嵌入式开发环境/","excerpt":"配置主机开发环境1) 安装Ubuntu 16.04操作系统，双系统、虚拟机、单系统或windows子系统2) 安装TI SDK并配置交叉编译环境，并配置环境变量3) 安装SecureCRT或者minicom等串口软件，运行secureCRT或者minicom均需要超级权限sudo。4) 配置有线以太网地址（ipv4） 1234Address:192.168.111.101Netmask:255.255.255.0Gateway:192.168.111.1DNS:4.4.4.4","text":"配置主机开发环境1) 安装Ubuntu 16.04操作系统，双系统、虚拟机、单系统或windows子系统2) 安装TI SDK并配置交叉编译环境，并配置环境变量3) 安装SecureCRT或者minicom等串口软件，运行secureCRT或者minicom均需要超级权限sudo。4) 配置有线以太网地址（ipv4） 1234Address:192.168.111.101Netmask:255.255.255.0Gateway:192.168.111.1DNS:4.4.4.4 配置项目工程Linux可以使用许多IDE，甚至可以脱离集成开发环境通过撰写Makefile管理项目文件。 Makefile假设工程文件中包括main.c、spi.c以及head.h，为了生成可执行文件，需要生成main.c和spi.c的链接文件main.o和spi.o，而main.o和spi.o也需要编译生成。这个过程就是makefile的执行过程。以下为Makefile的内容： 12345678910CC=gcc //gcc或者交叉编译gccOBJ=main.o spi.o //OBJ是生成的链接文件目标，作为变量方便main: $(OBJ) //main可执行文件的生成需要OBJ中的两个文件 $(CC) -o $@ $^ // -o表示生成可执行文件 $@表示目标文件（main）；$^表示所有依赖文件（OBJ）spi.o: spi.c head.h $(CC) -c $&lt; // $&lt; 表示第一个依赖文件（spi.c）main.o: main.c head.h $(CC) -c $&lt;clean: //make clean删除通过make指令生成的文件 rm main $(OBJ) VScode + Cmake当项目内容比较多时，可以通过CMake工具自动生成Makefile。Cmake主要配置CMakeLists.txt实现工程管理。推荐通过VScode生成CMake项目模板，过程如下：安装CMake插件；Ctrl+Shift+P，输入CMAKE QUICK START，选择gcc的kit，一般会自己查询到gcc或者交叉编译工具gcc，输入工程名称，再选择生成可执行文件。这样VScode就会生成项目模板。项目主要分为src、include、bin、build等文件夹，文件夹内容如下： 123456789101112|——zhx_cmake_prj #ZHX项目主要软件 |——bin #可执行文件夹目录 |——build #build目录 |——include #头文件目录 |——src #项目源文件 |——driver #设备驱动源文件目录 |——spi |——uart |... |——main.c |——CMakeLists.txt |——CMakeLists.txt CMakeLists主目录下的配置： 12345678cmake_minimum_required (VERSION 3.0.0)SET(CMAKE_C_COMPILER \"/usr/local/arm_gcc/bin/arm-linux-gnueabihf-gcc\") //配置CMAKE GCCSET(CMAKE_CXX_COMPILER \"/usr/local/arm_gcc/bin/arm-linux-gnueabihf-g++\")project(ZHX VERSION 0.1.0)MESSAGE (STATUS \"This is the binary dir: \" $&#123;PROJECT_BINARY_DIR&#125;)MESSAGE (STATUS \"This is the source dir: \" $&#123;PROJECT_SOURCE_DIR&#125;)INCLUDE_DIRECTORIES (include) //添加include路径ADD_SUBDIRECTORY(src) //添加src子目录 二级CMakeLists.txt（src文件夹下）： 123456AUX_SOURCE_DIRECTORY(. SRC_LIST) //添加当前目录为源码编译目录AUX_SOURCE_DIRECTORY(./driver/spi/ SRC_LIST)AUX_SOURCE_DIRECTORY(./driver/i2c/ SRC_LIST)AUX_SOURCE_DIRECTORY(../include/ SRC_LIST) //添加include为源码编译目录ADD_EXECUTABLE(main $&#123;SRC_LIST&#125; ) //通过源码目录中的所有依赖文件生成可执行文件mainSET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin) //将main输出至bin文件夹下 文件编译方式1234$ cd ($PRJ)/build $ cmake .. $ make$ cd ($PRJ)/bin 配置开发板制作SD卡运行$tisdk/bin/creat-sdcard.sh，替换zImage以及设备树文件。 远程登录与传递文件123$ ifconfig eth0 192.168.111.100$ ssh root@192.168.111.100$ scp file root@192.168.111.100:~ 如果显示ssh无法登陆，原因是当前ip地址与开发板的上一次刷的系统配置的ip地址冲突，使用以下命令删除旧的配置： 1$: ssh-keygen –f “/home/usr-name/.ssh/known_hosts” –R “192.168.111.100” 固定目标板的IP地址修改/etc/systemd/network/目录下的10-eth.network文件： 1234567[Match]Name=eth0KernelCommandLine=!root=/dev/nfs[Network]Address=192.168.111.100/24Gateway=192.168.111.1 串口收发文件目标板没有安装ssh时，通过TCP/IP无法传输文件，在文件容量较小的情况下可以使用lrzsz工具。Lrzsz工具解压后使用./configure命令配置makefile，在主机中需要将bin、src以及根目录下的makefile中的CC均改为交叉编译链，再在主目录中make，最后将src/lrz和src/lsz拷贝至目标板的/bin文件夹下。1) 主机向从机发送文件：从机运行lrz，主机选择通过zModem发送，（minicom中通过Ctrl+A-Z-S进入）文件将保存在从机当前目录下；2) 从机向主机发送文件：主机运行lrz（使用主机的gcc编译），从机运行： 1$ lsz file","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/categories/嵌入式/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"vscode","slug":"vscode","permalink":"http://yoursite.com/tags/vscode/"}]},{"title":"ARM Linux开发命令","slug":"ARM Linux开发命令","date":"2019-07-22T09:45:47.000Z","updated":"2019-07-23T07:14:30.268Z","comments":true,"path":"2019/07/22/ARM Linux开发命令/","link":"","permalink":"http://yoursite.com/2019/07/22/ARM Linux开发命令/","excerpt":"使用开发板版本：TI AM5728 EVM使用SDK版本：ti-processor-sdk-linux-rt-am57xx-evm-05.02.00.10官方软件支持：RT-Linux-software官方软件使用说明(更新至6.00.00.07,2019年7月)：TISDKTI中文社区：e2echina.ti创龙论坛：51ele","text":"使用开发板版本：TI AM5728 EVM使用SDK版本：ti-processor-sdk-linux-rt-am57xx-evm-05.02.00.10官方软件支持：RT-Linux-software官方软件使用说明(更新至6.00.00.07,2019年7月)：TISDKTI中文社区：e2echina.ti创龙论坛：51ele 内核编译命令1234make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- tisdk_am57xx-evm-rt_defconfig make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfigmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage -j16make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean 生成的zImage替换/rootfs/boot下的zImage文件。 内核源码内核功能裁剪思路设备树改写命令1make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- am57xx-evm-reva3.dtb -j8 源码位置：$tisdk/arch/arm/boot/dts/am57xx-beagle-x15-common.dtsi等。生成的am57xx-evm-reva3.dtb替换/rootfs/boot下的设备树文件。 编译模块12make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modules -j16sudo make ARCH=arm INSTALL_MOD_PATH=../rootfs modules_install 模块的版本要与内核一致，所以要编译模块。加载模块指令：insmod。卸载模块指令。","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/categories/嵌入式/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"arm","slug":"arm","permalink":"http://yoursite.com/tags/arm/"}]},{"title":"如何利用hexo和github搭建免费个人博客","slug":"如何利用hexo和github搭建免费个人博客","date":"2019-07-19T14:30:53.524Z","updated":"2019-07-23T07:14:20.263Z","comments":true,"path":"2019/07/19/如何利用hexo和github搭建免费个人博客/","link":"","permalink":"http://yoursite.com/2019/07/19/如何利用hexo和github搭建免费个人博客/","excerpt":"文章转载来自使用 Hexo + Github 搭建自己的博客（图文教程）替换主题参考Hexo 安装和替换主题、自定义博客主题","text":"文章转载来自使用 Hexo + Github 搭建自己的博客（图文教程）替换主题参考Hexo 安装和替换主题、自定义博客主题 搭建过程安装git node.js查看版本命令用 12$ npm -v$ node -v 新建仓库新建一个repository，名称为 name.github.io 安装Hexo1234567$ npm install hexo -g$ hexo -v$ hexo init$ npm install$ hexo g$ hexo s #查看本地新建的hexo$ npm install hexo-deployer-git --save 修改_config.yml1234deploy: type: git repository: git@github.com:sjl3110/sjl3110.github.io.git branch: master 建立ssh密钥1ssh-keygen -t rsa -C \"mail@xx.com\" 并将默认保存位置的id_rsa.pub内容存放到github网站中的SSH密钥中。 维护过程12$ hexo new post \"blog-name\"$ hexo d -g","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"基于TCP/IP网络socket通信","slug":"基于TCP-IP网络socket通信","date":"2019-07-19T13:55:15.200Z","updated":"2019-07-23T07:14:14.052Z","comments":true,"path":"2019/07/19/基于TCP-IP网络socket通信/","link":"","permalink":"http://yoursite.com/2019/07/19/基于TCP-IP网络socket通信/","excerpt":"网络传输文件现有的工具为ssh或者tcp指令，ssh中的scp指令如下： 1$ scp file name@IP:file_path 测试在百兆带宽的情况下，可以达到5~6MB/s。SSH的用户层工作原理，除去登陆密码以及公钥或者私钥的建立，底层的工作模式也需要考虑。","text":"网络传输文件现有的工具为ssh或者tcp指令，ssh中的scp指令如下： 1$ scp file name@IP:file_path 测试在百兆带宽的情况下，可以达到5~6MB/s。SSH的用户层工作原理，除去登陆密码以及公钥或者私钥的建立，底层的工作模式也需要考虑。 网络设备驱动网络层次七层又可以分为应用层（应用层、表示层与会话层）、传输层、网络层、数据链路层以及物理层。网络设备驱动负责将数据包写入网络或者从网络中读取数据包，从而完成上层的请求，与其他接口开发的不同是 网络设备不在/dev下创建设备文件； 底层采用中断的工作方式，并将中断传递给上层应用程序（这与UART类似）。 内核配置—&gt; Networking support &gt; Networking options网络功能选择：在内核中配置EtherNet网口支持的功能。 内核选项 含义 Packet socket 支持Socket通信 Unix domain sockets Socket进程间通信 TCP/IP networking TCP/TP网络协议 IP:multicasting 组播，多目标发送 IP:advanced router 高级路由，流量控制 IP:kernel level autoconfiguration 内核启动时自动获取IP IP:DHCP suppo DHCP 获取动态IP协议 IP:BOOTP support DHCP的前身 IP:RARP support 反向地址转换协议 — &gt; Device Drivers &gt; Network device support ─ Ethernet driver support配置芯片驱动：选择对应厂商的芯片，若没有需要写适配的驱动源码！ 设备树配置直接引用dra7.dtsi设备树源文件中的以太网寄存器配置。 12345678&amp;davinci_mdio &#123; phy0: ethernet-phy@1 &#123; reg = &lt;1&gt;; &#125;; phy1: ethernet-phy@2 &#123; reg = &lt;2&gt;; &#125;;&#125;; 传输协议数据传输协议 服务端accept()函数为阻塞函数，主进程执行至accept后进程阻塞，直到客户端发出连接请求； 接收请求后使用fork()函数创建子进程，这样就可以通过不同的子进程连接多个客户端； Send()函数将指定长度数据发送至内存缓冲队列，发送后等待对方确认（客户端确认和服务端重新发送在底层完成）； recv()函数也是阻塞函数，在队列中没有数据时，recv()进程进入阻塞，recv()成功读取则返回读取长度。 文件传输协议 缓冲区长度有限，若客户端不执行recv()则服务端发送一定量的数据包后停止发送； 客户端需要加入文件末尾判断的语句； 若 T1&gt;T2，则recv()函数并不能一次读取设定长度的数据，即有多少读多少，增加了客户端读取循环的次数，降低了传输效率； 测试与改进实际测试：文件长度50160000，约50MB；网络带宽100Mb，上限约12.5MB/s。设每次发送10000Byte，测得：服务端发送5016个数据包，客户端每次接收1000–10000长度不等的包，实际接收了13000个数据包，最终传输速率为2MB/s。改进：每次recv()先与对方确认包的长度，并将内容读满再返回，配置MSG_WAITALL。测试结果：服务端发送5016个数据包，客户端接收了5016个数据包，最终传输速率为10–12MB/s。 配置数据包 在应用层编写实现类似底层包的组帧结构的协议，可以完成多个文件的收发； 由于组包与解包的加入，速度略有牺牲，测试速度约为4~5MB/s。 应用程序服务端 server.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/shm.h&gt;#include &lt;time.h&gt;#define PORT 8888#define QUEUE_SIZE 10#define BUFFER_SIZE 10000//传进来的sockfd，就是互相建立好连接之后的socket文件描述符//通过这个sockfd，可以完成 [服务端]&lt;---&gt;[客户端] 互相收发数据void transfer_file(int sockfd)&#123; FILE *fp; int ch; time_t t_start, t_end; int send_num; long length = 0; //char name[LEN]; // storage for output filename int count = 0; fp = fopen(\"test.txt\", \"r\"); if (fp == NULL) &#123; fprintf(stderr, \"couldn't open the file \\n\"); exit(EXIT_FAILURE); &#125; fseek(fp, 0L, SEEK_END); //将文件指针移到末尾 length = ftell(fp); //获取文件长度 printf(\"%ld\\n\", length); char str[10]; sprintf(str, \"%ld\", length); //将文件长度转换为字符串str send(sockfd, str, sizeof(str), 0); //将文件长度发送给client char buffer1[BUFFER_SIZE]; recv(sockfd, buffer1, sizeof(buffer1), 0); //等待对方读取完长度后返回“ready” if (strcmp(buffer1, \"ready\") == 0) &#123; fseek(fp, 0L, SEEK_SET); //文件指针移到开头 // char buffer[1]; // copy data // while ((ch = getc(fp)) != EOF) // &#123; // buffer[0] = ch; // send(sockfd, buffer, 1, 0); // &#125; t_start = time(NULL); //获取开始时间 char buffer[BUFFER_SIZE]; //新建缓存 send_num = 0; //计算发送包的个数 while (fread(buffer, sizeof(buffer), 1, fp)) //fread 读文件到缓存，读到末尾会EOF（-1） &#123; //printf(\"send%d %ld\\n\",send_num,sizeof(buffer)); send(sockfd, buffer, sizeof(buffer), 0); //发送一个文件包 send_num++; //break; &#125; t_end = time(NULL); //获取结束时间 printf(\"send %d times\\n\", send_num); printf(\"speed: %.02f MB/s\\n\", length / 1024 / 1024 / difftime(t_end, t_start)); if (fclose(fp) != 0) //关闭文件 fprintf(stderr, \"Error in closing files\\n\"); &#125; else &#123; printf(\"cannot get start!\\n\"); &#125;&#125;int str_echo(int sockfd) //回环函数&#123; char buffer[BUFFER_SIZE]; //新建内存缓冲区 pid_t pid = getpid(); while (1) &#123; memset(buffer, 0, sizeof(buffer)); //将内存缓冲区清0，初始化 int len = recv(sockfd, buffer, sizeof(buffer), 0); printf(\"pid:%d receive:\\n\", pid); fputs(buffer, stdout); if (strcmp(buffer, \"exit\\n\") == 0) &#123; printf(\"child process: %d exited.\\n\", pid); printf(\"the server shutdown.\\n\"); break; &#125; if (strcmp(buffer, \"send\\n\") == 0) &#123; printf(\"start transfer.\\n\"); transfer_file(sockfd); printf(\"transfer end.\\n\"); //sleep(10); //printf(\"the server shutdown.\\n\"); continue; &#125; send(sockfd, buffer, len, 0); &#125; close(sockfd); return -1;&#125;int main(int argc, char **argv)&#123; //定义IPV4的TCP连接的套接字描述符 int server_sockfd = socket(AF_INET, SOCK_STREAM, 0); //定义sockaddr_in struct sockaddr_in server_sockaddr; server_sockaddr.sin_family = AF_INET; server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY); server_sockaddr.sin_port = htons(PORT); //bind成功返回0，出错返回-1 if (bind(server_sockfd, (struct sockaddr *)&amp;server_sockaddr, sizeof(server_sockaddr)) == -1) &#123; perror(\"bind\"); exit(1); //1为异常退出 &#125; printf(\"bind success.\\n\"); //listen成功返回0，出错返回-1，允许同时帧听的连接数为QUEUE_SIZE if (listen(server_sockfd, QUEUE_SIZE) == -1) &#123; perror(\"listen\"); exit(1); &#125; printf(\"listen success.\\n\"); for (;;) &#123; struct sockaddr_in client_addr; socklen_t length = sizeof(client_addr); //进程阻塞在accept上，成功返回非负描述字，出错返回-1 int conn = accept(server_sockfd, (struct sockaddr *)&amp;client_addr, &amp;length); if (conn &lt; 0) &#123; perror(\"connect\"); exit(1); &#125; printf(\"new client accepted.\\n\"); pid_t childid; if (childid = fork() == 0) //子进程 &#123; printf(\"child process: %d created.\\n\", getpid()); close(server_sockfd); //在子进程中关闭监听 if (str_echo(conn) &lt; 0) //处理监听的连接 &#123; exit(0); //对方发送exit，返回-1，关闭子进程，主进程继续accep &#125; &#125; &#125; printf(\"closed.\\n\"); close(server_sockfd); printf(\"end\\n\"); exit(0); return 0;&#125; 客户端编译后执行： 12$ ifconfig eth0 192.168.111.101$ ./server 客户端 client.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/shm.h&gt;#include &lt;time.h&gt;#define PORT 8888#define BUFFER_SIZE 10000int main(int argc, char **argv)&#123; if (argc != 2) &#123; printf(\"usage: client IP \\n\"); exit(0); &#125; //定义IPV4的TCP连接的套接字描述符 int sock_cli = socket(AF_INET, SOCK_STREAM, 0); FILE *out; time_t t_start, t_end; long i, receive_length, file_length, length; int receive_num; //定义sockaddr_in struct sockaddr_in servaddr; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = inet_addr(argv[1]); servaddr.sin_port = htons(PORT); //服务器端口 //连接服务器，成功返回0，错误返回-1 if (connect(sock_cli, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) &#123; perror(\"connect\"); exit(1); &#125; printf(\"connect server(IP:%s).\\n\", argv[1]); char sendbuf[BUFFER_SIZE]; char recvbuf[BUFFER_SIZE]; memset(sendbuf, 0, sizeof(sendbuf)); memset(recvbuf, 0, sizeof(recvbuf)); //客户端将控制台输入的信息发送给服务器端，服务器原样返回信息 while (fgets(sendbuf, sizeof(sendbuf), stdin) != NULL) //捕获命令行的字符串到sendbuf &#123; memset(recvbuf, 0, sizeof(recvbuf)); send(sock_cli, sendbuf, strlen(sendbuf), 0); ///发送 if (strcmp(sendbuf, \"exit\\n\") == 0) &#123; printf(\"client exited.\\n\"); break; &#125; if (strcmp(sendbuf, \"send\\n\") == 0) &#123; if ((out = fopen(\"out.txt\", \"w\")) == NULL) &#123; // open file for writing fprintf(stderr, \"Can't create output file.\\n\"); exit(3); &#125; recv(sock_cli, recvbuf, sizeof(recvbuf), 0); file_length = atoi(recvbuf); memset(recvbuf, 0, sizeof(recvbuf)); //获取文件长度 memset(sendbuf, 0, sizeof(sendbuf)); send(sock_cli, \"ready\", 5, 0); //发送就绪 printf(\"receive file start.\\n\"); t_start = time(NULL); length = 0; receive_num = 0; while (length &lt; file_length) &#123; receive_length = recv(sock_cli, recvbuf, sizeof(recvbuf), MSG_WAITALL); ///接收 //MSG_WAITALL是强行等待缓冲满再结束 //sleep(1); //printf(\"%d length %d\\n\", receive_num,receive_length); //fputs(recvbuf, stdout); //printf(\"run dot1\\n\"); //for (i = 0; i &lt; receive_length; i++) //&#123; //putc(recvbuf[i], out); //&#125; fprintf(out, \"%s\", recvbuf); //memset(sendbuf, 0, sizeof(sendbuf)); memset(recvbuf, 0, sizeof(recvbuf)); //printf(\"run\\n\"); length = length + receive_length; receive_num++; //break; &#125; printf(\"receive %d times\\n\", receive_num); if (fclose(out) != 0) fprintf(stderr, \"Error in closing files\\n\"); t_end = time(NULL); printf(\"time : %.2f s\\n\", difftime(t_end, t_start)); printf(\"speed: %.02f MB/s\\n\", file_length / 1024 / 1024 / difftime(t_end, t_start)); printf(\"receive file end.\\n\"); continue; &#125; printf(\"client receive:\\n\"); recv(sock_cli, recvbuf, sizeof(recvbuf), 0); ///接收 fputs(recvbuf, stdout); memset(sendbuf, 0, sizeof(sendbuf)); &#125; close(sock_cli); return 0;&#125; 服务端编译后执行： 12345$ ifconfig eth0 192.168.111.100$ ./client 192.168.111.101$ mesg //对方回环$ send //对方发送文件$ exit //对方关闭服务子进程，客户端退出","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://yoursite.com/categories/嵌入式/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"}]},{"title":"Windows系统配置Linux子系统开发ARM","slug":"Windows系统配置Linux子系统开发ARM","date":"2019-07-19T11:42:09.451Z","updated":"2019-07-23T07:14:34.386Z","comments":true,"path":"2019/07/19/Windows系统配置Linux子系统开发ARM/","link":"","permalink":"http://yoursite.com/2019/07/19/Windows系统配置Linux子系统开发ARM/","excerpt":"Win10可以支持Ubuntu子系统，再也不需要虚拟机！ 安装系统系统要求：最新版win10，打开应用商店安装Ubuntu应用软件，需要系统开启虚拟机功能以及LINUX子系统功能。安装完成后如下：","text":"Win10可以支持Ubuntu子系统，再也不需要虚拟机！ 安装系统系统要求：最新版win10，打开应用商店安装Ubuntu应用软件，需要系统开启虚拟机功能以及LINUX子系统功能。安装完成后如下： 配置 Ubuntu换源等操作。 12345678910111213141516$ cd /etc/apt$ sudo cp sources.list sources.list.bak$ sudo vi sources.list$ add deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse$ sudo apt-get update$ sudo apt-get upgrade 安装 gcc 交叉编译工具命名规则交叉编译工具链的命名规则为：arch [-vendor] [-os] [-(gnu)eabi] arch - 体系架构，如ARM，MIPS vendor - 工具链提供商 os - 目标操作系统 eabi - 嵌入式应用二进制接口（Embedded ApplicationBinary Interface） 根据对操作系统的支持与否，ARM GCC可分为支持和不支持操作系统，如arm-none-eabi：这个是没有操作系统的，自然不可能支持那些跟操作系统关系密切的函数，比如fork()。使用的是newlib这个专用于嵌入式系统的C库。arm-none-linux-eabi：用于Linux的，使用Glibc。比如:arm-none-eabi-gcc：用于编译 ARM 架构的裸机系统（包括 ARM Linux 的 boot、kernel，不适用编译 Linux 应用 Application）。arm-none-linux-gnueabi-gcc：主要用于基于 ARM 架构的 Linux 系统，可用于编译 ARM 架构的 u-boot、Linux内核、Linux应用等。arm-eabi-gcc：Android ARM 编译器。armcc ARM：公司推出的编译工具，功能和 arm-none-eabi 类似。arm-none-uclinuxeabi-gcc：用于uCLinux，使用Glibc。arm-none-symbianelf-gcc：用于symbian。下载链接: gcc-toolchain 123$ tar xvf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf.tar.xz -C /usr/local/arm_gcc$ sudo vim /etc/profile$ export PATH=/usr/local/arm_gcc/bin/:$PATH 安装 Minicom12$ sudo apr-get install minicom$ sudo minicom -D /dev/ttySx 编译代码需要在CMakelists.txt中set gcc和g++路径，其余与Linux正常。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"arm","slug":"arm","permalink":"http://yoursite.com/tags/arm/"}]}]}