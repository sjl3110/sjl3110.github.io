{"meta":{"title":"沈建谅的博客","subtitle":null,"description":"浙江大学","author":"沈建谅","url":"http://yoursite.com","root":"/"},"pages":[{"title":"所有分类","date":"2019-07-20T02:00:55.000Z","updated":"2019-07-20T02:23:25.822Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-07-20T02:28:21.000Z","updated":"2019-07-20T02:28:36.258Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-07-20T01:58:15.000Z","updated":"2019-07-20T02:23:10.772Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"如何利用hexo和github搭建免费个人博客","slug":"hexo-blog","date":"2019-07-19T14:30:53.524Z","updated":"2019-07-20T02:34:32.354Z","comments":true,"path":"2019/07/19/hexo-blog/","link":"","permalink":"http://yoursite.com/2019/07/19/hexo-blog/","excerpt":"","text":"文章转载来自使用 Hexo + Github 搭建自己的博客（图文教程）替换主题参考Hexo 安装和替换主题、自定义博客主题 1.搭建过程1.1 安装git node.js，查看版本命令用12$ npm -v$ node -v 1.2 新建一个repository，名称为 name.github.io1.3 安装Hexo1234567$ npm install hexo -g$ hexo -v$ hexo init$ npm install$ hexo g$ hexo s #查看本地新建的hexo$ npm install hexo-deployer-git --save 1.4 修改_config.yml1234deploy: type: git repository: git@github.com:sjl3110/sjl3110.github.io.git branch: master 1.5 建立ssh密钥1ssh-keygen -t rsa -C \"mail@xx.com\" 并将默认保存位置的id_rsa.pub内容存放到github网站中的SSH密钥中。 2.维护过程12$ hexo new post \"blog-name\"$ hexo d -g","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"基于TCP/IP网络socket通信","slug":"arm-tcp-ip","date":"2019-07-19T13:55:15.200Z","updated":"2019-07-20T02:34:35.673Z","comments":true,"path":"2019/07/19/arm-tcp-ip/","link":"","permalink":"http://yoursite.com/2019/07/19/arm-tcp-ip/","excerpt":"","text":"网络传输文件现有的工具为ssh或者tcp指令，ssh中的scp指令如下： 1$ scp file name@IP:file_path 检测，在百兆带宽的情况下，可以达到5~6MB/s。SSH的用户层工作原理，除去登陆密码以及公钥或者私钥的建立，底层的工作模式也需要考虑。 服务端 server.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/shm.h&gt;#include &lt;time.h&gt;#define PORT 8888#define QUEUE_SIZE 10#define BUFFER_SIZE 10000//传进来的sockfd，就是互相建立好连接之后的socket文件描述符//通过这个sockfd，可以完成 [服务端]&lt;---&gt;[客户端] 互相收发数据void transfer_file(int sockfd)&#123; FILE *fp; int ch; time_t t_start, t_end; int send_num; long length = 0; //char name[LEN]; // storage for output filename int count = 0; fp = fopen(\"test.txt\", \"r\"); if (fp == NULL) &#123; fprintf(stderr, \"couldn't open the file \\n\"); exit(EXIT_FAILURE); &#125; fseek(fp, 0L, SEEK_END); //将文件指针移到末尾 length = ftell(fp); //获取文件长度 printf(\"%ld\\n\", length); char str[10]; sprintf(str, \"%ld\", length); //将文件长度转换为字符串str send(sockfd, str, sizeof(str), 0); //将文件长度发送给client char buffer1[BUFFER_SIZE]; recv(sockfd, buffer1, sizeof(buffer1), 0); //等待对方读取完长度后返回“ready” if (strcmp(buffer1, \"ready\") == 0) &#123; fseek(fp, 0L, SEEK_SET); //文件指针移到开头 // char buffer[1]; // copy data // while ((ch = getc(fp)) != EOF) // &#123; // buffer[0] = ch; // send(sockfd, buffer, 1, 0); // &#125; t_start = time(NULL); //获取开始时间 char buffer[BUFFER_SIZE]; //新建缓存 send_num = 0; //计算发送包的个数 while (fread(buffer, sizeof(buffer), 1, fp)) //fread 读文件到缓存，读到末尾会EOF（-1） &#123; //printf(\"send%d %ld\\n\",send_num,sizeof(buffer)); send(sockfd, buffer, sizeof(buffer), 0); //发送一个文件包 send_num++; //break; &#125; t_end = time(NULL); //获取结束时间 printf(\"send %d times\\n\", send_num); printf(\"speed: %.02f MB/s\\n\", length / 1024 / 1024 / difftime(t_end, t_start)); if (fclose(fp) != 0) //关闭文件 fprintf(stderr, \"Error in closing files\\n\"); &#125; else &#123; printf(\"cannot get start!\\n\"); &#125;&#125;int str_echo(int sockfd) //回环函数&#123; char buffer[BUFFER_SIZE]; //新建内存缓冲区 pid_t pid = getpid(); while (1) &#123; memset(buffer, 0, sizeof(buffer)); //将内存缓冲区清0，初始化 int len = recv(sockfd, buffer, sizeof(buffer), 0); printf(\"pid:%d receive:\\n\", pid); fputs(buffer, stdout); if (strcmp(buffer, \"exit\\n\") == 0) &#123; printf(\"child process: %d exited.\\n\", pid); printf(\"the server shutdown.\\n\"); break; &#125; if (strcmp(buffer, \"send\\n\") == 0) &#123; printf(\"start transfer.\\n\"); transfer_file(sockfd); printf(\"transfer end.\\n\"); //sleep(10); //printf(\"the server shutdown.\\n\"); continue; &#125; send(sockfd, buffer, len, 0); &#125; close(sockfd); return -1;&#125;int main(int argc, char **argv)&#123; //定义IPV4的TCP连接的套接字描述符 int server_sockfd = socket(AF_INET, SOCK_STREAM, 0); //定义sockaddr_in struct sockaddr_in server_sockaddr; server_sockaddr.sin_family = AF_INET; server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY); server_sockaddr.sin_port = htons(PORT); //bind成功返回0，出错返回-1 if (bind(server_sockfd, (struct sockaddr *)&amp;server_sockaddr, sizeof(server_sockaddr)) == -1) &#123; perror(\"bind\"); exit(1); //1为异常退出 &#125; printf(\"bind success.\\n\"); //listen成功返回0，出错返回-1，允许同时帧听的连接数为QUEUE_SIZE if (listen(server_sockfd, QUEUE_SIZE) == -1) &#123; perror(\"listen\"); exit(1); &#125; printf(\"listen success.\\n\"); for (;;) &#123; struct sockaddr_in client_addr; socklen_t length = sizeof(client_addr); //进程阻塞在accept上，成功返回非负描述字，出错返回-1 int conn = accept(server_sockfd, (struct sockaddr *)&amp;client_addr, &amp;length); if (conn &lt; 0) &#123; perror(\"connect\"); exit(1); &#125; printf(\"new client accepted.\\n\"); pid_t childid; if (childid = fork() == 0) //子进程 &#123; printf(\"child process: %d created.\\n\", getpid()); close(server_sockfd); //在子进程中关闭监听 if (str_echo(conn) &lt; 0) //处理监听的连接 &#123; exit(0); //对方发送exit，返回-1，关闭子进程，主进程继续accep &#125; &#125; &#125; printf(\"closed.\\n\"); close(server_sockfd); printf(\"end\\n\"); exit(0); return 0;&#125; 客户端 client.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/shm.h&gt;#include &lt;time.h&gt;#define PORT 8888#define BUFFER_SIZE 10000// void receive_file(int sockfd)// &#123;// FILE *out; // declare two FILE pointers// int ch;// //char name[LEN]; // storage for output filename// int count = 0;// if ((out = fopen(\"out.txt\", \"w\")) == NULL)// &#123; // open file for writing// fprintf(stderr, \"Can't create output file.\\n\");// exit(3);// &#125;// // copy data// while ((ch = getc(in)) != EOF)// putc(ch, out);// // clean up// if (fclose(out) != 0)// fprintf(stderr, \"Error in closing files\\n\");// //chmod(\"test\", S_IXUSR);// &#125;int main(int argc, char **argv)&#123; if (argc != 2) &#123; printf(\"usage: client IP \\n\"); exit(0); &#125; //定义IPV4的TCP连接的套接字描述符 int sock_cli = socket(AF_INET, SOCK_STREAM, 0); FILE *out; time_t t_start, t_end; long i, receive_length, file_length, length; int receive_num; //定义sockaddr_in struct sockaddr_in servaddr; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = inet_addr(argv[1]); servaddr.sin_port = htons(PORT); //服务器端口 //连接服务器，成功返回0，错误返回-1 if (connect(sock_cli, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) &#123; perror(\"connect\"); exit(1); &#125; printf(\"connect server(IP:%s).\\n\", argv[1]); char sendbuf[BUFFER_SIZE]; char recvbuf[BUFFER_SIZE]; memset(sendbuf, 0, sizeof(sendbuf)); memset(recvbuf, 0, sizeof(recvbuf)); //客户端将控制台输入的信息发送给服务器端，服务器原样返回信息 while (fgets(sendbuf, sizeof(sendbuf), stdin) != NULL) //捕获命令行的字符串到sendbuf &#123; memset(recvbuf, 0, sizeof(recvbuf)); send(sock_cli, sendbuf, strlen(sendbuf), 0); ///发送 if (strcmp(sendbuf, \"exit\\n\") == 0) &#123; printf(\"client exited.\\n\"); break; &#125; if (strcmp(sendbuf, \"send\\n\") == 0) &#123; if ((out = fopen(\"out.txt\", \"w\")) == NULL) &#123; // open file for writing fprintf(stderr, \"Can't create output file.\\n\"); exit(3); &#125; recv(sock_cli, recvbuf, sizeof(recvbuf), 0); file_length = atoi(recvbuf); memset(recvbuf, 0, sizeof(recvbuf)); //获取文件长度 memset(sendbuf, 0, sizeof(sendbuf)); send(sock_cli, \"ready\", 5, 0); //发送就绪 printf(\"receive file start.\\n\"); t_start = time(NULL); length = 0; receive_num = 0; while (length &lt; file_length) &#123; receive_length = recv(sock_cli, recvbuf, sizeof(recvbuf), MSG_WAITALL); ///接收 //MSG_WAITALL是强行等待缓冲满再结束 //sleep(1); //printf(\"%d length %d\\n\", receive_num,receive_length); //fputs(recvbuf, stdout); //printf(\"run dot1\\n\"); //for (i = 0; i &lt; receive_length; i++) //&#123; //putc(recvbuf[i], out); //&#125; fprintf(out, \"%s\", recvbuf); //memset(sendbuf, 0, sizeof(sendbuf)); memset(recvbuf, 0, sizeof(recvbuf)); //printf(\"run\\n\"); length = length + receive_length; receive_num++; //break; &#125; printf(\"receive %d times\\n\", receive_num); if (fclose(out) != 0) fprintf(stderr, \"Error in closing files\\n\"); t_end = time(NULL); printf(\"time : %.2f s\\n\", difftime(t_end, t_start)); printf(\"speed: %.02f MB/s\\n\", file_length / 1024 / 1024 / difftime(t_end, t_start)); printf(\"receive file end.\\n\"); continue; &#125; printf(\"client receive:\\n\"); recv(sock_cli, recvbuf, sizeof(recvbuf), 0); ///接收 fputs(recvbuf, stdout); memset(sendbuf, 0, sizeof(sendbuf)); &#125; close(sock_cli); return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"}]},{"title":"Windows系统配置Linux子系统开发ARM","slug":"windows_wsl","date":"2019-07-19T11:42:09.451Z","updated":"2019-07-20T02:35:04.872Z","comments":true,"path":"2019/07/19/windows_wsl/","link":"","permalink":"http://yoursite.com/2019/07/19/windows_wsl/","excerpt":"","text":"Win10可以支持Ubuntu子系统，再也不需要虚拟机！ 安装系统系统要求：最新版win10，打开应用商店安装Ubuntu应用软件，需要系统开启虚拟机功能以及LINUX子系统功能。 1.配置 Ubuntu换源等操作 12345678910111213141516$ cd /etc/apt$ sudo cp sources.list sources.list.bak$ sudo vi sources.list$ add deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse$ sudo apt-get update$ sudo apt-get upgrade 2.安装 gcc 交叉编译工具命名规则 交叉编译工具链的命名规则为：arch [-vendor] [-os] [-(gnu)eabi] arch - 体系架构，如ARM，MIPS vendor - 工具链提供商 os - 目标操作系统 eabi - 嵌入式应用二进制接口（Embedded ApplicationBinary Interface）根据对操作系统的支持与否，ARM GCC可分为支持和不支持操作系统，如arm-none-eabi：这个是没有操作系统的，自然不可能支持那些跟操作系统关系密切的函数，比如fork()。使用的是newlib这个专用于嵌入式系统的C库。arm-none-linux-eabi：用于Linux的，使用Glibc。比如:arm-none-eabi-gcc：用于编译 ARM 架构的裸机系统（包括 ARM Linux 的 boot、kernel，不适用编译 Linux 应用 Application）。arm-none-linux-gnueabi-gcc：主要用于基于 ARM 架构的 Linux 系统，可用于编译 ARM 架构的 u-boot、Linux内核、Linux应用等。arm-eabi-gcc：Android ARM 编译器。armcc ARM：公司推出的编译工具，功能和 arm-none-eabi 类似。arm-none-uclinuxeabi-gcc：用于uCLinux，使用Glibc。arm-none-symbianelf-gcc：用于symbian。下载链接: gcc-toolchain123$ tar xvf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf.tar.xz -C /usr/local/arm_gcc$ sudo vim /etc/profile$ export PATH=/usr/local/arm_gcc/bin/:$PATH 安装完成后如下： 3.安装 Minicom12$ sudo apr-get install minicom$ sudo minicom -D /dev/ttySx 4.编译代码需要在CMakelists.txt中set gcc和g++路径，其余与Linux正常。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"arm","slug":"arm","permalink":"http://yoursite.com/tags/arm/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]}]}