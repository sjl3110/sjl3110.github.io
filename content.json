{"meta":{"title":"个人博客","subtitle":"记录点滴，分享生活","description":"浙江大学航空航天学院","author":"沈建谅","url":"http://yoursite.com","root":"/"},"pages":[{"title":"所有标签","date":"2019-07-20T01:58:15.000Z","updated":"2019-07-20T02:23:10.772Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-07-20T02:28:21.000Z","updated":"2019-07-20T04:19:36.402Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"联系方式电话：15895898063地址：浙江杭州邮箱：jianliang_shen@zju.edu.cnGitHub: “https://github.com/sjl3110&quot;"},{"title":"所有分类","date":"2019-07-20T02:00:55.000Z","updated":"2019-07-20T02:23:25.822Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"初中","slug":"middle-high-school","date":"2019-07-20T04:52:37.000Z","updated":"2019-07-20T05:44:34.687Z","comments":true,"path":"2019/07/20/middle-high-school/","link":"","permalink":"http://yoursite.com/2019/07/20/middle-high-school/","excerpt":"","text":"初识镇中&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果让我选择一段可以回溯的时光，我一定选择初中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;08年的五月，我妈一边犹豫着该不该让我尝试报考市一中，我一边漫不经心地看着自己偷偷买的奥林匹克竞赛培训书，希望能在小升初的数学试卷上多拿几分。之后我跟小伙伴去市里考试，第一次见到市二小如此宽敞明亮的教室，我暗自给自己定下目标，我有机会一定要去市里读书！考试的时候依旧死在语文上，至今依稀记得，陈毅的毅字不会写，考完后问同学还被鄙视。数学考试我带上了计算器，但因为老师检查桌肚颇为严厉，吓得我上厕所时藏到卫生间水池下面去了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;放榜那天，得知并不带我一起去一中看，心里扬起的一丝期待变成泡影，把穿的新凉鞋甩一边，接着去玩“泥巴”去了。有个一直看我不顺眼的邻居非常不屑，大概这样的玩物丧志的孩童不配他们眼里的第一中学。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我妈兴冲冲地跟我说我考上了，200分考到了140多，还说哪怕在我读的小学中参考的学生中也颇为优秀。这种事发生在那种环境下的“我”身上，恨不得路人皆知。然而事情并没有想象中的那么顺利，我妈咨询了之后才知道，乡镇的学生学费是很贵的，我妈又不愿意让我住校，如果搬到市里生活开销也比较大，我妈一考虑也就放弃了，尽管当时班主任力劝去市里读书，尽管这人得知我也能考上后表示十分不可思议，回头我再专门写一篇文章说说小学班主任陈井国。那个邻居得知后，大概是过程出乎了意料，但结局他觉得比较满意，换做我如果如此势利，我就会说“就说嘛，考上了也上不了”。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小学毕业考试完了，我妈带着我去镇中报道，又给我借来几本初一的教材，我把语文教材里有趣的文章翻来覆去看了好几遍，像《比萨斜塔》这类的文章，讲伽利略生平的尤其喜欢，现在想来，我的确不适合学语文。当时自己学了点初等数学里的负数、绝对值等简单内容，我觉得太简单了没有丝毫难度可言。至于英语，当时还有预备教材，暑假里我妈让我去了镇里精神病院后面破落的学校里面补习班上课，那英语老师的发音，大概是我听过的最难听的几位老师之一了。我记得还向他扔粉笔头被逮到过，他问我为啥上课不听讲，我直言你讲课发音太难听，那老师竟然还承认了，意思没办法混口饭，我当时不知道那位年轻的老师为何跟我这种小屁孩说这种话，现在想想，这大概就是生活所迫吧。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;真正开学后，我对新学校是非常地失望。尘土飞扬的操场，一到下雨简直跟个化粪池一般的泥泞，给我双破鞋我都舍不得下脚。更不提那低矮的教学楼，初一是平房，初二是二层破楼房，初三的教学楼地砖磨得可以给大姑娘拿去化妆了。拥挤的教师，残破的桌椅，头上的吊扇时常让人担心什么时候它转着掉下来导致生灵涂炭，教室门口的台阶露出里面砖头的棱角，旁边的花坛杂草丛生，甚至曾有学生被蛇咬过。我当时十分向往的市一中南校区塑胶跑道，连绵的洋红色教学楼全成了白日梦！哦对了，还有那难吃的食堂，韭菜炒蛋都是臭的！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么我要上这样的学校！","categories":[{"name":"回忆","slug":"回忆","permalink":"http://yoursite.com/categories/回忆/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"如何利用hexo和github搭建免费个人博客","slug":"hexo-blog","date":"2019-07-19T14:30:53.524Z","updated":"2019-07-20T04:23:18.705Z","comments":true,"path":"2019/07/19/hexo-blog/","link":"","permalink":"http://yoursite.com/2019/07/19/hexo-blog/","excerpt":"文章转载来自使用 Hexo + Github 搭建自己的博客（图文教程）替换主题参考Hexo 安装和替换主题、自定义博客主题","text":"文章转载来自使用 Hexo + Github 搭建自己的博客（图文教程）替换主题参考Hexo 安装和替换主题、自定义博客主题 1.搭建过程1.1 安装git node.js查看版本命令用 12$ npm -v$ node -v 1.2 新建仓库新建一个repository，名称为 name.github.io 1.3 安装Hexo1234567$ npm install hexo -g$ hexo -v$ hexo init$ npm install$ hexo g$ hexo s #查看本地新建的hexo$ npm install hexo-deployer-git --save 1.4 修改_config.yml1234deploy: type: git repository: git@github.com:sjl3110/sjl3110.github.io.git branch: master 1.5 建立ssh密钥1ssh-keygen -t rsa -C \"mail@xx.com\" 并将默认保存位置的id_rsa.pub内容存放到github网站中的SSH密钥中。 2.维护过程12$ hexo new post \"blog-name\"$ hexo d -g","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"基于TCP/IP网络socket通信","slug":"arm-tcp-ip","date":"2019-07-19T13:55:15.200Z","updated":"2019-07-20T04:28:24.606Z","comments":true,"path":"2019/07/19/arm-tcp-ip/","link":"","permalink":"http://yoursite.com/2019/07/19/arm-tcp-ip/","excerpt":"网络传输文件现有的工具为ssh或者tcp指令，ssh中的scp指令如下： 1$ scp file name@IP:file_path 检测，在百兆带宽的情况下，可以达到5~6MB/s。SSH的用户层工作原理，除去登陆密码以及公钥或者私钥的建立，底层的工作模式也需要考虑。","text":"网络传输文件现有的工具为ssh或者tcp指令，ssh中的scp指令如下： 1$ scp file name@IP:file_path 检测，在百兆带宽的情况下，可以达到5~6MB/s。SSH的用户层工作原理，除去登陆密码以及公钥或者私钥的建立，底层的工作模式也需要考虑。 1.服务端 server.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/shm.h&gt;#include &lt;time.h&gt;#define PORT 8888#define QUEUE_SIZE 10#define BUFFER_SIZE 10000//传进来的sockfd，就是互相建立好连接之后的socket文件描述符//通过这个sockfd，可以完成 [服务端]&lt;---&gt;[客户端] 互相收发数据void transfer_file(int sockfd)&#123; FILE *fp; int ch; time_t t_start, t_end; int send_num; long length = 0; //char name[LEN]; // storage for output filename int count = 0; fp = fopen(\"test.txt\", \"r\"); if (fp == NULL) &#123; fprintf(stderr, \"couldn't open the file \\n\"); exit(EXIT_FAILURE); &#125; fseek(fp, 0L, SEEK_END); //将文件指针移到末尾 length = ftell(fp); //获取文件长度 printf(\"%ld\\n\", length); char str[10]; sprintf(str, \"%ld\", length); //将文件长度转换为字符串str send(sockfd, str, sizeof(str), 0); //将文件长度发送给client char buffer1[BUFFER_SIZE]; recv(sockfd, buffer1, sizeof(buffer1), 0); //等待对方读取完长度后返回“ready” if (strcmp(buffer1, \"ready\") == 0) &#123; fseek(fp, 0L, SEEK_SET); //文件指针移到开头 // char buffer[1]; // copy data // while ((ch = getc(fp)) != EOF) // &#123; // buffer[0] = ch; // send(sockfd, buffer, 1, 0); // &#125; t_start = time(NULL); //获取开始时间 char buffer[BUFFER_SIZE]; //新建缓存 send_num = 0; //计算发送包的个数 while (fread(buffer, sizeof(buffer), 1, fp)) //fread 读文件到缓存，读到末尾会EOF（-1） &#123; //printf(\"send%d %ld\\n\",send_num,sizeof(buffer)); send(sockfd, buffer, sizeof(buffer), 0); //发送一个文件包 send_num++; //break; &#125; t_end = time(NULL); //获取结束时间 printf(\"send %d times\\n\", send_num); printf(\"speed: %.02f MB/s\\n\", length / 1024 / 1024 / difftime(t_end, t_start)); if (fclose(fp) != 0) //关闭文件 fprintf(stderr, \"Error in closing files\\n\"); &#125; else &#123; printf(\"cannot get start!\\n\"); &#125;&#125;int str_echo(int sockfd) //回环函数&#123; char buffer[BUFFER_SIZE]; //新建内存缓冲区 pid_t pid = getpid(); while (1) &#123; memset(buffer, 0, sizeof(buffer)); //将内存缓冲区清0，初始化 int len = recv(sockfd, buffer, sizeof(buffer), 0); printf(\"pid:%d receive:\\n\", pid); fputs(buffer, stdout); if (strcmp(buffer, \"exit\\n\") == 0) &#123; printf(\"child process: %d exited.\\n\", pid); printf(\"the server shutdown.\\n\"); break; &#125; if (strcmp(buffer, \"send\\n\") == 0) &#123; printf(\"start transfer.\\n\"); transfer_file(sockfd); printf(\"transfer end.\\n\"); //sleep(10); //printf(\"the server shutdown.\\n\"); continue; &#125; send(sockfd, buffer, len, 0); &#125; close(sockfd); return -1;&#125;int main(int argc, char **argv)&#123; //定义IPV4的TCP连接的套接字描述符 int server_sockfd = socket(AF_INET, SOCK_STREAM, 0); //定义sockaddr_in struct sockaddr_in server_sockaddr; server_sockaddr.sin_family = AF_INET; server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY); server_sockaddr.sin_port = htons(PORT); //bind成功返回0，出错返回-1 if (bind(server_sockfd, (struct sockaddr *)&amp;server_sockaddr, sizeof(server_sockaddr)) == -1) &#123; perror(\"bind\"); exit(1); //1为异常退出 &#125; printf(\"bind success.\\n\"); //listen成功返回0，出错返回-1，允许同时帧听的连接数为QUEUE_SIZE if (listen(server_sockfd, QUEUE_SIZE) == -1) &#123; perror(\"listen\"); exit(1); &#125; printf(\"listen success.\\n\"); for (;;) &#123; struct sockaddr_in client_addr; socklen_t length = sizeof(client_addr); //进程阻塞在accept上，成功返回非负描述字，出错返回-1 int conn = accept(server_sockfd, (struct sockaddr *)&amp;client_addr, &amp;length); if (conn &lt; 0) &#123; perror(\"connect\"); exit(1); &#125; printf(\"new client accepted.\\n\"); pid_t childid; if (childid = fork() == 0) //子进程 &#123; printf(\"child process: %d created.\\n\", getpid()); close(server_sockfd); //在子进程中关闭监听 if (str_echo(conn) &lt; 0) //处理监听的连接 &#123; exit(0); //对方发送exit，返回-1，关闭子进程，主进程继续accep &#125; &#125; &#125; printf(\"closed.\\n\"); close(server_sockfd); printf(\"end\\n\"); exit(0); return 0;&#125; 2.客户端 client.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/shm.h&gt;#include &lt;time.h&gt;#define PORT 8888#define BUFFER_SIZE 10000// void receive_file(int sockfd)// &#123;// FILE *out; // declare two FILE pointers// int ch;// //char name[LEN]; // storage for output filename// int count = 0;// if ((out = fopen(\"out.txt\", \"w\")) == NULL)// &#123; // open file for writing// fprintf(stderr, \"Can't create output file.\\n\");// exit(3);// &#125;// // copy data// while ((ch = getc(in)) != EOF)// putc(ch, out);// // clean up// if (fclose(out) != 0)// fprintf(stderr, \"Error in closing files\\n\");// //chmod(\"test\", S_IXUSR);// &#125;int main(int argc, char **argv)&#123; if (argc != 2) &#123; printf(\"usage: client IP \\n\"); exit(0); &#125; //定义IPV4的TCP连接的套接字描述符 int sock_cli = socket(AF_INET, SOCK_STREAM, 0); FILE *out; time_t t_start, t_end; long i, receive_length, file_length, length; int receive_num; //定义sockaddr_in struct sockaddr_in servaddr; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = inet_addr(argv[1]); servaddr.sin_port = htons(PORT); //服务器端口 //连接服务器，成功返回0，错误返回-1 if (connect(sock_cli, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) &#123; perror(\"connect\"); exit(1); &#125; printf(\"connect server(IP:%s).\\n\", argv[1]); char sendbuf[BUFFER_SIZE]; char recvbuf[BUFFER_SIZE]; memset(sendbuf, 0, sizeof(sendbuf)); memset(recvbuf, 0, sizeof(recvbuf)); //客户端将控制台输入的信息发送给服务器端，服务器原样返回信息 while (fgets(sendbuf, sizeof(sendbuf), stdin) != NULL) //捕获命令行的字符串到sendbuf &#123; memset(recvbuf, 0, sizeof(recvbuf)); send(sock_cli, sendbuf, strlen(sendbuf), 0); ///发送 if (strcmp(sendbuf, \"exit\\n\") == 0) &#123; printf(\"client exited.\\n\"); break; &#125; if (strcmp(sendbuf, \"send\\n\") == 0) &#123; if ((out = fopen(\"out.txt\", \"w\")) == NULL) &#123; // open file for writing fprintf(stderr, \"Can't create output file.\\n\"); exit(3); &#125; recv(sock_cli, recvbuf, sizeof(recvbuf), 0); file_length = atoi(recvbuf); memset(recvbuf, 0, sizeof(recvbuf)); //获取文件长度 memset(sendbuf, 0, sizeof(sendbuf)); send(sock_cli, \"ready\", 5, 0); //发送就绪 printf(\"receive file start.\\n\"); t_start = time(NULL); length = 0; receive_num = 0; while (length &lt; file_length) &#123; receive_length = recv(sock_cli, recvbuf, sizeof(recvbuf), MSG_WAITALL); ///接收 //MSG_WAITALL是强行等待缓冲满再结束 //sleep(1); //printf(\"%d length %d\\n\", receive_num,receive_length); //fputs(recvbuf, stdout); //printf(\"run dot1\\n\"); //for (i = 0; i &lt; receive_length; i++) //&#123; //putc(recvbuf[i], out); //&#125; fprintf(out, \"%s\", recvbuf); //memset(sendbuf, 0, sizeof(sendbuf)); memset(recvbuf, 0, sizeof(recvbuf)); //printf(\"run\\n\"); length = length + receive_length; receive_num++; //break; &#125; printf(\"receive %d times\\n\", receive_num); if (fclose(out) != 0) fprintf(stderr, \"Error in closing files\\n\"); t_end = time(NULL); printf(\"time : %.2f s\\n\", difftime(t_end, t_start)); printf(\"speed: %.02f MB/s\\n\", file_length / 1024 / 1024 / difftime(t_end, t_start)); printf(\"receive file end.\\n\"); continue; &#125; printf(\"client receive:\\n\"); recv(sock_cli, recvbuf, sizeof(recvbuf), 0); ///接收 fputs(recvbuf, stdout); memset(sendbuf, 0, sizeof(sendbuf)); &#125; close(sock_cli); return 0;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"}]},{"title":"Windows系统配置Linux子系统开发ARM","slug":"windows_wsl","date":"2019-07-19T11:42:09.451Z","updated":"2019-07-20T04:27:53.128Z","comments":true,"path":"2019/07/19/windows_wsl/","link":"","permalink":"http://yoursite.com/2019/07/19/windows_wsl/","excerpt":"Win10可以支持Ubuntu子系统，再也不需要虚拟机！ 安装系统系统要求：最新版win10，打开应用商店安装Ubuntu应用软件，需要系统开启虚拟机功能以及LINUX子系统功能。安装完成后如下：","text":"Win10可以支持Ubuntu子系统，再也不需要虚拟机！ 安装系统系统要求：最新版win10，打开应用商店安装Ubuntu应用软件，需要系统开启虚拟机功能以及LINUX子系统功能。安装完成后如下： 1.配置 Ubuntu换源等操作。 12345678910111213141516$ cd /etc/apt$ sudo cp sources.list sources.list.bak$ sudo vi sources.list$ add deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse$ sudo apt-get update$ sudo apt-get upgrade 2.安装 gcc 交叉编译工具命名规则交叉编译工具链的命名规则为：arch [-vendor] [-os] [-(gnu)eabi] arch - 体系架构，如ARM，MIPS vendor - 工具链提供商 os - 目标操作系统 eabi - 嵌入式应用二进制接口（Embedded ApplicationBinary Interface） 根据对操作系统的支持与否，ARM GCC可分为支持和不支持操作系统，如arm-none-eabi：这个是没有操作系统的，自然不可能支持那些跟操作系统关系密切的函数，比如fork()。使用的是newlib这个专用于嵌入式系统的C库。arm-none-linux-eabi：用于Linux的，使用Glibc。比如:arm-none-eabi-gcc：用于编译 ARM 架构的裸机系统（包括 ARM Linux 的 boot、kernel，不适用编译 Linux 应用 Application）。arm-none-linux-gnueabi-gcc：主要用于基于 ARM 架构的 Linux 系统，可用于编译 ARM 架构的 u-boot、Linux内核、Linux应用等。arm-eabi-gcc：Android ARM 编译器。armcc ARM：公司推出的编译工具，功能和 arm-none-eabi 类似。arm-none-uclinuxeabi-gcc：用于uCLinux，使用Glibc。arm-none-symbianelf-gcc：用于symbian。下载链接: gcc-toolchain 123$ tar xvf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf.tar.xz -C /usr/local/arm_gcc$ sudo vim /etc/profile$ export PATH=/usr/local/arm_gcc/bin/:$PATH 3.安装 Minicom12$ sudo apr-get install minicom$ sudo minicom -D /dev/ttySx 4.编译代码需要在CMakelists.txt中set gcc和g++路径，其余与Linux正常。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"arm","slug":"arm","permalink":"http://yoursite.com/tags/arm/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]}]}