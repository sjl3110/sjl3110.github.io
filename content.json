[{"title":"linux内核配置--Device drivers","date":"2020-05-25T05:20:57.000Z","path":"2020/05/25/linux内核配置-Device-drivers/","content":"<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核的配置过程依赖Makefile和arch/arm/Kconfig以及其他文件下的Kconfig文件，通过make menuconfig或者桌面环境下的xconfig/gconfig可以手动配置内核所支持的功能。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下为Device drivers启动设置的配置。  </p>\n<a id=\"more\"></a>  \n<details>\n<summary>Generic Driver Options ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/base/Kconfig  </p>\n<ul>\n<li><code>[Y] Support for uevent helper</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支持uevent（例如热插拔）事件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;早年的内核(切换到基于netlink机制之前),在发生uevent事件(通常是热插拔)时,需要调用用户空间程序(通常是”/sbin/hotplug”),以帮助完成uevent事件的处理.此选项就是用于开启此功能.由于目前的发行版都已不再需要此帮助程序,所以请选”N”.此外,如果你使用了systemd或udev则必须选”N”.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The uevent helper program is forked by the kernel for every uevent. Before the switch to the netlink-based uevent source, this was used to hook hotplug scripts into kernel device events. It usually pointed to a shell script at /sbin/hotplug. This should not be used today, because usual systems create many events at bootup or device discovery in a very short time frame. One forked process per event can create so many processes that it creates a high system load, or on smaller systems it is known to create out-of-memory situations during bootup.  <ul>\n<li><code>( ) path to uevent helper</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To disable user space helper program execution at by default specify an empty string here. This setting can still be altered via /proc/sys/kernel/hotplug or via /sys/kernel/uevent_helper later at runtime.  </li>\n</ul>\n</li>\n<li><code>[Y] Maintain a devtmpfs filesystem to mount at /dev</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在系统/dev文件夹下挂载devtmpf文件系统。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devtmpfs是一种基于CONFIG_TMPFS的文件系统(与proc和sys有几分相似).在系统启动过程中,随着各个设备的初始化完成,内核将会自动在devtmpfs中创建相应的设备节点(使用默认的文件名和权限)并赋予正确的主次设备号.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This creates a tmpfs/ramfs filesystem instance early at bootup. In this filesystem, the kernel driver core maintains device nodes with their default names and permissions for all registered devices with an assigned major/minor number. Userspace can modify the filesystem content as needed, add  symlinks, and apply needed permissions.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It provides a fully functional /dev directory, where usually udev runs on top, managing permissions and adding meaningful symlinks.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In very limited environments, it may provide a sufficient functional /dev without any further help. It also allows simple rescue systems, and reliably handles dynamic major/minor numbers.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Notice: if CONFIG_TMPFS isn’t enabled, the simpler ramfs file system will be used instead.  <ul>\n<li><code>[Y] Automount devtmpfs at /dev, after the kernel mounted the rootfs</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在内核挂载根文件系统的同时，立即自动将devtmpfs挂载到”/dev”目录。因为此时init进程都还尚未启动，所以这就确保在进入用户空间之前，所有设备文件就都已经准备完毕.开启此选项相当于设置内核引导参数”devtmpfs.mount=1”，关闭此选项相当于设置内核引导参数”devtmpfs.mount=0”。开启此项后,你就可以放心的使用”init=/bin/sh”直接进入救援模式，而不必担心”/dev”目录空无一物。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意:此选项并不影响基于initramfs的启动，此种情况下，devtmpfs必须被手动挂载.所以,如果你的系统使用initrd或者有专门的启动脚本用于挂载”/dev”目录(大多数发行版都有这样的脚本)，或者你看了前面的解释，还是不确定，那就选”N”.对于实在想要使用”init=/bin/sh”直接进入救援模式的人来说，还是使用”init=/bin/sh devtmpfs.mount=1”吧!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This will instruct the kernel to automatically mount the devtmpfs filesystem at /dev, directly after the kernel has mounted the root filesystem. The behavior can be overridden with the commandline parameter: devtmpfs.mount=0|1. This option does not affect initramfs based booting, here the devtmpfs filesystem always needs to be mounted manually after the rootfs is mounted.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;With this option enabled, it allows to bring up a system in rescue mode with init=/bin/sh, even when the /dev directory on the rootfs is completely empty.  </li>\n</ul>\n</li>\n<li><code>[Y] Select only drivers that don&#39;t need compile-time external firmware</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只显示那些编译时不需要额外固件支持的驱动程序，除非你有某些怪异硬件，否则请选”Y”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select this option if you don’t have magic firmware for drivers that need it. If unsure, say Y.  </li>\n<li><code>[Y] Prevent firmware from being built</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不编译固件(firmware)。固件一般是随硬件的驱动程序提供的，仅在更新固件的时候才需要重新编译。建议选”Y”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say yes to avoid building firmware. Firmware is usually shipped with the driver and only when updating the firmware should a rebuild be made. If unsure, say Y here.  </li>\n<li><code>{Y} Userspace firmware loading support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户空间固件加载支持。如果内核自带的模块需要它，它将会被自动选中。但某些内核树之外的模块也可能需要它，这时候就需要你根据实际情况手动开启了.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option is provided for the case where none of the in-tree modules require userspace firmware loading support, but a module built out-of-tree does.  <ul>\n<li><code>[Y] Include in-kernel firmware blobs in kernel binary</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核源码树中包含了许多驱动程序需要的二进制固件(blob),推荐的方法是通过”make firmware_install”将”firmware”目录中所需的固件复制到系统的”/lib/firmware/“目录中,然后由用户空间帮助程序在需要的时候进行加载.开启此项后,将会把所需的”blob”直接编译进内核,这样就可以无需用户空间程序的帮助,而直接使用这些固件了(例如:当根文件系统依赖于此类固件,而你又不想使用initrd的时候).每个需要此类二进制固件的驱动程序,都会有一个”Include firmware for xxx device”的选项,如果此处选”Y”,那么这些选项都将被隐藏.建议选”N”.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Various drivers in the kernel source tree may require firmware, which is generally available in your distribution’s linux-firmware package.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The linux-firmware package should install firmware into /lib/firmware/ on your system, so they can be loaded by userspace helpers on request.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enabling this option will build each required firmware blob specified by EXTRA_FIRMWARE into the kernel directly, where request_firmware() will find them without having to call out to userspace. This may be useful if your root file system requires a device that uses such firmware and you do not wish to use an initrd.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This single option controls the inclusion of firmware for every driver that uses request_firmware(), which avoids a proliferation of ‘Include firmware for xxx device’ options.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say ‘N’ and let firmware be loaded from userspace.    </li>\n<li><code>( ) External firmware blobs to build into the kernel binary</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定要额外编译进内核的二进制固件(blob).此选项的值是一个空格分隔的固件文件名字符串,这些文件必须位于CONFIG_EXTRA_FIRMWARE_DIR目录中(其默认值是内核源码树下的”firmware”目录).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option allows firmware to be built into the kernel for the case where the user either cannot or doesn’t want to provide it from userspace at runtime (for example, when the firmware in question is required for accessing the boot device, and the user doesn’t want to use an initrd).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option is a string and takes the (space-separated) names of the firmware files – the same names that appear in MODULE_FIRMWARE() and request_firmware() in the source. These files should exist under the directory specified by the EXTRA_FIRMWARE_DIR option, which is by default the firmware subdirectory of the kernel source tree.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For example, you might set CONFIG_EXTRA_FIRMWARE=”usb8388.bin”, copy the usb8388.bin file into the firmware directory, and build the kernel. Then any request_firmware(“usb8388.bin”) will be satisfied internally without needing to call out to userspace.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WARNING: If you include additional firmware files into your binary kernel image that are not available under the terms of the GPL, then it may be a violation of the GPL to distribute the resulting image since it combines both GPL and non-GPL work. You should consult a lawyer of your own before distributing such an image.  </li>\n</ul>\n</li>\n<li><code>[N] Fallback user-helper invocation for firmware loading</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在内核自己直接加载固件失败后,作为补救措施,调用用户空间帮助程序(通常是udev)再次尝试加载.通常这个动作是不必要的,因此应该选”N”,如果你使用了udev或systemd,则必须选”N”.仅在某些特殊的固件位于非标准位置时,才需要选”Y”.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option enables / disables the invocation of user-helper (e.g. udev) for loading firmware files as a fallback after the direct file loading in kernel fails.  The user-mode helper is no longer required unless you have a special firmware file that resides in a non-standard path. Moreover, the udev support has been deprecated upstream.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you are unsure about this, say N here.  </li>\n<li><code>[Y] Allow device coredump</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为驱动程序开启core dump机制,仅供调试.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;核心转储（core dump），是操作系统在进程收到某些信号而终止运行时，将此时进程地址空间的内容以及有关进程状态的其他信息写出的一个磁盘文件，这种信息往往用于调试，可以用gdb来调试。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option controls if the device coredump mechanism is available or not; if disabled, the mechanism will be omitted even if drivers that can use it are enabled.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say ‘N’ for more sensitive systems or systems that don’t want to ever access the information to not have the code, nor keep any data.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say Y.  </li>\n<li><code>[N] Driver Core verbose debug messages</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让驱动程序核心在系统日志中产生冗长的调试信息,仅供调试<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here if you want the Driver core to produce a bunch of debug messages to the system log. Select this if you are having a problem with the driver core and want to see more of what is going on.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you are unsure about this, say N here.  </li>\n<li><code>[N] Managed device resources verbose debug messages</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为内核添加一个”devres.log”引导参数.当被设为非零值时,将会打印出设备资源管理驱动(devres)的调试信息.仅供调试使用.推荐设置为N。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option enables kernel parameter devres.log. If set to non-zero, devres debug messages are printed. Select this if you are having a problem with devres or want to debug resource management for a managed device. devres.log can be switched on and off from sysfs node.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you are unsure about this, Say N here.  </li>\n<li><code>[N] Test driver remove calls during probe (UNSTABLE)</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here if you want the Driver core to test driver remove functions by calling probe, remove, probe. This tests the remove path without having to unbind the driver or unload the driver module.  This option is expected to find errors and may render your system unusable. You should say N here unless you are explicitly looking to test this functionality.  </li>\n<li><code>&lt;N&gt; Build kernel module to test asynchronous driver probing</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enabling this option produces a kernel module that allows testing asynchronous driver probing by the device core. The module name will be test_async_driver_probe.ko<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure say N.  </li>\n<li><code>[N] Enable verbose DMA_FENCE_TRACE messages</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable the DMA_FENCE_TRACE printks. This will add extra spam to the console log, but will make it easier to diagnose lockup related problems for dma-buffers shared across multiple devices.  </li>\n<li><code>[Y] DMA Contiguous Memory Allocator</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This enables the Contiguous Memory Allocator which allows drivers to allocate big physically-contiguous blocks of memory for use with hardware components that do not support I/O map nor scatter-gather.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You can disable CMA by specifying “cma=0” on the kernel’s command line.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For more information see &lt;include/linux/dma-contiguous.h&gt;. If unsure, say “n”.  <ul>\n<li><code>***Default contiguous memory area size:***</code>  </li>\n<li><code>(24) Size in Mega Bytes</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default 0 if X86<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default 16<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines the size (in MiB) of the default memory area for Contiguous Memory Allocator.  If the size of 0 is selected, CMA is disabled by default, but it can be enabled by passing cma=size[MG] to the kernel.  </li>\n<li><code>(C) Selected region size</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(X) Use mega bytes value only<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N) Use percentage value only<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N) Use lower value (minimum)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N) Use higher value (maximum)  </li>\n<li><code>(8) Maximum PAGE_SIZE order of alignment for contiguous buffers</code>  </li>\n</ul>\n</li>\n</ul>\n</details>  \n\n<details>\n<summary>Bus Devices ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/bus/Kconfig<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总线设备.此类设备仅出现在ARM平台。下列是勾选的：  </p>\n<ul>\n<li><code>&lt;Y&gt; OMAP INTERCONNECT DRIVER</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支持TI的omap开放式多媒体应用平台  </li>\n<li><code>&lt;Y&gt; OMAP OCP2SCP DRIVER</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ocp/scp协议  </li>\n<li><code>&lt;Y&gt; Simple Power-Managed Bus Driver</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;电源管理总线  </li>\n</ul>\n</details>  \n\n\n<details>\n<summary>< > Connector - unified userspace <-> kernelspace linker</-></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;连接器是一种新的用户态与内核态的通信方式，它使用起来非常方便。本质上，连接器是一种netlink，它的netlink协议号为 NETLINK_CONNECTOR，与一般的 netlink 相比，它提供了更容易的使用接口，使用起来更方便。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Connector driver makes it easy to connect various agents using a netlink based network. One must register a callback and an identifier. When the driver receives a special netlink message with the appropriate identifier, the appropriate callback will be called.  </p>\n</details>  \n\n<details>\n<summary><y> Memory Technology Device (MTD) support ---></y></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;详细参考/drivers/mtd/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MTD子系统是一个闪存转换层。其主要目的是提供一个介于闪存硬件驱动程序与高级应用程序之间的抽象层，以简化闪存设备的驱动。注意：MTD常用于嵌入式系统，而我们常见的U盘/MMC卡/SD卡/CF卡等移动存储设备以及固态硬盘(SSD)，虽然也叫”flash”，但它们并不是使用MTD技术的存储器。仅在你需要使用主设备号为31的MTD块设备(/dev/romX、/dev/rromX、/dev/flashX、/dev/rflashX)，或者主设备号为90的MTD字符设备(/dev/mtdX、/dev/mtdrX)时选”Y”，否则选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Memory Technology Devices are flash, RAM and similar chips, often used for solid state file systems on embedded devices. This option will provide the generic support for MTD drivers to register themselves with the kernel and for potential users of MTD devices to enumerate the devices which are present and obtain a handle on them. It will also allow you to select individual drivers for particular hardware and users of MTD devices. If unsure, say N.  </p>\n</details>  \n\n\n<details>\n<summary>-Y- Device Tree and Open Firmware support ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/mtd/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Device Tree基础架构与Open Firmware支持，主要用于嵌入式环境。不确定的选”N”。内核中若有其它选项依赖于它，则会自动选中此项。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option enables the device tree infrastructure. It is automatically selected by platforms that need it or can be enabled manually for unit tests, overlays or compile-coverage.  </p>\n</details>  \n\n\n<details>\n<summary>< > Parallel port support -----</summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/parport/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25针并口(LPT接口)支持，古董级的打印机或扫描仪可能使用这种接口。目前已被淘汰。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you want to use devices connected to your machine’s parallel port (the connector at the computer with 25 holes), e.g. printer, ZIP drive, PLIP link (Parallel Line Internet Protocol is mainly used to create a mini network by connecting the parallel ports of two local machines) etc., then you need to say Y here; please read <a href=\"file:Documentation/parport.txt\" target=\"_blank\" rel=\"noopener\">file:Documentation/parport.txt</a> and <a href=\"file:drivers/parport/BUGS-parport\" target=\"_blank\" rel=\"noopener\">file:drivers/parport/BUGS-parport</a>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For extensive information about drivers for many devices attaching to the parallel port see <a href=\"http://www.torque.net/linux-pp.html\" target=\"_blank\" rel=\"noopener\">http://www.torque.net/linux-pp.html</a> on the WWW. It is possible to share a single parallel port among several devices and it is safe to compile all the corresponding drivers into the kernel. To compile parallel port support as a module, choose M here: the module will be called parport. If you have more than one parallel port and want to specify which port and IRQ to be used by this driver at module load time, take a look at <a href=\"file:Documentation/parport.txt\" target=\"_blank\" rel=\"noopener\">file:Documentation/parport.txt</a>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say Y.  </p>\n</details>  \n\n<details>\n<summary>[Y] Block devices -----</summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;块设备，必选。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/block/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here to get to see options for various different block device drivers. This option alone does not add any kernel code.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you say N, all options in this submenu will be skipped and disabled; only do this if you know what you are doing.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列是勾选的：  </p>\n<ul>\n<li><code>&lt;Y&gt; Loopback device support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在进行某些测试的时候，往往需要新建一些磁盘分区或者设备（ISO9660镜像文件或者CD-ROM）等，此时对硬盘进行重新划分往往不太方便。在这种情况下，可以通过loop伪设备来实现循环挂载，从而达到目的。在使用之前，循环设备必须与现存文件系统上的文件相关联。这种关联将提供给用户一个应用程序接口，接口将允许文件视为块特殊文件（参见设备文件系统）使用。因此，如果文件中包含一个完整的文件系统，那么这个文件就能如同磁盘设备一般被挂载。这种设备文件经常被用于光盘或是磁盘镜像。通过循环挂载来挂载包含文件系统的文件，便使处在这个文件系统中的文件得以被访问。这些文件将出现在挂载点目录。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Linux中，设备名按照相应设备驱动程序的符号表项进行命名。这些设备被叫做“loop”设备，设备节点通常命名为/dev/loop0、/dev/loop1之类。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认情况下Linux支持的loop设备是8个。如果需要超过8个的loop设备，那么可能会遇到类似的错误“no such device”或“could not find any free loop device”，这是因为超过了可用loop设置设备的最大限制。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Saying Y here will allow you to use a regular file as a block device; you can then create a file system on that block device and mount it just as you would mount other block devices such as hard drive partitions, CD-ROM drives or floppy drives. The loop devices are block special device files with major number 7 and typically called /dev/loop0, /dev/loop1 etc.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is useful if you want to check an ISO 9660 file system before burning the CD, or if you want to use floppy images without first writing them to floppy. Furthermore, some Linux distributions avoid the need for a dedicated Linux partition by keeping their complete root file system inside a DOS FAT file using this loop device driver.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To use the loop device, you need the losetup utility, found in the util-linux package, see <a href=\"https://www.kernel.org/pub/linux/utils/util-linux/\" target=\"_blank\" rel=\"noopener\">https://www.kernel.org/pub/linux/utils/util-linux/</a>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The loop device driver can also be used to “hide” a file system in a disk partition, floppy, or regular file, either using encryption (scrambling the data) or steganography (hiding the data in the low bits of, say, a sound file). This is also safe if the file resides on a remote file server.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There are several ways of encrypting disks. Some of these require kernel patches. The vanilla kernel offers the cryptoloop option and a Device Mapper target (which is superior, as it supports all file systems). If you want to use the cryptoloop, say Y to both LOOP and CRYPTOLOOP, and make sure you have a recent (version 2.12 or later) version of util-linux. Additionally, be aware that the cryptoloop is not safe for storing journaled filesystems.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that this loop device has nothing to do with the loopback device used for network connections from the machine to itself. To compile this driver as a module, choose M here: the module will be called loop.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Most users will answer N here.  <ul>\n<li><code>(8) Number of loop devices to pre-create at init time</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置loop分区启动时默认分配的个数。  </li>\n</ul>\n</li>\n<li><code>&lt;Y&gt; RAM block device support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在内存中开辟一个和普通存储同样支持读写的块设备，一般用于启动时存放一个最小文件系统。详细参考<a href=\"file:Documentation/blockdev/ramdisk.txt\" target=\"_blank\" rel=\"noopener\">file:Documentation/blockdev/ramdisk.txt</a>，一般选择N。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Saying Y here will allow you to use a portion of your RAM memory as a block device, so that you can make file systems on it, read and write to it and do all the other things that you can do with normal block devices (such as hard drives). It is usually used to load and store a copy of a minimal root file system off of a floppy into RAM during the initial install of Linux.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that the kernel command line option “ramdisk=XX” is now obsolete. For details, read <a href=\"file:Documentation/blockdev/ramdisk.txt\" target=\"_blank\" rel=\"noopener\">file:Documentation/blockdev/ramdisk.txt</a>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To compile this driver as a module, choose M here: the module will be called brd. An alias “rd” has been defined for historical reasons.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Most normal users won’t need the RAM disk functionality, and can thus say N here.  <ul>\n<li><code>(16) Default number of RAM disks</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置默认RAM disks的个数。  </li>\n<li><code>(65536) Default RAM disk size (kbytes)</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置默认大小。  </li>\n</ul>\n</li>\n<li><code>&lt;Y&gt; Virtio block driver</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Virtio虚拟块设备驱动，仅可用在基于lguest或QEMU的半虚拟化客户机中(一般是KVM或XEN)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is the virtual block driver for virtio. It can be used with QEMU based VMMs (like KVM or Xen). Say Y or M.  </li>\n</ul>\n</details>  \n\n<details>\n<summary>< > NVM Express block device</summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NVM Express是专门针对PCI-E接口高性能固态硬盘的标准规范。有了这一标准，操作系统厂商只需要编写一种驱动，就可以支持不同厂商的不同PCI-E SSD设备，以解决过去PCI-E SSD产品形态与规格五花八门，缺乏通用性和互用性的问题。如果你有一块较新的PCIE固态硬盘，那么很大可能就是NVMe接口。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The NVM Express driver is for solid state drives directly connected to the PCI or PCI Express bus.  If you know you don’t have one of these, it is safe to answer N. To compile this driver as a module, choose M here: the module will be called nvme.  </p>\n</details>\n\n<details>\n<summary>< > NVM Express over Fabrics FC host driver</summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This provides support for the NVMe over Fabrics protocol using the FC transport.This allows you to use remote block devices exported using the NVMe protocol set.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To configure a NVMe over Fabrics controller use the nvme-cli tool from <a href=\"https://github.com/linux-nvme/nvme-cli\" target=\"_blank\" rel=\"noopener\">https://github.com/linux-nvme/nvme-cli</a>. If unsure, say N.</p>\n</details>\n\n\n\n<details>\n<summary><n> NVMe Target support </n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This enabled target side support for the NVMe protocol, that is it allows the Linux kernel to implement NVMe subsystems and controllers and export Linux block devices as NVMe namespaces. You need to select at least one of the transports below to make this functionality useful.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To configure the NVMe target you probably want to use the nvmetcli tool from <a href=\"http://git.infradead.org/users/hch/nvmetcli.git\" target=\"_blank\" rel=\"noopener\">http://git.infradead.org/users/hch/nvmetcli.git</a>.  </p>\n</details>  \n\n\n<details>\n<summary><n> Misc devices ---></n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他设备。以下是勾选的：  </p>\n<ul>\n<li><code>&lt;Y&gt; Analog Devices Digital Potentiometers</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you say yes here, you get support for the Analog Devices AD5258, AD5259, AD5251, AD5252, AD5253, AD5254, AD5255 AD5160, AD5161, AD5162, AD5165, AD5200, AD5201, AD5203, AD5204, AD5206, AD5207, AD5231, AD5232, AD5233, AD5235, AD5260, AD5262, AD5263, AD5290, AD5291, AD5292, AD5293, AD7376, AD8400, AD8402, AD8403, ADN2850, AD5241, AD5242, AD5243, AD5245, AD5246, AD5247, AD5248, AD5280, AD5282, ADN2860, AD5273, AD5171, AD5170, AD5172, AD5173, AD5270, AD5271, AD5272, AD5274 digital potentiometer chips.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See Documentation/misc-devices/ad525x_dpot.txt for the userspace interface.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This driver can also be built as a module. If so, the module will be called ad525x_dpot.  <ul>\n<li><code>&lt;Y&gt; support I2C bus connection</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here if you have a digital potentiometers hooked to an I2C bus. To compile this driver as a module, choose M here: the module will be called ad525x_dpot-i2c.  </li>\n</ul>\n</li>\n<li><code>&lt;Y&gt; Integrated Circuits ICS932S401</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖I2C驱动。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IDT ICS932S401系列时钟频率控制芯片支持(可能会出现在某些主板上)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you say yes here you get support for the Integrated Circuits ICS932S401 clock control chips. This driver can also be built as a module. If so, the module will be called ics932s401.  </li>\n<li><code>&lt;Y&gt; Medfield Avago APDS9802 ALS Sensor module</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖I2C驱动。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you say yes here you get support for the ALS APDS9802 ambient light sensor.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This driver can also be built as a module. If so, the module will be called apds9802als.  </li>\n<li><code>&lt;Y&gt; Intersil ISL29003 ambient light sensor</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖I2C和SYSFS驱动。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you say yes here you get support for the Intersil ISL29003ambient light sensor. This driver can also be built as a module. If so, the module will be called isl29003.  </li>\n<li><code>[Y] Generic on-chip SRAM driver</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;许多SoC系统都有芯片内嵌的SRAM。开启此项后，就可以声明将此段内存范围交给通用内存分配器(genalloc)管理。不确定的选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This driver allows you to declare a memory region to be managed by the genalloc API. It is supposed to be used for small on-chip SRAM areas found on many SoCs.  </li>\n<li><code>&lt;M&gt; PCI Endpoint Test driver</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PCI相关。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable this configuration option to enable the host side test driver for PCI Endpoint.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EEPROM support —&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一些eeprom设备的支持。  <ul>\n<li><code>&lt;M&gt; I2C EEPROMs / RAMs / ROMs from most vendors</code>  </li>\n<li><code>-Y- EEPROM 93CX6 support</code>  </li>\n</ul>\n</li>\n</ul>\n</details>  \n\n<details>\n<summary> ATA/ATAPI/MFM/RLL support (DEPRECATED) ----</summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;已被废弃的IDE硬盘和ATAPI光驱等接口的驱动(已被CONFIG_ATA取代)。  </p>\n</details>\n\n\n<details>\n<summary>SCSI device support ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有SCSI（小型计算机系统接口）设备，例如硬盘、软驱、光驱、打印机以及扫描仪等，就需要勾选。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/scsi/support。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you want to use a SCSI hard disk, SCSI tape drive, SCSI CD-ROM or any other SCSI device under Linux, say Y and make sure that you know the name of your SCSI host adapter (the card inside your computer that “speaks” the SCSI protocol, also called SCSI controller), because you will be asked for it.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You also need to say Y here if you have a device which speaks the SCSI protocol.  Examples of this include the parallel port version of the IOMEGA ZIP drive, USB storage devices, Fibre Channel, and FireWire storage.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To compile this driver as a module, choose M here and read <a href=\"file:Documentation/scsi/scsi.txt\" target=\"_blank\" rel=\"noopener\">file:Documentation/scsi/scsi.txt</a>. The module will be called scsi_mod.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;However, do not compile this as a module if your root file system (the one containing the directory /) is located on a SCSI device.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选的子项：  </p>\n<ul>\n<li><code>{M} SCSI device support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SCSI协议支持。有任何SCSI/SAS/SATA/USB/Fibre Channel/FireWire设备之一就必须选上，选”Y”。注意USB设备驱动也需要此项支持！  </li>\n<li><code>[Y] legacy /proc/scsi/ support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过时的/proc/scsi/接口。某些老旧的刻录程序可能需要它，建议选”N”。  </li>\n<li><code>&lt;M&gt; SCSI disk support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用SCSI/SAS/SATA/PATA/USB/Fibre Channel存储设备的必选，选”Y”。  </li>\n<li><code>&lt;M&gt; SCSI CDROM support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过SCSI/FireWire/USB/SATA/IDE接口连接的DVD/CD驱动器(基本上涵盖了所有常见的接口)。  </li>\n<li><code>[Y] SCSI low-level drivers ---&gt;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;底层SCSI驱动程序。  </li>\n</ul>\n</details>\n\n<details>\n<summary><m> Serial ATA and Parallel ATA drivers (libata)--->  </m></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SATA与PATA(IDE)设备。桌面级PC以及低端服务器的硬盘基本都是此种接口。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/ata/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you want to use an ATA hard disk, ATA tape drive, ATA CD-ROM or any other ATA device under Linux, say Y and make sure that you know the name of your ATA host adapter (the card inside your computer that “speaks” the ATA protocol, also called ATA controller), because you will be asked for it.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NOTE: ATA enables basic SCSI support; <em>however</em>, ‘SCSI disk support’, ‘SCSI tape support’, or ‘SCSI CDROM support’ may also be needed, depending on your hardware configuration.  </p>\n</details>\n\n\n<details>\n<summary>[N] Multiple devices driver support (RAID and LVM) ----</summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多设备支持(RAID和LVM)。RAID和LVM的功能是使用多个物理设备组建成一个单独的逻辑设备。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/md/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Support multiple physical spindles through a single logical device. Required for RAID and logical volume management.  </p>\n</details>\n\n\n<details>\n<summary><n> Generic Target Core Mod (TCM) and ConfigFS Infrastructure ----</n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通用TCM存储引擎与ConfigFS虚拟文件系统(/sys/kernel/config)支持，看不懂就说明你不需要。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/target/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y or M here to enable the TCM Storage Engine and ConfigFS enabled control path for target_core_mod.  This includes built-in TCM RAMDISK subsystem logic for virtual LUN 0 access.  </p>\n</details>\n\n\n<details>\n<summary>[N] Fusion MPT device support ----  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fusion MPT(Message Passing Technology) 是 LSI Logic 公司为了更容易实现SCSI和光纤通道而提出的技术，支持Ultra320 SCSI/光纤通道/SAS。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/message/fusion/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here to get to see options for Fusion Message Passing Technology (MPT) drivers.This option alone does not add any kernel code.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you say N, all options in this submenu will be skipped and disabled.  </p>\n</details>\n\n\n<details>\n<summary>IEEE 1394 (FireWire) support --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;火线(IEEE 1394)是苹果公司开发的串行接口，类似于USB，但PC上并不常见，算得上是个没有未来的技术了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/firewire/Kconfig。  </p>\n</details>\n\n\n<details>\n<summary>[Y] Network device support --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网络设备。除非你不想连接任何网络，否则必选”Y”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/net/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You can say N here if you don’t intend to connect your Linux box to any other computer at all.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You’ll have to say Y if your computer contains a network card that you want to use under Linux. If you are going to run SLIP or PPP over telephone line or null modem cable you need say Y here. Connecting two machines with parallel ports using PLIP needs this, as well as AX.25/KISS for sending Internet traffic over amateur radio links.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See also “The Linux Network Administrator’s Guide” by Olaf Kirch and Terry Dawson. Available at <a href=\"http://www.tldp.org/guides.html\" target=\"_blank\" rel=\"noopener\">http://www.tldp.org/guides.html</a>. If unsure, say Y.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选的：  </p>\n<ul>\n<li><code>[Y] Network core driver support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你不想使用任何高级网络功能(拨号网络/EQL/VLAN/bridging/bonding/team/光纤通道/虚拟网络等)，仅仅是一般性质的联网(普通低端服务器，通过路由器或者局域网上网的常规个人电脑或办公电脑)，可以选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You can say N here if you do not intend to use any of the networking core drivers (i.e. VLAN, bridging, bonding, etc.)  <ul>\n<li><code>&lt;M&gt; Dummy net driver support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dummy网络接口本质上是一个可以配置IP地址的bit-bucket(位桶，所有发送到此设备的流量都将被湮灭)，以使应用程序看上去正在和一个常规的网络接口进行通信。使用SLIP(小猫拨号，目前应该已经绝迹了)或PPP(常用于PPPoE ADSL)的用户需要它。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is essentially a bit-bucket device (i.e. traffic you send to this device is consigned into oblivion) with a configurable IP address. It is most commonly used in order to make your currently inactive SLIP address seem like a real address for local programs.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you use SLIP or PPP, you might want to say Y here. It won’t enlarge your kernel. What a deal. Read about it in the Network Administrator’s Guide, available from <a href=\"http://www.tldp.org/docs.html#guide\" target=\"_blank\" rel=\"noopener\">http://www.tldp.org/docs.html#guide</a>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To compile this driver as a module, choose M here: the module will be called dummy.  </li>\n<li><code>&lt;M&gt; MAC-VLAN support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MAC-VLAN是通过MAC地址来划分VLAN的方式,在Linux则用来给网卡添加多个MAC地址。你可以使用”ip link add link <real dev> [ address MAC ] [ NAME ] type macvlan”命令创建一个虚拟的”macvlan”设备(系统会自动打开网卡的混杂模式)，然后就可以在同一个物理网卡上虚拟出多个以太网口。Docker依赖于它.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This allows one to create virtual interfaces that map packets to or from specific MAC addresses to a particular interface.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Macvlan devices can be added using the “ip” command from the iproute2 package starting with the iproute2-2.6.23 release:”ip link add link <real dev> [ address MAC ] [ NAME ] type macvlan”<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To compile this driver as a module, choose M here: the module will be called macvlan.  </real></real></li>\n<li><code>&lt;M&gt; Virtual eXtensible Local Area Network (VXLAN)</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“vxlan”虚拟接口可以在第三层网络上创建第二层网络(跨多个物理IP子网的虚拟二层子网)，是一种在UDP中封装MAC的简单机制，主要用于虚拟化环境下的隧道虚拟网络(tunnel virtual network)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This allows one to create vxlan virtual interfaces that provide Layer 2 Networks over Layer 3 Networks. VXLAN is often used to tunnel virtual network infrastructure in virtualized environments.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For more information see: <a href=\"http://tools.ietf.org/html/draft-mahalingam-dutt-dcops-vxlan-02\" target=\"_blank\" rel=\"noopener\">http://tools.ietf.org/html/draft-mahalingam-dutt-dcops-vxlan-02</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To compile this driver as a module, choose M here: the module will be called vxlan.  </li>\n<li><code>&lt;M&gt; Virtual ethernet pair device</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该驱动提供了一个本地以太网隧道(设备会被成对的创建)，Docker依赖于它。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This device is a local ethernet tunnel. Devices are created in pairs. When one end receives the packet it appears on its pair and vice versa.  </li>\n<li><code>&lt;Y&gt; Virtio network driver</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtio虚拟网卡驱动，仅可用在基于lguest或QEMU的半虚拟化客户机中(一般是KVM或XEN)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is the virtual network driver for virtio.  It can be used with QEMU based VMMs (like KVM or Xen). Say Y or M.  </li>\n</ul>\n</li>\n<li><code>[Y] Ethernet driver support ---&gt;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最常见的以太网卡驱动，针对各厂商。参考：drivers/net/ethernet/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This section contains all the Ethernet device drivers  </li>\n<li><code>-Y- MDIO bus device drivers ----</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MDIO devices and driver infrastructure code.  </li>\n<li><code>-Y- PHY Device support and infrastructure ---&gt;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据链路层芯片简称为MAC控制器，物理层芯片简称之为PHY，通常的网卡把MAC和PHY的功能做到了一颗芯片中，但也有一些仅含PHY的“软网卡”。此选项就是对这些“软网卡”的支持。请根据实际情况选择其下的子项，参考：drivers/net/phy/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ethernet controllers are usually attached to PHY devices. This option provides infrastructure for managing PHY devices.  </li>\n<li><code>&lt;M&gt; USB Network Adapters ---&gt;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;USB网络适配器，参考：drivers/net/usb/Kconfig。  </li>\n<li><code>[Y] Wireless LAN ---&gt;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无线网卡，参考：drivers/net/wireless/Kconfig。  </li>\n</ul>\n</details>\n\n\n<details>\n<summary>[N] Open-Channel SSD target support ----</summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open-channel SSD 是一种遵守NVMe规范且不使用FTL技术的固态硬盘。目前此种SSD由于过于前卫还非常罕见，但是非常有前途。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/lightnvm/Kconfig。  </p>\n</details>\n\n\n<details>\n<summary>Input device support ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入设备。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/input/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>-Y- Generic input layer (needed for keyboard, mouse, ...)</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通用输入层。只要你有任何输入设备(键盘、鼠标、手写板、触摸板、游戏杆、方向盘,游戏键盘…)，就必须选”Y”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here if you have any input device (mouse, keyboard, tablet, joystick, steering wheel …) connected to your system and want it to be available to applications. This includes standard PS/2 keyboard and mouse.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say N here if you have a headless (no monitor, no keyboard) system.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;More information is available: <a href=\"file:Documentation/input/input.txt\" target=\"_blank\" rel=\"noopener\">file:Documentation/input/input.txt</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say Y.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To compile this driver as a module, choose M here: the module will be called input.  </li>\n<li><code>&lt;Y&gt; Export input device LEDs in sysfs</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将输入设备上的LED指示灯当作标准的LED类设备导出到sysfs中。不确定的选”Y”。  </li>\n<li><code>{M} Polled input device skeleton</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用轮询机制的输入设备支持，此项主要是为源码树之外的驱动准备的，内核自带的驱动若有需要会自动选中，不确定的选”N”。  </li>\n<li><code>*{M} Matrix keymap support library</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用”matrix keymap”的输入设备支持，此项主要是为源码树之外的驱动准备的，内核自带的驱动若有需要会自动选中，不确定的选”N”。  </li>\n<li><code>&lt;Y&gt; Joystick interface</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;游戏杆(joystick)和游戏键盘(gamepad)支持(/dev/input/jsX)。  </li>\n<li><code>&lt;Y&gt; Event interface</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将所有的输入设备事件都通过”/dev/input/eventX”以一种通用的方式进行处理.Xorg需要使用此接口，不确定的选”Y”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here if you want your input device events be accessible under char device 13:64+ - /dev/input/eventX in a generic way. To compile this driver as a module, choose M here: the module will be called evdev.  </li>\n<li><code>[Y] Keyboards ---&gt;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;键盘。  </li>\n<li><code>[Y] Mice ---&gt;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标。  </li>\n<li><code>[Y] Touchscreens ---&gt;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;触摸屏。  </li>\n<li><code>[Y] Miscellaneous devices ---&gt;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他杂项输入，支持GPIO、SPI、I2C，参考：drivers/input/misc/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here, and a list of miscellaneous input drivers will be displayed. Everything that didn’t fit into the other categories is here. This option doesn’t affect the kernel.  </li>\n</ul>\n</details>\n\n\n<details>\n<summary>Character devices ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符设备。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>[Y] Enable TTY</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符终端和串口都需要TTY的支持，选”Y”。参考/drivers/tty/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allows you to remove TTY support which can save space, and blocks features that require TTY from inclusion in the kernel. TTY is required for any text terminals or serial port communication. Most users should leave this enabled.  <ul>\n<li><code>[Y] Virtual terminal</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟终端可以在一个物理终端设备上虚拟出多个”显示器+键盘”的组合(可以使用”Alt+Fn”组合键在多个虚拟终端间切换)，除非是嵌入式系统，否则必选”Y”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you say Y here, you will get support for terminal devices with display and keyboard devices. These are called “virtual” because you can run several virtual terminals (also called virtual consoles) on one physical terminal. This is rather useful, for example one virtual terminal can collect system messages and warnings, another one can be used for a text-mode user session, and a third could run an X session, all in parallel. Switching between virtual terminals is done with certain key combinations, usually Alt-<function key>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The setterm command (“man setterm”) can be used to change the properties (such as colors or beeping) of a virtual terminal. The man page console_codes(4) (“man console_codes”) contains the special character sequences that can be used to change those properties directly. The fonts used on virtual terminals can be changed with the setfont (“man setfont”) command and the key bindings are defined with the loadkeys (“man loadkeys”) command.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You need at least one virtual terminal device in order to make use of your keyboard and monitor. Therefore, only people configuring an embedded system would want to say N here in order to save some memory; the only way to log into such a system is then via a serial or network connection.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say Y, or else you won’t be able to do much with your new shiny Linux system :-)  <ul>\n<li><code>[Y] Enable character translations in console</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在虚拟控制台(console)上支持字体映射和Unicode转换。  </li>\n<li><code>[Y] Support for console on virtual terminal</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核默认将第一个虚拟终端(/dev/tty0)用作系统控制台(可以通过”console=tty3”这样的参数去修改)，将诸如模块错误/内核错误/启动信息之类的警告信息发送到这里，而且以单用户模式登录时也需要使用这个控制台。若选”N”则会导致黑屏，除非是嵌入式系统，否则必选”Y”。  </li>\n<li><code>-Y- Support for binding and unbinding console drivers</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟终端是通过控制台驱动程序与物理终端交互的，但在某些系统上可以使用多个控制台驱动程序(如framebuffer控制台驱动程序)，该选项使得你可以选择其中之一。  </li>\n</ul>\n</function></li>\n<li><code>[Y] Unix98 PTY support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伪终端(PTY)是指一个”软件终端”，它是由slave(等价于一个物理终端)和master(被一个诸如xterm之类的进程用来读写slave设备)两部分组成的软设备。图形界面用户与需要支持ssh/telnet远程登录者必选。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A pseudo terminal (PTY) is a software device consisting of two halves: a master and a slave. The slave device behaves identical to a physical terminal; the master device is used by a process to read data from and write data to the slave, thereby emulating a terminal. Typical programs for the master side are telnet servers and xterms.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux has traditionally used the BSD-like names /dev/ptyxx for masters and /dev/ttyxx for slaves of pseudo terminals. This scheme has a number of problems. The GNU C library glibc 2.1 and later, however, supports the Unix98 naming standard: in order to acquire a pseudo terminal, a process opens /dev/ptmx; the number of the pseudo terminal is then made available to the process and the pseudo terminal slave can be accessed as /dev/pts/<number>. What was traditionally /dev/ttyp2 will then be /dev/pts/2, for example.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All modern Linux systems use the Unix98 ptys.  Say Y unless you’re on an embedded system and want to conserve memory.  </number></li>\n<li><code>[Y] Legacy (BSD) PTY support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用过时的BSD风格的/dev/ptyxx作为master，/dev/ttyxx作为slave，这个方案有一些安全问题，建议选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A pseudo terminal (PTY) is a software device consisting of two halves: a master and a slave. The slave device behaves identical to a physical terminal; the master device is used by a process to read data from and write data to the slave, thereby emulating a terminal. Typical programs for the master side are telnet servers and xterms.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux has traditionally used the BSD-like names /dev/ptyxx for masters and /dev/ttyxx for slaves of pseudo terminals. This scheme has a number of problems, including security.  This option enables these legacy devices; on most systems, it is safe to say N.  <ul>\n<li><code>(256) Maximum number of legacy PTY in use</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The maximum number of legacy PTYs that can be used at any one time. The default is 256, and should be more than enough. Embedded systems may want to reduce this to save memory. When not in use, each legacy PTY occupies 12 bytes on 32-bit architectures and 24 bytes on 64-bit architectures.  </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>[Y] /dev/mem virtual device support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”/dev/mem”虚拟设备是整个处理器地址空间的全映射(包括所有物理内存/设备IO空间/总线映射空间)，可以用来直接存取物理内存，常用于访问物理IO设备，例如dmidecode工具可以从中提取系统识别信息(序列号、制造商、型号、等等)，或者Xorg可以用来访问显卡的物理内存或者实现用户空间驱动，同时拥有root权限的攻击者也可以使用它完成很多标准rootkit的行为。如果你需要使用用户空间的驱动或不确定，那么选”Y”。如果你觉得安全特别重要，可以选”N”。  </li>\n<li><code>*Serial drivers ---&gt;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;串口(COM)驱动,串口在台式机主板上正在逐渐消亡,而在笔记本和服务器上早就已经绝迹了.大多数人应该将所有子项都选”N”。但在嵌入式系统仍然使用，参考/drivers/tty/serial/Kconfig。下列为勾选项：  <ul>\n<li><code>&lt;Y&gt; 8250/16550 and compatible serial support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是标准串口(COM)驱动，只要你想使用串口，就必选此项。  </li>\n<li><code>&lt;Y&gt; Support for OMAP internal UART (8250 based driver)</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TI OMAP平台芯片可选。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you have a machine based on an Texas Instruments OMAP CPU you can enable its onboard serial ports by enabling this option. This driver uses ttyS instead of ttyO.  <ul>\n<li><code>[Y] Replace ttyO with ttyS</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将ttyO代替为ttyS。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option replaces the “console=ttyO” argument with the matching ttyS argument if the user did not specified it on the command line. This ensures that the user can see the kernel output during boot which he wouldn’t see otherwise. The getty has still to be configured for ttyS instead of ttyO regardless of this option. This option is intended for people who “automatically” enable this driver without knowing that this driver requires a different console= argument. If you read this, please keep this option disabled and instead update your kernel command line. If you prepare a kernel for a distribution or other kind of larger user base then you probably want to keep this option enabled. Otherwise people might complain about a not booting kernel because the serial console remains silent in case they forgot to update the command line.  </li>\n</ul>\n</li>\n<li><code>&lt;Y&gt; Devicetree based probing for 8250 ports</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有相关资料默认选择。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option is used for all 8250 compatible serial ports that are probed through devicetree, including Open Firmware based PowerPC systems and embedded systems on architectures using the flattened device tree format.  </li>\n<li><code>&lt;Y&gt; Broadcom BCM63xx/BCM33xx UART support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有相关资料默认选择。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This enables the driver for the onchip UART core found on the following chipsets:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BCM33xx (cable modem)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BCM63xx/BCM63xxx (DSL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BCM68xx (PON)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BCM7xxx (STB) - DOCSIS console  </li>\n</ul>\n</li>\n<li><code>&lt;Y&gt; Virtio console</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Virtio虚拟控制台设备驱动，此外，该驱动还可以作为普通的串口设备(/dev/vportNpX)，用于客户机和宿主机之间的通信。仅可用在基于lguest或QEMU的半虚拟化客户机中(一般是KVM或XEN)。参考：drivers/char/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Also serves as a general-purpose serial device for data transfer between the guest and host.  Character devices at /dev/vportNpn will be created when corresponding ports are found, where N is the device number and n is the port number within that device.  If specified by the host, a sysfs attribute called ‘name’ will be populated with a name for the port which can be used by udev scripts to create a symlink to the device.  </li>\n<li><code>&lt;Y&gt; Hardware Random Number Generator Core support ---&gt;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;硬件随机数发生器设备(/dev/hw_random)支持。此设备并不会直接向内核的随机数发生器填充(这是”rngd”守护进程的职责)。详情参见”Documentation/hw_random.txt”文档。参考：drivers/char/hw_random/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hardware Random Number Generator Core infrastructure.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To compile this driver as a module, choose M here: the module will be called rng-core.  This provides a device that’s usually called /dev/hwrng, and which exposes one of possibly several hardware random number generators.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;These hardware random number generators do feed into the kernel’s random number generator entropy pool.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say Y.  </li>\n<li><code>[Y] /dev/port character device</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/char/Kconfig<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here if you want to support the /dev/port device. The /dev/port device is similar to /dev/mem, but for I/O ports.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I2C support —&gt;  </li>\n</ul>\n</details>\n\n\n<details>\n<summary>-Y- I2C support</summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I2C与SMBus支持，I2C(读着”I-squared-C”)是用于单片机(又称”微控制器”)的低速串行总线协议,它为微控制器(Microcontroller)与各种不同的低速设备通信提供了一种廉价的总线(因为只需要使用两个引脚,称为”2线”)，因此广泛的应用于嵌入式环境.SMBus(System Management Bus)差不多相当于是I2C的子集，最初的目的是为了管理智能电池，现在常用于硬件监控(电压/风扇转速/温度/电池等)以及内存模块的配置(使用I2C EEPROM)，因此所有PC主板都依赖于SMBus协议。系统硬件监控工具lm_sensors和i2c-tools依赖于此模块，硬件传感器和”Video For Linux”也需要该模块的支持。详情参见”Documentation/i2c/summary”文档及整个”i2c”文件夹。不确定的选”Y”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/i2c/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I2C (pronounce: I-squared-C) is a slow serial bus protocol used in many micro controller applications and developed by Philips.  SMBus, or System Management Bus is a subset of the I2C protocol.  More information is contained in the directory <a href=\"file:Documentation/i2c/\" target=\"_blank\" rel=\"noopener\">file:Documentation/i2c/</a>, especially in the file called “summary” there.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Both I2C and SMBus are supported here. You will need this for hardware sensors support, and also for Video For Linux support.If you want I2C support, you should say Y here and also to the specific driver for your bus adapter(s) below.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This I2C support can also be built as a module.  If so, the module will be called i2c-core.  </p>\n</details>\n\n\n<details>\n<summary>[Y] SPI support  ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;串行外设接口(Serial Peripheral Interface)是一种标准的四线同步双向串行总线，SPI类似于I2C，但比I2C的”2线”稍微复杂一些，SPI需要4个引脚(“4线”)，不但传输速率比I2C更高，还能实现全双工通信。大多数SPI设备不支持动态设备检测，有些甚至是只读或者只写的。SPI常用于微控制器(Microcontroller)与外围设备(RTC、传感器、EEPROM、FLASH、解/编码器、模数转换器、数字信号处理器)之间的通信，MMC和SD卡也可以通过SPI协议访问，而MMC接口的DataFlash卡则必须通过SPI才能访问。仅用于嵌入式环境，PC平台上没有这样的设备。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/spi/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The “Serial Peripheral Interface” is a low level synchronous protocol.  Chips that support SPI can have data transfer rates up to several tens of Mbit/sec.  Chips are addressed with a controller and a chipselect.  Most SPI slaves don’t support dynamic device discovery; some are even write-only or read-only.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SPI is widely used by microcontrollers to talk with sensors, eeprom and flash memory, codecs and various other controller chips, analog to digital (and d-to-a) converters, and more. MMC and SD cards can be accessed using SPI protocol; and for DataFlash cards used in MMC sockets, SPI must always be used.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SPI is one of a family of similar protocols using a four wire interface (select, clock, data in, data out) including Microwire (half duplex), SSP, SSI, and PSP.  This driver framework should work with most such devices and controllers.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重要的子项：  </p>\n<ul>\n<li><code>&lt;Y&gt; User mode SPI device driver support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This supports user mode SPI protocol drivers. Note that this application programming interface is EXPERIMENTAL and hence SUBJECT TO CHANGE WITHOUT NOTICE while it stabilizes.  </li>\n</ul>\n</details>\n\n\n<details>\n<summary><y> SPMI support ----</y></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统电源管理接口(SPMI, System Power Management Interface)是一种连接PMIC(Power Management Integrated Circuits)的双线串行接口，仅用于嵌入式环境。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/spmi/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SPMI (System Power Management Interface) is a two-wire serial interface between baseband and application processors and Power Management Integrated Circuits (PMIC).  </p>\n</details>\n\n\n<details>\n<summary><n> HSI support ----</n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高速同步串行接口(High speed synchronous Serial Interface)是移动产业处理器接口(MIPI)联盟的高速同步接口工作组发布的一项技术规范。MIPI(Mobile Industry Processor Interface)是2003年由ARM、Nokia、ST、TI等公司成立的一个联盟，目的是把手机内部的接口(如摄像头、显示屏接口、射频/基带接口等)标准化，从而减少手机设计的复杂程度和增加设计灵活性。MIPI联盟下面有不同的工作组，分别定义了一系列的手机内部接口标准，比如摄像头接口CSI，显示接口DSI，射频接口DigRF，麦克风/扬声器接口SLIMbus等。统一接口标准的好处是手机厂商根据需要可以从市面上灵活选择不同的芯片和模组，更改设计和功能时更加快捷方便。目前，MIPI联盟的董事成员包括英特尔、摩托罗拉、诺基亚、三星、意法半导体、德州仪器。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/hsi/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The “High speed synchronous Serial Interface” is synchronous serial interface used mainly to connect application engines and cellular modems.  </p>\n</details>\n\n\n<details>\n<summary>-Y- PPS support ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;秒脉冲(Pulse Per Second)驱动用来控制电流脉冲速率，可用于计时。PPS的精度可以到纳秒级，而且没有累积误差。这通常是GPS天线的一项功能，用于获取GPS卫星的授时。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/pps/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PPS (Pulse Per Second) is a special pulse provided by some GPS antennae. Userland can use it to get a high-precision time reference.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some antennae’s PPS signals are connected with the CD (Carrier Detect) pin of the serial line they use to communicate with the host. In this case use the SERIAL_LINE client support. Some antennae’s PPS signals are connected with some special host inputs so you have to enable the corresponding client support.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To compile this driver as a module, choose M here: the module will be called pps_core.ko.  </p>\n</details>\n\n\n<details>\n<summary>PTP clock support  ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;精密时间协议(Precision Time Protocol)是IEEE 1588定义的一种基于以太网的高精度时间同步协议。PTP采用硬件与软件结合设计，可以提供比纯软件方式的NTP(网络时间协议)高的多的精度(微秒级)。与GPS授时相比，在提供和GPS相同的精度情况下，PTP不需要为每个设备安装GPS那样昂贵的组件，只需要一个高精度的本地时钟和提供高精度时钟戳的部件，成本较低。一般的PC和服务器上没有PTP硬件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/ptp/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The IEEE 1588 standard defines a method to precisely synchronize distributed clocks over Ethernet networks. The standard defines a Precision Time Protocol (PTP), which can be used to achieve synchronization within a few dozen microseconds. In addition, with the help of special hardware time stamping units, it can be possible to achieve synchronization to within a few hundred nanoseconds.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This driver adds support for PTP clocks as character devices. If you want to use a PTP clock, then you should also enable at least one clock driver as well.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To compile this driver as a module, choose M here: the module will be called ptp.  </p>\n</details>\n\n<details>\n<summary>-Y- Pin controllers ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pin控制器。其下的各选项请根据实际硬件状况选择(皆为低功耗或嵌入式平台)。一般由其他项选中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/pinctrl/Kconfig。  </p>\n</details>\n\n\n<details>\n<summary>-Y- GPIO Support ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个芯片都会有至少一个引脚(PIN)，像CPU或者芯片组这种复杂的芯片，其引脚会有成百上千个，这些PIN就是芯片与外部沟通的渠道，每个PIN都会有它特定的功能。GPIO(General Purpose I/O)就是芯片上的一种通用功能的引脚，其功能可由使用者通过编程的方式自定义(所谓”可编程引脚”)，比如使用两条PIN就可以组成I2C，使用4条PIN就可以组成SPI。嵌入式系统经常需要控制结构简单但数量众多的外部设备(比如LED的亮与灭)，使用传统的串口或者并口就太”大炮打蚊子”，而GPIO则非常适合用于控制此类数量众多的简单设备。GPIO在嵌入式设备中使用广泛，但PC平台的芯片组南桥大多也集成有GPIO引脚(但只有BIOS才知道如何使用他们)，以支持某些特殊的定制硬件。详情参见”Documentation/gpio/gpio.txt”文档，不确定的选”N”。一般由其他项选中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/gpio/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This enables GPIO support through the generic GPIO library. You only need to enable this, if you also want to enable one or more of the GPIO drivers below.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say N.  </p>\n</details>\n\n\n<details>\n<summary><m> Dallas's 1-wire support ---></m></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dallas公司发明的单总线是比I2C更简单的总线，仅使用一个引脚(1-wire)，使用Master-Slave结构，用于连接慢速的单引脚设备，比如iButton和热传感器。主要用于嵌入式系统。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/w1/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dallas’ 1-wire bus is useful to connect slow 1-pin devices such as iButtons and thermal sensors.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you want W1 support, you should say Y here.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This W1 support can also be built as a module.  If so, the module will be called wire.  </p>\n</details>\n\n\n<details>\n<summary>[Y] Adaptive Voltage Scaling class support ----</summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自适应电压调节(Adaptive Voltage Scaling)技术能够动态的对设备工作电压进行精细的调整，拥有比DVFS更佳的电力利用效率，是一种降低功耗与优化性能并举的电源与性能管理技术。AVS在OMAP设备上也被称为”SmartReflex”，目前仅用于嵌入式领域。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/power/avs/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AVS is a power management technique which finely controls the operating voltage of a device in order to optimize (i.e. reduce) its power consumption. At a given operating point the voltage is adapted depending on static factors (chip manufacturing process) and dynamic factors (temperature depending performance). AVS is also called SmartReflex on OMAP devices.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here to enable Adaptive Voltage Scaling class support.  </p>\n</details>\n\n\n\n<details>\n<summary>[Y] Board level reset or power off ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;允许通过操作板载的主电源，关闭或重启整个系统。仅用于嵌入式系统。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/power/reset/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Provides a number of drivers which either reset a complete board or shut it down, by manipulating the main power supply on the board.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here to enable board reset and power off  </p>\n</details>\n\n<details>\n<summary>[Y] Power supply class support ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;允许用户空间程序通过sysfs/uevent接口对电源(电池、交流电、USB)进行监控。主要用于笔记本与嵌入式设备。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/power/supply/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here to enable power supply class support. This allows power supply (batteries, AC, USB) monitoring by userspace via sysfs and uevent (if available) and/or APM kernel interface (if selected below).  </p>\n</details>\n\n<details>\n<summary><y> Hardware Monitoring support ---></y></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前主板大多都有一个监控硬件温度/电压/风扇转速等状况的设备，请按照主板实际使用的芯片选择相应的子项。如果你不知道究竟需要使用哪个驱动，可以使用Superiotool和sensors-detect工具进行检测。另外,某些子项可能还需要CONFIG_I2C的支持。更多详情参见”Documentation/hwmon/userspace-tools”文档。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/hwmon/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hardware monitoring devices let you monitor the hardware health of a system. Most modern motherboards include such a device. It can include temperature sensors, voltage sensors, fan speed sensors and various additional features such as the ability to control the speed of the fans.  If you want this support you should say Y here and also to the specific driver(s) for your sensors chip(s) below.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To find out which specific driver(s) you need, use the sensors-detect script from the lm_sensors package.  Read <a href=\"file:Documentation/hwmon/userspace-tools\" target=\"_blank\" rel=\"noopener\">file:Documentation/hwmon/userspace-tools</a> for details.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This support can also be built as a module.  If so, the module will be called hwmon.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>&lt;Y&gt; GPIO fan</code>  </li>\n<li><code>&lt;Y&gt; Hwmon driver that uses channels specified via iio maps</code>  </li>\n<li><code>&lt;Y&gt; National Semiconductor LM90 and compatibles</code>  </li>\n<li><code>&lt;Y&gt; National Semiconductor LM95245 and compatibles</code>  </li>\n<li><code>&lt;M&gt; NTC thermistor support from Murata</code>  </li>\n<li><code>&lt;M&gt; PWM fan</code>  </li>\n<li><code>&lt;M&gt; Texas Instruments INA219 and compatibles</code>  </li>\n<li><code>&lt;Y&gt; Texas Instruments TMP102</code>  </li>\n</ul>\n</details>\n\n<details>\n<summary>-Y- Generic Thermal sysfs driver ---> </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为ACPI规范中定义的”thermal”(发热控制)提供一个通用的sysfs接口，以方便与诸如温度传感器和风扇之类的设备通信。由于目前所有PC和服务器都已支持ACPI，并且发热控制也越来越重要，所以建议选”Y”。详情参见”Documentation/thermal/sysfs-api.txt”文档。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/thermal/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generic Thermal Sysfs driver offers a generic mechanism for thermal management. Usually it’s made up of one or more thermal zone and cooling device. Each thermal zone contains its own temperature, trip points, cooling devices.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All platforms with ACPI thermal support can use this driver.If you want this support, you should say Y or M here.  </p>\n</details>\n\n<details>\n<summary>[Y] Watchdog Timer Support ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选”Y”并选中下面相应的驱动之后，再创建一个主/次设备号为10/130的字符设备”/dev/watchdog”，即可拥有一只看门狗。其工作原理是：当/dev/watchdog设备被打开后，如果喂狗守护进程超过60秒没有喂狗(写入”/dev/watchdog”)，那么底层的看门狗硬件将会触发整个机器硬重启(相当于按下面板上的”RESET”按钮)。这对于提高服务器的在线率来说意义重大。详情参见”Documentation/watchdog/watchdog-api.txt”文档。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/watchdog/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you say Y here (and to one of the following options) and create a character special file /dev/watchdog with major number 10 and minor number 130 using mknod (“man mknod”), you will get a watchdog, i.e.: subsequently opening the file and then failing to write to it for longer than 1 minute will result in rebooting the machine. This could be useful for a networked machine that needs to come back on-line as fast as possible after a lock-up. There’s both a watchdog implementation entirely in software (which can sometimes fail to reboot the machine) and a driver for hardware watchdog boards, which are more robust and can also keep track of the temperature inside your computer. For details, read <a href=\"file:Documentation/watchdog/watchdog-api.txt\" target=\"_blank\" rel=\"noopener\">file:Documentation/watchdog/watchdog-api.txt</a> in the kernel source.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The watchdog is usually used together with the watchdog daemon which is available from <a href=\"ftp://ibiblio.org/pub/Linux/system/daemons/watchdog/\" target=\"_blank\" rel=\"noopener\">ftp://ibiblio.org/pub/Linux/system/daemons/watchdog/</a>. This daemon can also monitor NFS connections and can reboot the machine when the process table is full.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say N.  </p>\n</details>\n\n<details>\n<summary>Sonics Silicon Backplane  ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSB(Sonics Silicon Backplane)是一种仅在嵌入式环境中使用的总线。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/ssb/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Support for the Sonics Silicon Backplane bus. You only need to enable this option, if you are configuring a kernel for an embedded system with this bus.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It will be auto-selected if needed in other environments.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The module will be called ssb.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say N.  </p>\n</details>\n\n<details>\n<summary>{Y} Broadcom specific AMBA ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Broadcom特有的AMBA(Advanced Microcontroller Bus Architecture)总线支持，仅用于嵌入式环境。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/bcma/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bus driver for Broadcom specific Advanced Microcontroller Bus Architecture.  </p>\n</details>\n\n<details>\n<summary>[Y] ChipCommon-attached serial flash support</summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/bcma/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some cheap devices have serial flash connected to the ChipCommon instead of independent SPI controller. It requires using a separated driver that implements ChipCommon specific interface communication.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enabling this symbol will let bcma recognize serial flash and register it as platform device.  </p>\n</details>\n\n<details>\n<summary>[Y] BCMA Broadcom GBIT MAC COMMON core driver</summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/bcma/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Driver for the Broadcom GBIT MAC COMMON core attached to Broadcom specific Advanced Microcontroller Bus.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say N  </p>\n</details>\n\n<details>\n<summary>[Y] BCMA GPIO driver</summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/bcma/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Driver to provide access to the GPIO pins of the bcma bus.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say N  </p>\n</details>\n\n<details>\n<summary>[N] BCMA debugging</summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/bcma/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This turns on additional debugging messages.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say N  </p>\n</details>\n\n<details>\n<summary>Multifunction device drivers ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MFD(多功能设备)的含义是”在单个芯片上集成多个功能(GPIO、触摸屏、键盘、电流调节、电源管理…)”。此种芯片通常通过一个或多个IRQ线和低速数据总线(SPI/I2C/GPIO)与主CPU进行通信。对于主系统来说，它们通过数据总线显示为一个单独的MFD设备。但透过MFD框架，又可以拥有多个相互独立的子设备(子功能)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/mfd/Kconfig。  </p>\n</details>\n\n<details>\n<summary>-Y- Voltage and Current Regulator Support ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通用的电压与电流调节器框架，除了提供通用的电压与电流调节接口外，还能通过sysfs向用户空间提供电压与电流的状态信息。目的在于通过动态调节电压和电流，降低能耗，延长电池寿命。主要用于嵌入式环境。一般由其他项选中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/regulator/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generic Voltage and Current Regulator support.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This framework is designed to provide a generic interface to voltage and current regulators within the Linux kernel. It’s intended to provide voltage and current control to client or consumer drivers and also provide status information to user space applications through a sysfs interface.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The intention is to allow systems to dynamically control regulator output in order to save power and prolong battery life. This applies to both voltage regulators (where voltage output is controllable) and current sinks (where current output is controllable).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This framework safely compiles out if not selected so that client drivers can still be used in systems with no software controllable regulators.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say no.  </p>\n</details>\n\n<details>\n<summary><y> Remote Controller support ---> </y></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/media/rc/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable support for Remote Controllers on Linux. This is needed in order to support several video capture adapters, standalone IR receivers/transmitters, and RF receivers.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable this option if you have a video capture board even if you don’t need IR, as otherwise, you may not be able to compile the driver for your adapter.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y when you have a TV or an IR device.  </p>\n</details>\n\n<details>\n<summary><y> Multimedia support ---></y></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多媒体设备：摄像头、视频采集、模拟电视、数字电视、机顶盒、收音机、遥控器、数字视频广播(DVB)…内核多媒体子系统由LinuxTV项目负责维护。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/media/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you want to use Webcams, Video grabber devices and/or TV devices enable this option and other options below. Additional info and docs are available on the web at <a href=\"https://linuxtv.org\" target=\"_blank\" rel=\"noopener\">https://linuxtv.org</a>  </p>\n</details>\n\n<details>\n<summary>Graphics support ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图形设备/显卡支持，对于不需要使用图形界面的服务器环境来说，必须的最小选项集取决于平台(BIOS/UEFI)和引导程序(GRUB/LILO/GRUB4DOS)的设置(全选”N”则屏幕将无任何显示)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/gpu。  </p>\n</details>\n\n<details>\n<summary><y> Sound card support ---></y></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;声卡支持。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：sound/Kconfig<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you have a sound card in your computer, i.e. if it can say more than an occasional beep, say Y.  Be sure to have all the information about your sound card and its configuration down (I/O port, interrupt and DMA channel), because you will be asked for it.You want to read the Sound-HOWTO, available from <a href=\"http://www.tldp.org/docs.html#howto\" target=\"_blank\" rel=\"noopener\">http://www.tldp.org/docs.html#howto</a>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;General information about the modular sound system is contained in the files <a href=\"file:Documentation/sound/oss/Introduction\" target=\"_blank\" rel=\"noopener\">file:Documentation/sound/oss/Introduction</a>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The file <a href=\"file:Documentation/sound/oss/README.OSS\" target=\"_blank\" rel=\"noopener\">file:Documentation/sound/oss/README.OSS</a> contains some slightly outdated but still useful information as well.  Newer sound driver documentation is found in <a href=\"file:Documentation/sound/alsa/*\" target=\"_blank\" rel=\"noopener\">file:Documentation/sound/alsa/*</a>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you have a PnP sound card and you want to configure it at boot time using the ISA PnP tools (read <a href=\"http://www.roestock.demon.co.uk/isapnptools/\" target=\"_blank\" rel=\"noopener\">http://www.roestock.demon.co.uk/isapnptools/</a>), then you need to compile the sound card support as a module and load that module after the PnP configuration is finished.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To do this, choose M here and read <a href=\"file:Documentation/sound/oss/README.modules\" target=\"_blank\" rel=\"noopener\">file:Documentation/sound/oss/README.modules</a>; the module will be called soundcore.  </p>\n</details>\n\n<details>\n<summary>HID support ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HID(人机接口设备)是一种定义计算机如何与人类交互的规范，常与USB或蓝牙搭配使用，常见的设备有：键盘、鼠标、触摸板、游戏杆、遥控器、蓝牙耳机、游戏手柄、手写板等等。不过HID设备不一定要有人机接口，只要符合HID规范，就是HID设备。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/hid/Kconfig<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A human interface device (HID) is a type of computer device that interacts directly with and takes input from humans. The term “HID” most commonly used to refer to the USB-HID specification, but other devices (such as, but not strictly limited to, Bluetooth) are designed using HID specification (this involves certain keyboards, mice, tablets, etc). This option adds the HID bus to the kernel, together with generic HID layer code. The HID devices are added and removed from the HID bus by the transport-layer drivers, such as usbhid (USB_HID) and hidp (BT_HIDP).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For docs and specs, see <a href=\"http://www.usb.org/developers/hidpage/\" target=\"_blank\" rel=\"noopener\">http://www.usb.org/developers/hidpage/</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say Y.  </p>\n</details>\n\n<details>\n<summary>[Y] USB support ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通用串行总线(Universal Serial Bus)的目标是统一电脑的外设接口，目前几乎找不到没有USB接口的电脑，而且各种智能设备也大多带有USB接口。不要犹豫，选”Y”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/usb/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option adds core support for Universal Serial Bus (USB). You will also need drivers from the following menu to make use of it.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>&lt;M&gt; Support for Host-side USB</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主机端(Host-side)USB支持。通用串行总线(USB)是一个串行总线子系统规范，它比传统的串口速度更快并且特性更丰富(供电、热插拔、最多可接127个设备等)，其目标是统一PC外设接口。USB总体上呈现一种树型结构，USB的”Host”(主设备)被称为”根”(也可以理解为是主板上的USB控制器)，USB的”Slave”(从设备)被称为”叶子”，而内部的节点则称为”hub”(集线器)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Universal Serial Bus (USB) is a specification for a serial bus subsystem which offers higher speeds and more features than the traditional PC serial port.  The bus supplies power to peripherals and allows for hot swapping.  Up to 127 USB peripherals can be connected to a single USB host in a tree structure.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The USB host is the root of the tree, the peripherals are the leaves and the inner nodes are special USB devices called hubs. Most PCs now have USB host ports, used to connect peripherals such as scanners, keyboards, mice, modems, cameras, disks, flash memory, network links, and printers to the PC.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here if your computer has a host-side USB port and you want to use USB devices.  You then need to say Y to at least one of the Host Controller Driver (HCD) options below.  Choose a USB 1.1 controller, such as “UHCI HCD support” or “OHCI HCD support”, and “EHCI HCD (USB 2.0) support” except for older systems that do not have USB 2.0 support.  It doesn’t normally hurt to select them all if you are not certain.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If your system has a device-side USB port, used in the peripheral side of the USB protocol, see the “USB Gadget” framework instead.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;After choosing your HCD, then select drivers for the USB peripherals you’ll be using.  You may want to check out the information provided in <a href=\"file:Documentation/usb/\" target=\"_blank\" rel=\"noopener\">file:Documentation/usb/</a> and especially the links given in <a href=\"file:Documentation/usb/usb-help.txt\" target=\"_blank\" rel=\"noopener\">file:Documentation/usb/usb-help.txt</a>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To compile this driver as a module, choose M here: the module will be called usbcore.  </li>\n<li><code>[Y] PCI based USB host interface</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A lot of embeded system SOC (e.g. freescale T2080) have both PCI and USB modules. But USB module is controlled by registers directly, it have no relationship with PCI module.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When say N here it will not build PCI related code in USB driver.  </li>\n<li><code>[Y] USB announce new devices</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在syslog中记录每个新接入系统的USB设备的详细标识信息，主要用于系统调试.不确定的选”N”。  </li>\n<li><code>[Y] Enable USB persist by default</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据USB规范，当USB总线被挂起(休眠)后，它必须继续提供挂起电流(1-5毫安)，以确保USB设备能保持其内部状态，并且USB集线器(HUB)能够检测连接变化(设备插入和拔出)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这在技术上被称为”电力会话”(power session)。如果一个USB设备的电力会话被中断，那么系统必须按照该设备已经被拔出进行处理，这是一种保守的做法。因为没有挂起电流，计算机不可能知道外围设备究竟发生了什么变化：也许依然保持连接，也许已经被拔出并在同一端口上插入了一个新设备。系统必须做最坏的打算，默认情况下，Linux的行为符合USB规范的要求。当整个电脑进入休眠状态(例如挂起到硬盘)时，包括USB总线在内所有总线都将掉电，然后当系统被唤醒，所有USB设备都会被当做在休眠前就已经被拔出来处理。这样做始终是安全的，并且也是”官方正确”的做法。对于大多数USB设备来说，这样做没有任何问题，但是对于USB存储设备(例如移动硬盘/U盘)来说，如果在休眠前有尚未卸载的文件系统(特别是根文件系统)，当系统被唤醒之后，由于无法访问该文件系统，系统可能会立即崩溃！其实不只有掉电，只要”power session”被中断(例如BIOS在唤醒过程中重置了USB控制器)，都会导致这种故障。此选项(USB-persist)就是为了解决这个问题而设置的，虽然解决的不甚完美(参见”Documentation/usb/persist.txt”)，但是依然推荐选”Y”，除非你确实有选”N”的理由。当然，最保险的做法是在休眠之前先卸载所有USB设备上的文件系统，而如果根文件系统位于USB设备上，就根本不使用任何休眠功能(不论是挂起到硬盘还是挂起到内存)。  </li>\n<li><code>&lt;M&gt; xHCI HCD (USB 3.0) support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xHCI(eXtensible Host Controller Interface)就是当下大红大紫的USB3.0主机控制器规范。  </li>\n<li><code>&lt;M&gt; EHCI HCD (USB 2.0) support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EHCI(Enhanced Host Controller Interface)就是渐成昨日黄花的USB2.0(HighSpeed USB)主机控制器规范。  </li>\n<li><code>&lt;M&gt; OHCI HCD (USB 1.1) support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OHCI(Open Host Controller Interface)是主要用于嵌入式环境的USB1.1(主机控制器规范，但也存在于某些老旧的SiS芯片组的PC上。  </li>\n<li><code>&lt;M&gt; USB Modem (CDC ACM) support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;USB接口的猫或ISDN适配器，基本没人用的东西。  </li>\n<li><code>&lt;M&gt; USB Mass Storage support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;USB存储设备(U盘、USB硬盘、USB软盘、USB光盘、USB磁带、记忆棒、数码相机、读卡器[包括某些笔记本内置的SD卡读卡器]等等)。该选项依赖于CONFIG_SCSI和CONFIG_BLK_DEV_SD选项。选”Y”，除非你确实知道自己在干什么。  </li>\n</ul>\n</details>\n\n<details>\n<summary><n> Ultra Wideband devices ----</n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UWB(Ultra Wideband)是一种高带宽，低能耗，点对点,抗干扰性能强的无载波通信技术。UWB在较宽的频谱(3.1-10.6GHz)上，使用极低的功率(约为蓝牙的1/20)，以时间间隔极短(小于1ns)的脉冲信号进行通信。UWB主要应用于室内通信(2米范围内实现480Mbps速率，10米范围内实现110Mbps速率)，例如作为WUSB(Wireless USB)协议的传输层。如果你有UWB无线控制器，可以选”Y”，不确定的选”N”。详见”Documentation/usb/WUSB-Design-overview.txt”文档。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/uwb/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UWB is a high-bandwidth, low-power, point-to-point radio technology using a wide spectrum (3.1-10.6GHz). It is optimized for in-room use (480Mbps at 2 meters, 110Mbps at 10m). It serves as the transport layer for other protocols, such as Wireless USB (WUSB).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The topology is peer to peer; however, higher level protocols (such as WUSB) might impose a master/slave relationship.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here if your computer has UWB radio controllers (USB or PCI) based. You will need to enable the radio controllers below.  It is ok to select all of them, no harm done.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For more help check the UWB and WUSB related files in <a href=\"file:Documentation/usb/\" target=\"_blank\" rel=\"noopener\">file:Documentation/usb/</a>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To compile the UWB stack as a module, choose M here.  </p>\n</details>\n\n<details>\n<summary><y> MMC/SD/SDIO card support ---></y></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MMC(MultiMediaCard)/SD(Secure Digital)/SDIO(Secure Digital I/O)主机控制器。[提示]虽然许多笔记本上有SD卡插槽,但其实它们大多使用的是CONFIG_USB_STORAGE驱动,而不是这里的驱动。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/mmc/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This selects MultiMediaCard, Secure Digital and Secure Digital I/O support.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you want MMC/SD/SDIO support, you should say Y here and also to your specific host controller driver.  </p>\n</details>\n\n<details>\n<summary><n> Sony MemoryStick card support ----</n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sony记忆棒是一种Sony专用的存储设备。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/memstick/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sony MemoryStick is a proprietary storage/extension card protocol.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you want MemoryStick support, you should say Y here and also to the specific driver for your MemoryStick interface.  </p>\n</details>\n\n<details>\n<summary>[Y] LED Support ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发光二级管(LED)支持.[提示]标准键盘上的LED灯不在此列(由input子系统控制)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/leds/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y to enable Linux LED support.  This allows control of supported LEDs from both userspace and optionally, by kernel events (triggers).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>&lt;Y&gt; LED Class Support</code>  </li>\n<li><code>&lt;Y&gt; LED Support for GPIO connected LEDs</code>  </li>\n<li><code>&lt;Y&gt; PWM driven LED Support</code>  </li>\n<li><code>&lt;Y&gt; LED driver for TLC59108 and TLC59116 controllers</code>  </li>\n</ul>\n</details>\n\n<details>\n<summary>[N] Accessibility support ----</summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无障碍(Accessibility)支持。各种帮助残疾人使用计算机的软硬件技术，例如：盲文设备、语音合成、键盘映射等等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/accessibility/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accessibility handles all special kinds of hardware devices or software adapters which help people with disabilities (e.g. blindness) to use computers.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;That includes braille devices, speech synthesis, keyboard remapping, etc.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here to get to see options for accessibility.This option alone does not add any kernel code.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you say N, all options in this submenu will be skipped and disabled.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say N.  </p>\n</details>\n\n<details>\n<summary><n> InfiniBand support ----</n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InfiniBand是一种低延迟/高带宽数据中心互联架构，采用远程直接内存存取(RDMA)实现高性能处理器间通信(IPC)，同时对虚拟化技术也提供了良好的支持。主要用于服务器集群与高性能计算(HPC)领域。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/infiniband/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Core support for InfiniBand (IB).  Make sure to also select any protocols you wish to use as well as drivers for your InfiniBand hardware.  </p>\n</details>\n\n<details>\n<summary><y> EDAC (Error Detection And Correction) reporting ---></y></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在电磁环境比较恶劣的情况下，一些大规模集成电路常常会受到干扰，特别是像RAM这种利用双稳态进行存储的器件，往往会在强干扰下发生翻转，使原来存储的”0”变为”1”，或者”1”变为”0”，造成严重的后果(例如控制程序跑飞，关键数据出错)。随着芯片集成度的增加，发生错误的可能性也在增大，这已经成为一个不能忽视的问题。错误检测与纠正(EDAC)技术的目标就是发现并报告甚至纠正在计算机系统中发生的错误，这些错误是由CPU或芯片组报告的底层错误(内存错误/缓存错误/PCI错误/温度过高等等)，建议选”Y”。如果这些代码报告了一个错误，请到<a href=\"http://bluesmoke.sourceforge.net/和http://buttersideup.com/edacwiki查看更多信息。详见&quot;Documentation/edac.txt&quot;文档。\" target=\"_blank\" rel=\"noopener\">http://bluesmoke.sourceforge.net/和http://buttersideup.com/edacwiki查看更多信息。详见&quot;Documentation/edac.txt&quot;文档。</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/edac/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EDAC is a subsystem along with hardware-specific drivers designed to report hardware errors. These are low-level errors that are reported in the CPU or supporting chipset or other subsystems: memory errors, cache errors, PCI errors, thermal throttling, etc..<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, select ‘Y’.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The mailing list for the EDAC project is <a href=\"mailto:linux-edac@vger.kernel.org\" target=\"_blank\" rel=\"noopener\">linux-edac@vger.kernel.org</a>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>[Y] EDAC legacy sysfs</code>  </li>\n<li><code>&lt;M&gt; Texas Instruments DDR3 ECC Controller</code>  </li>\n</ul>\n</details>\n\n<details>\n<summary>[Y] Real Time Clock ---></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通用RTC(实时时钟)类支持。所有的PC机主板都包含一个电池动力的实时时钟芯片，以便在断电后仍然能够继续保持时间，RTC通常与CMOS集成在一起，因此BIOS可以从中读取当前时间(精度一般是秒级)。选中此项后你就可以在操作系统中使用一个或多个RTC设备(你还必须从下面启用一个或多个RTC接口)。[注意]Clock与Timer没有任何关系，Timer是定时器(用于计量时长)，Clock是时钟(用于记录当前的时刻”年-月-日 时：分：秒”)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/rtc/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generic RTC class support. If you say yes here, you will be allowed to plug one or more RTCs to your system. You will probably want to enable one or more of the interfaces below.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为主要勾选项：  </p>\n<ul>\n<li><code>[Y] Set system time from RTC on startup and resume</code>  </li>\n<li><code>[Y] Set the RTC time based on NTP synchronization</code>  </li>\n<li><code>[Y] RTC debug support</code>  </li>\n<li><code>[Y] RTC non volatile storage support</code>  </li>\n<li><code>[Y] /sys/class/rtc/rtcN (sysfs)</code>  </li>\n<li><code>[Y] /proc/driver/rtc (procfs for rtcN)</code>  </li>\n<li><code>[Y] /dev/rtcN (character devices)</code>  </li>\n<li><code>&lt;M&gt; Dallas/Maxim DS1307/37/38/39/40/41, ST M41T00, EPSON RX-8025, ISL12057</code>  </li>\n<li><code>&lt;M&gt; TI Palmas RTC driver</code>  </li>\n<li><code>&lt;M&gt; TI TPS6586X RTC driver</code>  </li>\n<li><code>&lt;M&gt; TI TPS65910 RTC driver</code>  </li>\n<li><code>&lt;M&gt; EFI RTC</code>  </li>\n<li><code>&lt;M&gt; TI OMAP Real Time Clock</code>  </li>\n</ul>\n</details>\n\n<details>\n<summary>[Y] DMA Engine support --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA引擎(DMA Engine)可以看做是传统DMA控制器(DMA controller)的新生。在DMA引擎的协助下，CPU只需初始化一个传输动作，其余的动作就可以由DMA引擎独立完成(完成后以中断的方式通知CPU)，这对于高速传输大量数据以及”分散-收集”操作大有益处，可以节约大量的CPU资源(有时也可节约大量的内存操作)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前，DMA引擎有两个用途：(1)卸载高速网络栈中的内存COPY操作，(2)加速CONFIG_MD_RAID456驱动中的RAID操作。”DMA引擎”只是一个统称，在不同场合对应着不同的技术，例如Intel I/OAT(PC平台)和AHB(嵌入式)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/dma/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA engines can do asynchronous data transfers without involving the host CPU.  Currently, this framework can be used to offload memory copies in the network stack and RAID operations in the MD driver.  This menu only presents DMA Device drivers supported by the configured arch, it may be empty in some cases.  </p>\n</details>\n\n<details>\n<summary>DMABUF options --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下为勾选项：  </p>\n<ul>\n<li><code>-Y- Explicit Synchronization Framework</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/dma-buf/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Sync File Framework adds explicit syncronization via userspace. It enables send/receive ‘struct dma_fence’ objects to/from userspace via Sync File fds for synchronization between drivers via userspace components. It has been ported from Android.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The first and main user for this is graphics in which a fence is associated with a buffer. When a job is submitted to the GPU a fence is attached to the buffer and is transferred via userspace, using Sync Files fds, to the DRM driver for example. More details at Documentation/sync_file.txt.  </li>\n</ul>\n</details>\n\n<details>\n<summary>[N] Auxiliary Display support ----  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;辅助显示设备。例如基于KS0108控制器的Crystalfontz CFAG12864B单色液晶屏(分辨率:128x64)。仅用于嵌入式系统。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/auxdisplay/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here to get to see options for auxiliary display drivers. This option alone does not add any kernel code.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you say N, all options in this submenu will be skipped and disabled.  </p>\n</details>\n\n<details>\n<summary><m> Userspace I/O drivers--->  </m></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UIO(Userspace I/O)是运行在用户空间的I/O技术，它为开发用户空间的驱动提供了一个简单的架构(/dev/uioN)。使用uio的设备一般都属于嵌入式系统，不确定的选”N”。[提示]lsuio工具可以列出所有UIO的模块和其映射的内存地址。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/uio/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable this to allow the userspace driver core code to be built.  This code allows userspace programs easy access to kernel interrupts and memory locations, allowing some drivers to be written in userspace.  Note that a small kernel driver is also required for interrupt handling to work properly.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you don’t know what to do here, say N.  </p>\n</details>\n\n<details>\n<summary><n> VFIO Non-Privileged userspace driver framework ----  </n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VFIO是一套无特权用户空间I/O驱动框架，需要有IOMMU虚拟化硬件支持(AMD-Vi/Intel VT-d)。此选项仅用于宿主机内核，VFIO的目标是在IOMMU硬件的帮助下，取代CONFIG_UIO和CONFIG_KVM_DEVICE_ASSIGNMENT。VFIO主要用于编写高效的用户态驱动，以及在虚拟化环境的属主机中高效的实现设备直通(passthrough)且无须root特权，可用于详见”Documentation/vfio.txt”文档。[提示]QEMU 1.3以上版本才能利用VFIO特性。不玩KVM虚拟化的选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/vfio/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VFIO provides a framework for secure userspace device drivers. See Documentation/vfio.txt for more details.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you don’t know what to do here, say N.  </p>\n</details>\n\n<details>\n<summary>[N] Virtualization drivers ----  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个选项仅对PowerPC架构有意义。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/virt/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here to get to see options for device drivers that support virtualization environments.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you say N, all options in this submenu will be skipped and disabled.  </p>\n</details>\n\n<details>\n<summary>Virtio drivers --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅可用于客户机内核的Virtio驱动。Virtio的目标是为各种半虚拟化的虚拟机管理程序(特别是KVM)提供一组通用的模拟设备,目前已实现：network/block/balloon/console/hw_random，未来还会实现更多。下列驱动仅可用在基于lguest或QEMU的半虚拟化客户机中(一般是KVM或XEN)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/virtio/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option is selected by any driver which implements the virtio bus, such as<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONFIG_VIRTIO_PCI,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONFIG_VIRTIO_MMIO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONFIG_RPMSG,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONFIG_S390_GUEST.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>&lt;Y&gt; PCI driver for virtio devices</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;半虚拟化PCI设备驱动，VMM(虚拟机管理程序)必须要有相应的”PCI virtio backend”。基于QEMU的VMM(KVM,Xen)一般都支持该驱动。[提示]由于目前的ABI尚不稳定,建议使用时注意版本匹配。  </li>\n<li><code>&lt;Y&gt; Platform bus driver for memory mapped virtio devices</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支持使用内存映射机制的virtio设备驱动。  </li>\n</ul>\n</details>\n\n<details>\n<summary>Microsoft Hyper-V guest support ----  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅在将此Linux内核作为微软Hyper-V虚拟机的来宾操作系统运行时，才需要开启这里的选项。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/hv/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select this option to run Linux as a Hyper-V client operating system.  </p>\n</details>\n\n<details>\n<summary>[N] Staging drivers ----  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尚在开发中或尚未完成的，目前尚不完善的驱动，切勿用于生产环境。仅供测试人员或者开发者试用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/staging/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option allows you to select a number of drivers that are not of the “normal” Linux kernel quality level.  These drivers are placed here in order to get a wider audience to make use of them.  Please note that these drivers are under heavy development, may or may not work, and may contain userspace interfaces that most likely will be changed in the near future.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using any of these drivers will taint your kernel which might affect support options from both the community, and various commercial support organizations.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you wish to work on these drivers, to help improve them, or to report problems you have with them, please see the driver_name.README file in the drivers/staging/ directory to see what needs to be worked on, and who to contact.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If in doubt, say N here.  </p>\n</details>\n\n<details>\n<summary>[N] Platform support for Goldfish virtual devices ----  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/platform/goldfish/Kconfig<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here to get to see options for the Goldfish virtual platform.This option alone does not add any kernel code. Unless you are building for the Android Goldfish emulator say N here.  </p>\n</details>\n\n<details>\n<summary>[N] Platform support for Chrome hardware ----  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;专用于Google公司的Chromebook笔记本/Chromebox迷你机的设备驱动。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/platform/chrome/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here to get to see options for platform support for various Chromebooks and Chromeboxes. This option alone does not add any kernel code.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you say N, all options in this submenu will be skipped and disabled.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Common Clock Framework —&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CCF(Common Clock Framework)是从3.4内核开始引入的新时钟框架，用于取代原有的”Clock Framework”。详见”Documentation/clk.txt”文档。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/clk/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The common clock framework is a single definition of struct clk, useful across many platforms, as well as an implementation of the clock API in include/linux/clk.h. Architectures utilizing the common struct clk should select this option.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>&lt;Y&gt; Clock driver for TI Palmas devices</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This driver supports TI Palmas devices 32KHz output KG and KG_AUDIO using common clock framework.  </li>\n</ul>\n</details>\n\n<details>\n<summary>[Y] Hardware Spinlock drivers --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;硬件自旋锁驱动。目前仅出现在嵌入式处理器上，自旋锁是保护共享资源的一种锁机制，与互斥锁比较类似，都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个持有者。也就是说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同，对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起申请者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直在循环中”忙等”(占用CPU但无事可做)，直到该自旋锁被释放。”自旋”一词就是因此而得名。自旋锁的使用非常方便，但仅适用于需要极短时间锁定的场合(例如1毫秒)，以避免消耗太多的CPU空等时间。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/hwspinlock/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>&lt;Y&gt; OMAP Hardware Spinlock device</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say y here to support the OMAP Hardware Spinlock device (firstly introduced in OMAP4).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say N.  </li>\n</ul>\n</details>\n\n<details>\n<summary>Clock Source drivers --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”时钟源”驱动，主要面向嵌入式设备。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/clocksource/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>[Y] Enable ARM architected timer event stream generation by default</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option enables support by default for event stream generation based on the ARM architected timer. It is used for waking up CPUs executing the wfe instruction at a frequency represented as a power-of-2 divisor of the clock rate. The behaviour can also be overridden on the command line using the clocksource.arm_arch_timer.evtstream parameter. The main use of the event stream is wfe-based timeouts of userspace locking implementations. It might also be useful for imposing timeout on wfe to safeguard against any programming errors in case an expected event is not generated.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This must be disabled for hardware validation purposes to detect any hardware anomalies of missing events.  </li>\n</ul>\n</details>\n\n<details>\n<summary>-Y- Mailbox Hardware Support --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mailbox硬件支持。这里的”Mailbox”是一个框架，通过消息队列和中断驱动信号，控制芯片上的多个处理器之间的通信。仅用于嵌入式环境。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/mailbox/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mailbox is a framework to control hardware communication between on-chip processors through queued messages and interrupt driven signals. Say Y if your platform supports hardware mailboxes.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>*{Y} OMAP2+ Mailbox framework support</code>  </li>\n<li><code>(256) Mailbox kfifo default buffer size (bytes)</code>  </li>\n</ul>\n</details>\n\n<details>\n<summary>[Y] IOMMU Hardware Support --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IOMMU硬件主要出现在带有I/O虚拟化技术的硬件上，例如带有AMD-Vi或VT-d技术的芯片。IOMMU主要作用：(1)内存地址转换(例如DMA地址转换，scatter-gather)，(2)中断重映射，(3)对设备读取和写入的进行权限检查。这对于提高虚拟化性能和安全性，以及在64位系统上更好的使用32位设备，意义重大。[提示]此选项仅对宿主机有意义，如果此内核要作为来宾操作系统运行，请选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/iommu/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here if you want to compile device drivers for IO Memory Management Units into the kernel. These devices usually allow to remap DMA requests and/or remap interrupts from other devices on the system.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>[Y] OMAP IOMMU Support</code>  </li>\n<li><code>[Y] Export OMAP IOMMU internals in DebugFS</code>  </li>\n</ul>\n</details>\n\n<details>\n<summary>Remoteproc drivers --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现代的SoC芯片一般都会以AMP(非对称多处理器)方式集成多个不同的处理器(例如OMAP5432就在单个芯片上集成了2个Cortex-A15处理器，2个Cortex-M4处理器，1个C64x DSP)，这样就可在不同的处理器上分别运行多个不同的操作系统实例(例如，在2个Cortex-A9处理器上以SMP(对称多处理器)方式运行Linux，在2个Cortex-M3和1个C64x上分别运行不同的实时操作系统)。而Remoteproc驱动对此种场合下的处理器间通信非常有用，详见”Documentation/remoteproc.txt”和”Documentation/rpmsg.txt”文档。目前仅对嵌入式系统有意义，不确定的选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/remoteproc/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>&lt;M&gt; Support for Remote Processor subsystem</code>  </li>\n<li><code>&lt;M&gt; OMAP remoteproc support</code>  </li>\n<li><code>&lt;M&gt; TI PRUSS remoteproc support</code>  </li>\n</ul>\n</details>\n\n<details>\n<summary>Rpmsg drivers --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此项和上面的Remoteproc紧密相关。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/rpmsg/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>&lt;M&gt; Virtio RPMSG bus driver</code>  </li>\n<li><code>&lt;M&gt; rpmsg Remote Procedure Call driver</code>  </li>\n<li><code>&lt;M&gt; PRU RPMsg Communication driver</code>  </li>\n</ul>\n</details>\n\n<details>\n<summary>SOC (System On Chip) specific Drivers --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;专用于单片机的设备驱动，皆为嵌入式系统。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>[Y] TI SOC drivers support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/soc/ti/Kconfig  </li>\n</ul>\n</details>\n\n<details>\n<summary>[N] Generic Dynamic Voltage and Frequency Scaling (DVFS) support ----  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DVFS(动态电压与频率调整)可以根据系统负载动态调节设备的运行频率和电压(对于同一芯片，频率越高，需要的电压也越高)，从而达到节能目的。此选项提供了一个类似CPUfreq(CONFIG_CPU_FREQ)的通用DVFS框架(devfreq)。目前DVFS技术进在嵌入式设备(例如Exynos4/Exynos5)上普遍存在，不确定的选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/devfreq/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A device may have a list of frequencies and voltages available. devfreq, a generic DVFS framework can be registered for a device in order to let the governor provided to devfreq choose an operating frequency based on the device driver’s policy.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Each device may have its own governor and policy. Devfreq can reevaluate the device state periodically and/or based on the notification to “nb”, a notifier block, of devfreq.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Like some CPUs with CPUfreq, a device may have multiple clocks. However, because the clock frequencies of a single device are determined by the single device’s state, an instance of devfreq is attached to a single device and returns a “representative” clock frequency of the device, which is also attached to a device by 1-to-1. The device registering devfreq takes the responsibility to “interpret” the representative frequency and to set its every clock accordingly with the “target” callback given to devfreq.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When OPP is used with the devfreq device, it is recommended to register devfreq’s nb to the OPP’s notifier head.  If OPP is used with the devfreq device, you may use OPP helper functions defined in devfreq.h.  </p>\n</details>\n\n<details>\n<summary>-Y- External Connector Class (extcon) support  --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extcon(外部连接器类)允许用户空间通过sysfs和uevent监控外部连接器，同时也支持多状态外部连接器(也就是拥有多个连接线缆的外部连接器)。例如，一端连接到主机USB端口的多状态外部连接器，一端可以同时连接一条HDMI线缆和一个AC适配器。30针的PDMI连接器也是多状态外部连接器的常见例子。不确定的选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/extcon/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here to enable external connector class (extcon) support. This allows monitoring external connectors by userspace via sysfs and uevent and supports external connectors with multiple states; i.e., an extcon that may have multiple cables attached. For example, an external connector of a device may be used to connect an HDMI cable and a AC adaptor, and to host USB ports. Many of 30-pin connectors including PDMI are also good examples.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>&lt;M&gt; Palmas USB EXTCON support</code>  </li>\n<li><code>&lt;M&gt; USB GPIO extcon support</code>  </li>\n</ul>\n</details>\n\n<details>\n<summary>-Y- Memory Controller drivers --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存控制器驱动。这里所说的”内存控制器”仅指嵌入式SoC系统中的各种控制器，不确定的选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/memory/Kconfig。  </p>\n</details>\n\n<details>\n<summary><y> Industrial I/O support --->  </y></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IIO子系统为各种不同总线(i2c、spi等)的嵌入式传感器驱动提供了一个统一的框架。例如：(1)模数转换器，(2)加速度传感器，(3)陀螺仪，(4)惯性测量仪，(5)电容-数字转换器，(6)压力/温度/光线传感器等等。主要用于工业领域和嵌入式领域，不确定的选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：Industrial I/O support rivers。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The industrial I/O subsystem provides a unified framework for drivers for many different types of embedded sensors using a number of different physical interfaces (i2c, spi, etc).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为主要勾选项：  </p>\n<ul>\n<li><code>-Y- Enable buffer support within IIO</code>  </li>\n<li><code>-Y- Industrial I/O buffering based on kfifo</code>  </li>\n<li><code>-Y- Enable IIO configuration via configfs</code>  </li>\n<li><code>-Y- Enable triggered sampling support</code>  </li>\n<li><code>&lt;Y&gt; Enable software triggers support</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他勾选项以各类芯片为主。  </li>\n</ul>\n</details>\n\n<details>\n<summary><n> Non-Transparent Bridge support ----  </n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PCI-E非透明桥是一个点对点PCI-E总线，用于连接两条对等的PCI-E总线。例如英特尔 Atom S1200处理器， Xeon C5500/C3500 嵌入式处理器等。具体支持的设备号(PCI_DEVICE_ID)可以查看”drivers/ntb/ntb_hw.h”文件或NTB驱动数据库，不确定的选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/ntb/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The PCI-E Non-transparent bridge hardware is a point-to-point PCI-E busconnecting 2 systems. When configured, writes to the device’s PCImapped memory will be mirrored to a buffer on the remote system.  Thentb Linux driver uses this point-to-point communication as a method totransfer data from one system to the other.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say N.  </p>\n</details>\n\n<details>\n<summary>[N] VME bridge support ----  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VME(VersaModule Eurocard)总线是一种通用的计算机总线，主要用于工业控制/军用系统/航空航天/交通运输/医疗等嵌入式领域。而VME桥则是其他总线(例如PCI/PCI-E)到VME总线之间的转换芯片，不确定的选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/vme/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you say Y here you get support for the VME bridge Framework.  </p>\n</details>\n\n<details>\n<summary>-Y- Pulse-Width Modulation (PWM) Support --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PWM(脉宽调制)是将模拟信号转换为脉波的一种技术，在计算机领域，这项技术常被用于控制风扇转速和背光显示器的亮度。很多微型处理器内部都包含有PWM控制器，此选项为所有PWM控制器驱动提供了一个统一的框架，不确定的选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/pwm/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generic Pulse-Width Modulation (PWM) support.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In Pulse-Width Modulation, a variation of the width of pulses in a rectangular pulse signal is used as a means to alter the average power of the signal. Applications include efficient power delivery and voltage regulation. In computer systems, PWMs are commonly used to control fans or the brightness of display backlights.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This framework provides a generic interface to PWM devices within the Linux kernel. On the driver side it provides an API to register and unregister a PWM chip, an abstraction of a PWM controller, that supports one or more PWM devices. Client drivers can request PWM devices and use the generic framework to configure as well as enable and disable them.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This generic framework replaces the legacy PWM framework which allows only a single driver implementing the required API. Not all legacy implementations have been ported to the framework yet. The framework provides an API that is backward compatible with the legacy framework so that existing client drivers continue to work as expected.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say no.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>&lt;M&gt; Freescale FlexTimer Module (FTM) PWM support</code>  </li>\n<li><code>&lt;Y&gt; ECAP PWM support</code>  </li>\n<li><code>&lt;Y&gt; EHRPWM PWM support</code>  </li>\n</ul>\n</details>\n\n<details>\n<summary>IRQ chip support ----  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：/drivers/irqchip/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有选择项。  </p>\n</details>\n\n<details>\n<summary><n> IndustryPack bus support ----  </n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IndustryPack是工业控制领域常用的一种总线，不确定的选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/ipack/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option provides support for the IndustryPack framework.  There are IndustryPack carrier boards, which interface another bus (such as PCI) to an IndustryPack bus, and IndustryPack modules, that are hosted on these buses.  While IndustryPack modules can provide a large variety of functionality, they are most often found in industrial control applications.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say N if unsure.  </p>\n</details>\n\n<details>\n<summary>[Y] Reset Controller Support --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为GPIO总线或者芯片内置的重启控制器提供通用支持，仅用于嵌入式设备。不确定的选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/reset/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generic Reset Controller support.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This framework is designed to abstract reset handling of devices via GPIOs or SoC-internal reset controller modules.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say no.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>&lt;Y&gt; TI SYSCON Reset Driver</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This enables the reset driver support for TI devices with memory-mapped reset registers as part of a syscon device node. If you wish to use the reset framework for such memory-mapped devices, say Y here. Otherwise, say N.  </li>\n</ul>\n</details>\n\n<details>\n<summary><n> FMC support ----  </n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FMC(FPGA Mezzanine Carrier)是一个定义如何将FPGA夹层卡(FPGA Mezzanine Card)连接到主机电路板的接口标准，仅用于嵌入式环境。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/fmc/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FMC (FPGA Mezzanine Carrier) is a mechanical and electrical standard for mezzanine cards that plug into a carrier board. This kernel subsystem supports the matching between carrier and mezzanine based on identifiers stored in the internal I2C EEPROM, as well as having carrier-independent drivers.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The framework was born outside of the kernel and at this time the off-tree code base is more complete.  Code and documentation is at git://ohwr.org/fmc-projects/fmc-bus.git .  </p>\n</details>\n\n<details>\n<summary>PHY Subsystem --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PHY子系统。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/phy/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>-Y- PHY Core</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为内核中的所有PHY设备提供一个通用的PHY框架，不确定的选”N”。内核中若有其他部分依赖它，会自动选上。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This framework is designed to provide a generic interface for PHY devices present in the kernel. This layer will have the generic API by which phy drivers can create PHY using the phy framework and phy users can obtain reference to the PHY. All the users of this framework should select this config.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他为部分芯片的选项。  </li>\n</ul>\n</details>\n\n<details>\n<summary>[N] Generic powercap sysfs driver ----  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”power capping”的意思是允许用户把设备的总功耗限定在指定的范围内，此选项允许内核子系统将”power capping”的设置以sysfs的方式导出到用户空间，不确定的选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/powercap/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The power capping sysfs interface allows kernel subsystems to expose power capping settings to user space in a consistent way.  Usually, it consists of multiple control types that determine which settings may be exposed and power zones representing parts of the system that can be subject to power capping.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If you want this code to be compiled in, say Y here.  </p>\n</details>\n\n<details>\n<summary><n> MCB support ----  </n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MCB(MEN Chameleon Bus)是专用于德国MEN Mikro Elektronik公司的FPGA设备的总线，MEN Mikro Elektronik公司的嵌入式计算主要是为航空/航海/铁路及陆地车辆的应用，以及自动化/电力/能源和医疗用途。不确定的选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/mcb/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MCB (MEN Chameleon Bus) is a Bus specific to MEN Mikroelektronik  FPGA based devices. It is used to identify MCB based IP-Cores within  an FPGA and provide the necessary framework for instantiating drivers for these devices.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If build as a module, the module is called mcb.ko  </p>\n</details>\n\n<details>\n<summary>Performance monitor support --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;专用于ARM架构的CPU性能监控框架。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/perf/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下列为勾选项：  </p>\n<ul>\n<li><code>[Y] ARM PMU framework</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say y if you want to use CPU performance monitors on ARM-based systems.  </li>\n</ul>\n</details>\n\n<details>\n<summary>-Y- Reliability, Availability and Serviceability (RAS) features ----  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RAS(可靠、可用、可维护)是一个计算机硬件术语，可靠性描述系统能够持续正确工作多长时间，可用性描述系统能够正确工作的时间百分比，可维护性描述系统从错误恢复到正常需要多长时间。具有高等级RAS的硬件会有一系列额外的技术保障数据的可靠性与正确性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/ras/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reliability, availability and serviceability (RAS) is a computer hardware engineering term. Computers designed with higher levels of RAS have a multitude of features that protect data integrity and help them stay available for long periods of time without failure.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reliability can be defined as the probability that the system will produce correct outputs up to some given time. Reliability is enhanced by features that help to avoid, detect and repair hardware faults.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Availability is the probability a system is operational at a given time, i.e. the amount of time a device is actually operating as the percentage of total time it should be operating.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serviceability or maintainability is the simplicity and speed with which a system can be repaired or maintained; if the time to repair a failed system increases, then availability will decrease.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that Reliability and Availability are distinct concepts: Reliability is a measure of the ability of a system to function correctly, including avoiding data corruption, whereas Availability measures how often it is available for use, even though it may not be functioning correctly. For example, a server may run forever and so have ideal availability, but may be unreliable, with frequent data corruption.  </p>\n</details>\n\n<details>\n<summary>Android --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安卓平台专用驱动。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/android/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable support for various drivers needed on the Android platform。  </p>\n</details>\n\n<details>\n<summary><n> NVDIMM (Non-Volatile Memory Device) Support ----  </n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NVDIMM(非易失性内存)支持。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/nvdimm/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generic support for non-volatile memory devices including ACPI-6-NFIT defined resources.  On platforms that define an NFIT, or otherwise can discover NVDIMM resources, a libnvdimm bus is registered to advertise PMEM (persistent memory) namespaces (/dev/pmemX) and BLK (sliding mmio window(s)) namespaces (/dev/ndblkX.Y). A PMEM namespace refers to a memory resource that may span multiple DIMMs and support DAX (see CONFIG_DAX).  A BLK namespace refers to an NVDIMM control region which exposes an mmio register set for windowed access mode to non-volatile memory.  </p>\n</details>\n\n<details>\n<summary><n> DAX: direct access to differentiated memory ----  </n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/dax/Kconfig。  </p>\n</details>\n\n<details>\n<summary>-Y- NVMEM Support ----  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NVMEM(非易失性存储器)设备支持，包括：EEPROM、EFUSES……不确定的选”N”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/nvmem/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Support for NVMEM(Non Volatile Memory) devices like EEPROM, EFUSES…<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This framework is designed to provide a generic interface to NVMEM from both the Linux Kernel and the userspace.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This driver can also be built as a module. If so, the module will be called nvmem_core.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If unsure, say no.  </p>\n</details>\n\n<details>\n<summary><n> System Trace Module devices  </n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅供调试使用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/hwtracing/stm/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A System Trace Module (STM) is a device exporting data in System Trace Protocol (STP) format as defined by MIPI STP standards.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Examples of such devices are Intel(R) Trace Hub and Coresight STM.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here to enable System Trace Module device support.  </p>\n</details>\n\n<details>\n<summary><n> Intel(R) Trace Hub controller  </n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仅供调试使用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/hwtracing/intel_th/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Intel(R) Trace Hub (TH) is a set of hardware blocks (subdevices) that produce, switch and output trace data from multiple hardware and software sources over several types of trace output ports encoded in System Trace Protocol (MIPI STPv2) and is intended to perform full system debugging.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option enables intel_th bus and common code used by TH subdevices to interact with each other and hardware and for platform glue layers to drive Intel TH devices.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here to enable Intel(R) Trace Hub controller support.  </p>\n</details>\n\n<details>\n<summary><n> FPGA Configuration Framework ----  </n></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FPGA配置框架支持，仅用于嵌入式系统。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/fpga/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Say Y here if you want support for configuring FPGAs from the kernel.  The FPGA framework adds a FPGA manager class and FPGA manager drivers.  </p>\n</details>\n\n<details>\n<summary>FSI support --->  </summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/fsi/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSI - the FRU Support Interface - is a simple bus for low-level access to POWER-based hardware.  </p>\n</details>\n\n<details>\n<summary><y> Trusted Execution Environment support    </y></summary>  \n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对移动端的安全威胁产生的可信执行环境技术。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/tee/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implements a generic interface towards a Trusted Execution Environment (TEE).  </p>\n<ul>\n<li><code>*TEE drivers ---&gt;</code>  <ul>\n<li><code>&lt;Y&gt; OP-TEE</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：drivers/tee/optee/Kconfig。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This implements the OP-TEE Trusted Execution Environment (TEE) driver.  </li>\n</ul>\n</li>\n</ul>\n</details>","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"kernel","slug":"kernel","permalink":"http://yoursite.com/tags/kernel/"}]},{"title":"AM437 U-Boot修改","date":"2020-05-25T01:12:05.000Z","path":"2020/05/25/AM437 U-boot修改/","content":"<p>为了让ARM启动时从SD-card搬运数据然后转NAND Flash启动，需要重新配置创龙提供的2014版本的Uboot源码文件，主要思路包括：  </p>\n<ul>\n<li>编译UBI相关命令</li>\n<li>配置环境变量</li>\n<li>使用Ubi命令</li>\n<li>制作文件系统镜像</li>\n<li>烧写文件</li>\n<li>添加自定义三取二命令</li>\n<li>修改Uboot初始化配置</li>\n</ul>\n<a id=\"more\"></a>  \n<h2 id=\"U-boot添加Ubi和Ubifs命令\"><a href=\"#U-boot添加Ubi和Ubifs命令\" class=\"headerlink\" title=\"U-boot添加Ubi和Ubifs命令\"></a>U-boot添加Ubi和Ubifs命令</h2><p>在uboot-2014的include/configs/am43xx_evm.h中添加如下声明。  </p>\n<pre><code class=\"C\"><span class=\"comment\">/* #define CONFIG_MTD_DEVICE            1 */</span>\n<span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_MTD_PARTITIONS        1</span>\n<span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_CMD_MTDPARTS         </span>\n<span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_CMD_UBIFS           </span>\n<span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_CMD_UBI         </span>\n<span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_LZO                   1</span>\n<span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONFIG_RBTREE                1</span></code></pre>\n<h2 id=\"配置环境变量\"><a href=\"#配置环境变量\" class=\"headerlink\" title=\"配置环境变量\"></a>配置环境变量</h2><p>在上述头文件中修改nandroot变量：  </p>\n<pre><code class=\"C\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NANDARGS \\</span>\n    <span class=\"string\">\"mtdids=\"</span> MTDIDS_DEFAULT <span class=\"string\">\"\\0\"</span> \\\n    <span class=\"string\">\"mtdparts=\"</span> MTDPARTS_DEFAULT <span class=\"string\">\"\\0\"</span> \\\n    <span class=\"string\">\"nandargs=setenv bootargs console=${console} \"</span> \\\n        <span class=\"string\">\"${optargs} \"</span> \\\n        <span class=\"string\">\"root=${nandroot} \"</span> \\\n        <span class=\"string\">\"rootfstype=${nandrootfstype}\\0\"</span> \\\n    <span class=\"string\">\"nandroot=ubi0:NAND.file-system rw ubi.mtd=NAND.file-system,2048\\0\"</span> \\\n    <span class=\"string\">\"nandrootfstype=ubifs rootwait=1\\0\"</span> \\\n    <span class=\"string\">\"nandboot=echo Booting from nand ...; \"</span> \\\n        <span class=\"string\">\"run nandargs; \"</span> \\\n        <span class=\"string\">\"nand read ${fdtaddr} NAND.u-boot-spl-os; \"</span> \\\n        <span class=\"string\">\"nand read ${loadaddr} NAND.kernel; \"</span> \\\n        <span class=\"string\">\"bootz ${loadaddr} - ${fdtaddr}\\0\"</span>\n<span class=\"meta\">#<span class=\"meta-keyword\">define</span> NANDBOOT            <span class=\"meta-string\">\"run nandboot; \"</span></span></code></pre>\n<p>其中，ubi0:NAND.file-system是由分区表决定的，ubi0指设备名，NAND.file-system是分区名，rw指分区可读可写，2048代表VID offset，不可或缺，下面需要使用这个变量。<br>分区表也在头文件中定义：  </p>\n<pre><code class=\"C\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MTDPARTS_DEFAULT        <span class=\"meta-string\">\"mtdparts=nand.0:\"</span> \\</span>\n                    <span class=\"string\">\"256k(NAND.SPL),\"</span> \\\n                    <span class=\"string\">\"256k(NAND.SPL.backup1),\"</span> \\\n                    <span class=\"string\">\"256k(NAND.SPL.backup2),\"</span> \\\n                    <span class=\"string\">\"256k(NAND.SPL.backup3),\"</span> \\\n                    <span class=\"string\">\"512k(NAND.u-boot-spl-os),\"</span> \\\n                    <span class=\"string\">\"1m(NAND.u-boot),\"</span> \\\n                    <span class=\"string\">\"256k(NAND.u-boot-env),\"</span> \\\n                    <span class=\"string\">\"256k(NAND.u-boot-env.backup1),\"</span> \\\n                    <span class=\"string\">\"7m(NAND.kernel),\"</span> \\\n                    <span class=\"string\">\"-(NAND.file-system)\"</span></code></pre>\n<p>注意mtd计数从0开始，因此文件系统分区为mtd=9。分区名称一定要与nandroot变量中一致，否则一定会出现无法加载的错误。  </p>\n<h2 id=\"使用UBI命令\"><a href=\"#使用UBI命令\" class=\"headerlink\" title=\"使用UBI命令\"></a>使用UBI命令</h2><p>UBI包括ubi part、ubi create、ubi write、ubi info (l)等命令。进入uboot后使用mtd可以查看分区表，接下来运行：  </p>\n<pre><code class=\"C\">nand erase.part NAND.file-system       <span class=\"comment\">//擦除分区</span>\nubi part NAND.file-system <span class=\"number\">2048</span>        <span class=\"comment\">//2048与环境变量一致，否则默认512</span>\nubi create NAND.file-system           <span class=\"comment\">//制作卷</span></code></pre>\n<p>使用ubi info l命令查看分区，注意usable_leb_size参数为126976，在制作镜像要用。  </p>\n<h2 id=\"制作文件系统镜像\"><a href=\"#制作文件系统镜像\" class=\"headerlink\" title=\"制作文件系统镜像\"></a>制作文件系统镜像</h2><p>在rootfs文件系统上一级运行如下命令，并将ubifs.img拷贝到sd card的rootfs/boot路径下。  </p>\n<pre><code class=\"C\">sudo mkfs.ubifs -r ./rootfs/ -m <span class=\"number\">2048</span> -e <span class=\"number\">126976</span> -c <span class=\"number\">4300</span> -o ~/ubifs.img</code></pre>\n<p>注意-c, –max-leb-cnt=COUNT  maximum logical erase block count，主要和容量大小有关，如果太小会提示设置一个合理值。另外-e, –leb-size=SIZE:logical erase block size设置为126976。  </p>\n<h2 id=\"烧写文件\"><a href=\"#烧写文件\" class=\"headerlink\" title=\"烧写文件\"></a>烧写文件</h2><p>将开发板设置为优先从SDIO（MMC 0）启动，启动进入uboot命令行，运行：  </p>\n<pre><code class=\"C\">env <span class=\"keyword\">default</span> -a</code></pre>\n<p>上述步骤还原编译的环境变量，下面依次运行下面指令（注意事先擦除各分区）。  </p>\n<pre><code class=\"C\"><span class=\"comment\">//烧写MLO至NAND.SPL，烧写u-boot.img至NAND.u-boot。</span>\nload mmc <span class=\"number\">0</span>:<span class=\"number\">1</span> <span class=\"number\">0x80000000</span> /MLO                    <span class=\"comment\">//load MLO from sdcard</span>\nnand write <span class=\"number\">0x80000000</span> <span class=\"number\">0x00000000</span> <span class=\"number\">0x00016f30</span>     \nnand write <span class=\"number\">0x80000000</span> <span class=\"number\">0x00040000</span> <span class=\"number\">0x00016f30</span>\nnand write <span class=\"number\">0x80000000</span> <span class=\"number\">0x00080000</span> <span class=\"number\">0x00016f30</span>\nnand write <span class=\"number\">0x80000000</span> <span class=\"number\">0x000c0000</span> <span class=\"number\">0x00016f30</span>\nload mmc <span class=\"number\">0</span>:<span class=\"number\">1</span> <span class=\"number\">0x90000000</span> /u-boot.img              <span class=\"comment\">//load u-boot.img from sdcard</span>\nnand write <span class=\"number\">0x90000000</span> <span class=\"number\">0x00180000</span> <span class=\"number\">0x000817e0</span>\nload mmc <span class=\"number\">0</span>:<span class=\"number\">2</span> <span class=\"number\">0x88000000</span> /boot/am437x-gp-evm.dtb   <span class=\"comment\">//load dtb from sdcard</span>\n\n<span class=\"comment\">//烧写zImage至NAND.kernel，设备树至NAND.u-boot-spl-os。</span>\nload mmc <span class=\"number\">0</span>:<span class=\"number\">2</span> <span class=\"number\">0x82000000</span> /boot/zImage             <span class=\"comment\">//load zImage from sdcard</span>\nload mmc <span class=\"number\">0</span>:<span class=\"number\">2</span> <span class=\"number\">0x88080000</span> /boot/rootfs.tar.gz         <span class=\"comment\">//load gz rootf from sdcard </span>\nnand write <span class=\"number\">0x82000000</span> <span class=\"number\">0x00300000</span> <span class=\"number\">0x00461568</span>     <span class=\"comment\">//sizeof zImage  4593000</span>\nnand write <span class=\"number\">0x88000000</span> <span class=\"number\">0x00100000</span> <span class=\"number\">0x0000c774</span>     <span class=\"comment\">//sizeof dtb   51060</span>\n\n<span class=\"comment\">//烧写ubifs镜像，UBI分区的步骤需要先做一遍。</span>\nload mmc <span class=\"number\">0</span>:<span class=\"number\">2</span> <span class=\"number\">0x88080000</span> /boot/ubifs.img\nubi write <span class=\"number\">0x88080000</span> NAND.file-system <span class=\"number\">0x12414000</span></code></pre>\n<p>设置nandboot：  </p>\n<pre><code class=\"C\">setenv bootcmd nand read <span class=\"number\">0x88000000</span> NAND.u-boot-spl-os\\;nand read <span class=\"number\">0x82000000</span> NAND.kernel\\;bootz <span class=\"number\">0x82000000</span> - <span class=\"number\">0x88000000</span></code></pre>\n<p>主要从相关分区读取文件并保存到内存相应地址中，0x88000000和0x82000000也在环境变量中定义的。不赘述。<br>保存环境变量：  </p>\n<pre><code class=\"C\">saveenv</code></pre>\n<p>关闭电源，设置从nandflash优先启动并拔出sdcard，上电后开发板从nandflash启动。  </p>\n","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"u-boot","slug":"u-boot","permalink":"http://yoursite.com/tags/u-boot/"}]},{"title":"阿里云物联网开发入门篇","date":"2019-11-08T06:08:05.000Z","path":"2019/11/08/阿里云物联网开发入门篇/","content":"<h2 id=\"数据可视化效果预览\"><a href=\"#数据可视化效果预览\" class=\"headerlink\" title=\"数据可视化效果预览\"></a>数据可视化效果预览</h2><p><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/%E6%B9%BF%E5%BA%A6.jpeg\" alt=\"avatar\"></p>\n<a id=\"more\"></a>  \n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.yuque.com/jingzi-m1gex/kb\" target=\"_blank\" rel=\"noopener\">语雀–基于Arduino的物联网开发</a></p>\n","tags":[{"name":"Adruino","slug":"Adruino","permalink":"http://yoursite.com/tags/Adruino/"},{"name":"Aliyun","slug":"Aliyun","permalink":"http://yoursite.com/tags/Aliyun/"}]},{"title":"AM5728配置DMM_LISA_MAP修改内存工作模式","date":"2019-11-08T05:30:34.000Z","path":"2019/11/08/AM5728内存配置/","content":"<p>在测试AM5728时发现，ARM读完SD card中的MLO文件后没有后续操作，推断是由于我们的硬件更改导致的内存加载出错，研究TI给出的《AM572x Technical Reference Manual》，需要配置相关的寄存器。</p>\n<h3 id=\"硬件更改\"><a href=\"#硬件更改\" class=\"headerlink\" title=\"硬件更改\"></a>硬件更改</h3><p>原TI AM5728使用EMIF0接口和EMIF1接口，使用interleaving模式配置2GB的内存，每个EMIF接口连接两个512MB的内存芯片。为降低功耗，平衡性能和成本，现更改为单EMIF接口连接两个256MB的芯片，并且在ECC内存接口增设ECC DDR保证内存运行的可靠性。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>EMIF1</th>\n<th>EMIF2</th>\n<th>ECC</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>TI AM5728</td>\n<td>2 x 512MB</td>\n<td>2 x 512MB</td>\n<td>/</td>\n</tr>\n<tr>\n<td>ZHX星务主板</td>\n<td>2 x 256MB</td>\n<td>/</td>\n<td>128MB</td>\n</tr>\n</tbody></table>\n<a id=\"more\"></a>  \n<h3 id=\"寄存器详解\"><a href=\"#寄存器详解\" class=\"headerlink\" title=\"寄存器详解\"></a>寄存器详解</h3><p>根据TRM 15.2.3.5.1.2所述，在系统启动时，需要合理更改DDR的寄存器配置，主要有以下四种：</p>\n<ul>\n<li>DMM_LISA_MAP_3</li>\n<li>DMM_LISA_MAP_2</li>\n<li>DMM_LISA_MAP_1</li>\n<li>DMM_LISA_MAP_0</li>\n</ul>\n<p>参考DMM_LISA_MAP_i的寄存器表格可以重置DDR的启动功能和映射大小。<br><img src=\"https://cdn.nlark.com/yuque/0/2019/png/291611/1573191981268-343a5467-aebe-45af-9171-7a15daf9a55c.png?x-oss-process=image/resize,w_747\" alt=\"avatar\"></p>\n<p>上图为寄存器的内容，SYS_SIZE为配置的内存总大小，SDRC_MAP为interleaving的配置方式，可选只使用EMIF1、只使用EMIF2、或者EMIF1和EMIF2交叉存取的方式，如果工作在非交叉存取的模式，SDRC_INTL不需要配置。  </p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/291611/1573191983828-5404393f-a212-4495-8873-782d41650e88.png?x-oss-process=image/resize,w_747\" alt=\"avatar\"></p>\n<h3 id=\"U-BOOT配置寄存器\"><a href=\"#U-BOOT配置寄存器\" class=\"headerlink\" title=\"U-BOOT配置寄存器\"></a>U-BOOT配置寄存器</h3><p>在TI-SDK的U-BOOT源码board/ti/board.c中，以下程序完成了对TI AM5728 EVM的内存配置：  </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dmm_lisa_map_regs</span> <span class=\"title\">beagle_x15_lisa_regs</span> = &#123;</span></span><br><span class=\"line\">\t.dmm_lisa_map_3 = <span class=\"number\">0x80740300</span>,</span><br><span class=\"line\">\t.is_ma_present  = <span class=\"number\">0x1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">emif_get_dmm_regs</span><span class=\"params\">(<span class=\"keyword\">const</span> struct dmm_lisa_map_regs **dmm_lisa_regs)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (board_is_am571x_idk())</span><br><span class=\"line\">\t\t*dmm_lisa_regs = &amp;am571x_idk_lisa_regs;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t*dmm_lisa_regs = &amp;beagle_x15_lisa_regs;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>根据原设置使用寄存器3的内容0x8074 0300可以看出内存的配置如下：<br><img src=\"https://cdn.nlark.com/yuque/0/2019/png/291611/1573191991095-65719886-eeb8-4158-a847-0c145284a414.png\" alt=\"avatar\"><br>根据硬件配置，我们的内存设置如下：<br><img src=\"https://cdn.nlark.com/yuque/0/2019/png/291611/1573191994187-8f80fbe3-188b-4c56-b8d6-6e347258e9d2.png\" alt=\"avatar\"><br>参考：<a href=\"http://processors.wiki.ti.com/index.php?oldid=127545&title=EZSDK_Memory_Map&keyMatch=MEMORY%20MAP&tisearch=Search-CN-everything\" target=\"_blank\" rel=\"noopener\">TI wiki</a>  </p>\n","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"ddr","slug":"ddr","permalink":"http://yoursite.com/tags/ddr/"}]},{"title":"C++学习笔记--菜鸟教程","date":"2019-09-17T10:53:34.000Z","path":"2019/09/17/C-学习笔记-菜鸟教程/","content":"<p>VS2015编译按ctrl+F5<br>网页地址<a href=\"https://www.runoob.com/cplusplus/cpp-tutorial.html\" target=\"_blank\" rel=\"noopener\">菜鸟教程</a></p>\n<a id=\"more\"></a>  \n<h2 id=\"helloworld\"><a href=\"#helloworld\" class=\"headerlink\" title=\"helloworld\"></a>helloworld</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">       <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello, world!\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">       <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello, world!\"</span> &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>“\\n” 表示内容为一个回车符的字符串。std::endl 是流操作子，输出的作用和输出 “\\n” 类似，但可能略有区别。std::endl 输出一个换行符，并立即刷新缓冲区。例如:</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>相当于:</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span> &lt;&lt; <span class=\"built_in\">std</span>::flush;</span><br><span class=\"line\">或者</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">'\\n'</span>; <span class=\"built_in\">std</span>::fflush(<span class=\"built_in\">stdout</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<blockquote>\n<p>由于流操作符 &lt;&lt; 的重载，对于 ‘\\n’ 和 “\\n”，输出效果相同。对于有输出缓冲的流（例如cout、clog），如果不手动进行缓冲区刷新操作，将在缓冲区满后自动刷新输出。不过对于 cout 来说（相对于文件输出流等），缓冲一般体现得并不明显。但是必要情况下使用 endl 代替 ‘\\n’ 一般是个好习惯。<br>对于无缓冲的流（例如标准错误输出流cerr），刷新是不必要的，可以直接使用 ‘\\n’。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>真正的开发过程中， 尽量避免使用 using namespace std; 等直接引入整个命名空间，否则会因为命名空间污染导致很多不必要的问题， 比如自己写的某个函数，名称正好和 std 中的一样， 编译器会不知道使用哪一个， 引起编译报错， 建议使用:</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Hello World\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>等直接由命名空间组合起来的全称。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>声明一个命名空间的意思。命名空间在多人合作的时候很有用，因为你定义了变量 a，别人也定义了变量 a，这样就重复定义了。如果你在自己的命名空间中定义了 a，别人在别人的命名空间中定义了 a，这样就不重复了，比如：</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> xx;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> yy;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>xx::a 和 yy::a 虽然都叫 a，但是不是同一个变量。std 是系统标准的命名空间，为了和用户定义的名字不重复，所以它声明在 std 这个命名空间中。另外，这个空间也像一个大包一样，包括了系统所有的支持。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>cout 流速度较慢，如果速度过慢可以用 &lt;stdio.h&gt; 库中的 printf() 格式化输出函数，不需要 using namespace std;。它的示例为：</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World!\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"C-基本语法\"><a href=\"#C-基本语法\" class=\"headerlink\" title=\"C++基本语法\"></a>C++基本语法</h2><p>基本等同于C；<br>头文件：include <iostream><br>新增了命名空间 namespace<br>输出可以使用cout流</iostream></p>\n<h2 id=\"C-注释\"><a href=\"#C-注释\" class=\"headerlink\" title=\"C++注释\"></a>C++注释</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 这是注释 */</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* C++ 注释也可以 </span></span><br><span class=\"line\"><span class=\"comment\">* 跨行 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//到行末</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> 0</span></span><br><span class=\"line\">   code <span class=\"comment\">//不执行，等同于注释，改为 #if 1 调试时执行</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"C-数据类型\"><a href=\"#C-数据类型\" class=\"headerlink\" title=\"C++数据类型\"></a>C++数据类型</h2><h3 id=\"长度\"><a href=\"#长度\" class=\"headerlink\" title=\"长度\"></a>长度</h3><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>长度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>char</td>\n<td>1个字节</td>\n</tr>\n<tr>\n<td>int</td>\n<td>4个字节</td>\n</tr>\n<tr>\n<td>unsigned int</td>\n<td>4字节</td>\n</tr>\n<tr>\n<td>long int</td>\n<td>8字节</td>\n</tr>\n<tr>\n<td>float</td>\n<td>4个字节</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8个字节</td>\n</tr>\n<tr>\n<td>### typedef</td>\n<td></td>\n</tr>\n<tr>\n<td>typedef 为一个已有的类型取一个新的名字。</td>\n<td></td>\n</tr>\n</tbody></table>\n<hr>\n<blockquote>\n<p>typedef 可以声明各种类型名，但不能用来定义变量。用 typedef 可以声明数组类型、字符串类型，使用比较方便。<br>用typedef只是对已经存在的类型增加一个类型名，而没有创造新的类型。<br>当在不同源文件中用到同一类型数据（尤其是像数组、指针、结构体、共用体等类型数据）时，常用 typedef 声明一些数据类型，把它们单独放在一个头文件中，然后在需要用到它们的文件中用 ＃include 命令把它们包含进来，以提高编程效率。使用 typedef 有利于程序的通用与移植。有时程序会依赖于硬件特性，用 typedef 便于移植。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>size_t</strong> 是一种 整型 类型，里面保存的是一个整数，就像 int, long 那样。这种整数用来记录一个大小(size)。size_t 的全称应该是 size type，就是说<strong>一种用来记录大小的数据类型</strong>。<br>通常我们用 sizeof(XXX) 操作，这个操作所得到的结果就是 size_t 类型。因为 size_t 类型的数据其实是保存了一个整数，所以它也可以做加减乘除，也可以转化为 int 并赋值给 int 类型的变量。<br>例如：<strong>typedef int size_t;</strong> 定义了 size_t 为整型。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>typedef 与 #define 的区别：</p>\n<ol>\n<li>执行时间不同<br>关键字 typedef 在编译阶段有效，由于是在编译阶段，因此 typedef 有类型检查的功能。<br>#define 则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查。</li>\n<li>功能有差异<br>typedef 用来定义类型的别名，定义与平台无关的数据类型，与 struct 的结合使用等。<br>#define 不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</li>\n<li>作用域不同<br>#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而 typedef 有自己的作用域。</li>\n</ol>\n</blockquote>\n<hr>\n<h3 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> 枚举名&#123; </span><br><span class=\"line\">     标识符[=整型常数], </span><br><span class=\"line\">     标识符[=整型常数], </span><br><span class=\"line\">... </span><br><span class=\"line\">    标识符[=整型常数]</span><br><span class=\"line\">&#125; 枚举变量;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> color &#123; red, green, blue &#125; c;</span><br><span class=\"line\">c = blue;</span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> color &#123; red, green=<span class=\"number\">5</span>, blue &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。</p>\n<h2 id=\"C-变量类型\"><a href=\"#C-变量类型\" class=\"headerlink\" title=\"C++变量类型\"></a>C++变量类型</h2><p><strong>bool char int float double void wchar_t 枚举 指针 数组 数据结构 类</strong><br>可以使用 extern 关键字在任何地方<code>声明</code>一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。<br>同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。<strong>定义包含了声明，但是声明不包含定义。</strong></p>\n<hr>\n<blockquote>\n<p>C/C++ 编译 cpp 文件是从上往下编译，所以 main 函数里面调用其他函数时，如果其他函数在 main 函数的下面，则要在 main 函数上面先声明这个函数。或者把 main 函数放在最下面，这个不仅限于 main 函数，其他函数的调用都是如此。被调用的函数要在调用的函数之前声明。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>变量的类型间是可以互相转换的，转换又分为自动转换和强制转换。<br><strong>自动转换规则</strong>：</p>\n<blockquote>\n<ol>\n<li>若参与运算量的类型不同，则先转换成同一类型，然后进行运算。</li>\n<li>转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算。<br>a、若两种类型的字节数不同，转换成字节数高的类型<br>b、若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型 </li>\n<li>所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。 </li>\n<li>char型和short型参与运算时，必须先转换成int型。 </li>\n<li>在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度:</li>\n</ol>\n</blockquote>\n<p><strong>强制转换规则</strong>：</p>\n<blockquote>\n<p>强制类型转换是通过类型转换运算来实现的。其一般形式为：（类型说明符）（表达式）其功能是把表达式的运算结果强制转换成类型说明符所表示的类型</p>\n</blockquote>\n</blockquote>\n<hr>\n<h2 id=\"C-作用域\"><a href=\"#C-作用域\" class=\"headerlink\" title=\"C++作用域\"></a>C++作用域</h2><p>作用域是程序的一个区域，一般来说有三个地方可以定义变量：</p>\n<ul>\n<li>在函数或一个代码块内部声明的变量，称为局部变量。</li>\n<li>在函数参数的定义中声明的变量，称为形式参数。</li>\n<li>在所有函数外部声明的变量，称为全局变量。</li>\n</ul>\n<p>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。</p>\n<h3 id=\"全局变量默认初始值\"><a href=\"#全局变量默认初始值\" class=\"headerlink\" title=\"全局变量默认初始值\"></a>全局变量默认初始值</h3><table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>初始默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int</td>\n<td>0</td>\n</tr>\n<tr>\n<td>char</td>\n<td>‘\\0’</td>\n</tr>\n<tr>\n<td>float</td>\n<td>0</td>\n</tr>\n<tr>\n<td>double</td>\n<td>0</td>\n</tr>\n<tr>\n<td>pointer</td>\n<td>NULL</td>\n</tr>\n</tbody></table>\n<hr>\n<blockquote>\n<p>在一个函数体内可以存在重名的变量，前提是它们的作用域不同。例如代码块内定义的同名变量在块执行结束后释放。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围，说到底 static 还是用来隐藏的。虽然这种用法不常见。<br>PS：如果作为 static 局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。<br>例如static int a = 10，在函数内部定义，那么下次进入函数，a为上次操作之后的值，效果等同于全局变量。但是函数中的a并不能在函数外部被调用。<br><strong>静态变量</strong>和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。<br>全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。<br><strong>静态全局变量</strong>也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。<br><strong>Tips</strong>:</p>\n<ol>\n<li>若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；</li>\n<li>若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；</li>\n<li>设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；</li>\n<li>如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带“内部存储器”功能的的函数)</li>\n<li>函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p><strong>静态函数</strong>：在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。如果在一个源文件中定义的函数，只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用，这种函数也称为内部函数。定义一个内部函数，只需在函数类型前再加一个“static”关键字即可。</p>\n</blockquote>\n<hr>\n<h2 id=\"C-常量\"><a href=\"#C-常量\" class=\"headerlink\" title=\"C++常量\"></a>C++常量</h2><p>定义常量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> identifier value</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> type variable = value;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>定义成 const 后的常量，程序对其中只能读不能修改。<br>宏定义结束不加分号<br>宏定义 #define 和常量 const 的区别</p>\n<ol>\n<li>类型和安全检查不同<br>宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；<br>const常量是常量的声明，有类型区别，需要在编译阶段进行类型检查</li>\n<li>编译器处理不同<br>宏定义是一个”编译时”概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期；const常量是一个”运行时”概念，在程序运行使用，类似于一个只读行数据</li>\n<li>存储方式不同<br>宏定义是直接替换，不会分配内存，存储与程序的代码段中；const常量需要进行内存分配，存储与程序的数据段中</li>\n<li>定义域不同<br>宏定义不受定义域限制；const常量局限于代码块内</li>\n<li>是否可以做函数参数<br>宏定义不能作为参数传递给函数const常量可以在函数的参数列表中出现</li>\n<li>定义后能否取消<br>宏定义可以通过#undef来使之前的宏定义失效const常量定义后将在定义域内永久有效</li>\n</ol>\n</blockquote>\n<hr>\n<blockquote>\n<p><a href=\"https://www.runoob.com/w3cnote/const-char.html\" target=\"_blank\" rel=\"noopener\">const char<em>, char const</em>, char*const 的区别</a></p>\n</blockquote>\n<hr>\n<h2 id=\"C-修饰符类型\"><a href=\"#C-修饰符类型\" class=\"headerlink\" title=\"C++修饰符类型\"></a>C++修饰符类型</h2><p>在int、char、double前田间修饰符，包括signed、unsigned、long、short，在修饰int时，int可以省略；</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">short</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// 有符号短整数 </span></span><br><span class=\"line\"><span class=\"keyword\">short</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> j; <span class=\"comment\">// 无符号短整数</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<blockquote>\n<p>对于无符号化为有符号的位数运算，采取 N-2^n 的计算方法，n 取决于定义的数据类型 int、short、char、long int 等等，N 为无符号数的数值，例如文中的 N=50000，short 为 16 位，计算方法为 50000-2^16 得到 -15536。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>16 位整数（短整数）的情况下，十进制 50000 就是二进制 11000011 01010000 但在有符号的情况下，二进制最左边的 1，代表这整个数字是负数但是电脑是以补码形式来表示数字的，要获得原本的数字，首先要把整个二进制数 - 11100001101010000 - 1 = ‭1100001101001111‬ 然后，在把答案取反码 not ‭1100001101001111‬ = ‭0011110010110000‬ 把最终答案变成十进制，就是 15536 所以，一开始的二进制数 11000011 01010000，在有符号的情况下代表的就是 -15536。</p>\n</blockquote>\n<hr>\n<h2 id=\"C-存储类\"><a href=\"#C-存储类\" class=\"headerlink\" title=\"C++ 存储类\"></a>C++ 存储类</h2><p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。</p>\n<table>\n<thead>\n<tr>\n<th><strong>存储类</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>auto</td>\n<td>auto 关键字用于两种情况：声明变量时根据初始化表达式<code>自动推断</code>该变量的类型、声明函数时函数返回值的占位符。</td>\n</tr>\n<tr>\n<td>register</td>\n<td>register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</td>\n</tr>\n<tr>\n<td>static</td>\n<td>static 存储类指示编译器在程序的生命周期内保持<code>局部变量</code>的存在，而<strong>不需要在每次它进入和离开作用域时进行创建和销毁。使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</strong>。static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在<code>声明它的文件内</code>。</td>\n</tr>\n<tr>\n<td>extern</td>\n<td>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。<code>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。</code>可以这么理解，<strong>extern 是用来在另一个文件中声明一个全局变量或函数。extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候。</strong></td>\n</tr>\n<tr>\n<td>thread_local</td>\n<td>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。thread_local 说明符可以与 static 或 extern 合并。可以将 thread_local 仅应用于数据声明和定义，<strong>thread_local 不能用于函数声明或定义</strong>。</td>\n</tr>\n</tbody></table>\n<hr>\n<blockquote>\n<p>静态局部变量有以下特点：</p>\n<ul>\n<li>该变量在全局数据区分配内存；</li>\n<li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li>\n<li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li>\n<li>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<ol>\n<li>寄存器存在于CPU中，速度很快，数目有限存储器就是内存，速度稍慢，但数量很大。计算机做运算时，必须将数据读入寄存器才能运算。</li>\n<li>存储器包括寄存器，存储器有 ROM 和 RAM</li>\n</ol>\n</blockquote>\n<hr>\n<h2 id=\"C-运算符\"><a href=\"#C-运算符\" class=\"headerlink\" title=\"C++运算符\"></a>C++运算符</h2><h3 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h3><p>A =10, B =20.</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>把两个操作数相加</td>\n<td>A + B 将得到 30</td>\n</tr>\n<tr>\n<td>-</td>\n<td>从第一个操作数中减去第二个操作数</td>\n<td>A - B 将得到 -10</td>\n</tr>\n<tr>\n<td>*</td>\n<td>把两个操作数相乘</td>\n<td>A * B 将得到 200</td>\n</tr>\n<tr>\n<td>/</td>\n<td>分子除以分母</td>\n<td>B / A 将得到 2</td>\n</tr>\n<tr>\n<td>%</td>\n<td>取模运算符，整除后的余数</td>\n<td>B % A 将得到 0</td>\n</tr>\n<tr>\n<td>++</td>\n<td>自增运算符，整数值增加 1</td>\n<td>A++ 将得到 11</td>\n</tr>\n<tr>\n<td>–</td>\n<td>自减运算符，整数值减少 1</td>\n<td>A– 将得到 9</td>\n</tr>\n</tbody></table>\n<hr>\n<blockquote>\n<p>++d 是先加，先对 d 的值加 1，再使用 d 的值执行该行命令。<br>d++ 是后加，先使用 d 的值执行该行命令，执行完后再对 d 的值加 1。</p>\n</blockquote>\n<hr>\n<h3 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3><p>A =10, B =20.</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>==</td>\n<td>检查两个操作数的值是否相等，如果相等则条件为真。</td>\n<td>(A == B) 不为真。</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>\n<td>(A != B) 为真。</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>\n<td>(A &gt; B) 不为真。</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>\n<td>(A &lt; B) 为真。</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>\n<td>(A &gt;= B) 不为真。</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>\n<td>(A &lt;= B) 为真。</td>\n</tr>\n</tbody></table>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><p>A =1, B =0.</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;&amp;</td>\n<td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>\n<td>(A &amp;&amp; B) 为假。</td>\n</tr>\n<tr>\n<td>||</td>\n<td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>\n<td>(A</td>\n</tr>\n<tr>\n<td>!</td>\n<td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>\n<td>!(A &amp;&amp; B) 为真。</td>\n</tr>\n</tbody></table>\n<h3 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h3><p>A = 60 = (0011 1100)<br>B = 13 = (0000 1101)</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;</td>\n<td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>\n<td>(A &amp; B) 将得到 12，即为 0000 1100</td>\n</tr>\n<tr>\n<td>|</td>\n<td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>\n<td>(A | B) 将得到 61，即为 0011 1101</td>\n</tr>\n<tr>\n<td>^</td>\n<td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>\n<td>(A ^ B) 将得到 49，即为 0011 0001</td>\n</tr>\n<tr>\n<td>~</td>\n<td>二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。</td>\n<td>(~A ) 将得到 -61，即为 1100 0011</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>\n<td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>\n<td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td>\n</tr>\n</tbody></table>\n<h3 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h3><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>=</td>\n<td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td>\n<td>C = A + B 将把 A + B 的值赋给 C</td>\n</tr>\n<tr>\n<td>+=</td>\n<td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>\n<td>C += A 相当于 C = C + A</td>\n</tr>\n<tr>\n<td>-=</td>\n<td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>\n<td>C -= A 相当于 C = C - A</td>\n</tr>\n<tr>\n<td>*=</td>\n<td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>\n<td>C *= A 相当于 C = C * A</td>\n</tr>\n<tr>\n<td>/=</td>\n<td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>\n<td>C /= A 相当于 C = C / A</td>\n</tr>\n<tr>\n<td>%=</td>\n<td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>\n<td>C %= A 相当于 C = C % A</td>\n</tr>\n<tr>\n<td>&lt;&lt;=</td>\n<td>左移且赋值运算符</td>\n<td>C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td>\n</tr>\n<tr>\n<td>&gt;&gt;=</td>\n<td>右移且赋值运算符</td>\n<td>C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td>\n</tr>\n<tr>\n<td>&amp;=</td>\n<td>按位与且赋值运算符</td>\n<td>C &amp;= 2 等同于 C = C &amp; 2</td>\n</tr>\n<tr>\n<td>^=</td>\n<td>按位异或且赋值运算符</td>\n<td>C ^= 2 等同于 C = C ^ 2</td>\n</tr>\n<tr>\n<td>|=</td>\n<td>按位或且赋值运算符</td>\n<td>C |= 2 等同于 C = C | 2</td>\n</tr>\n</tbody></table>\n<h3 id=\"杂项运算符\"><a href=\"#杂项运算符\" class=\"headerlink\" title=\"杂项运算符\"></a>杂项运算符</h3><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>sizeof</td>\n<td>sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。</td>\n</tr>\n<tr>\n<td>Condition ? X : Y</td>\n<td>条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。</td>\n</tr>\n<tr>\n<td>,</td>\n<td>逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</td>\n</tr>\n<tr>\n<td>.（点）和 -&gt;（箭头）</td>\n<td>成员运算符用于引用类、结构和共用体的成员。</td>\n</tr>\n<tr>\n<td>Cast</td>\n<td>强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>指针运算符 &amp; 返回变量的地址。例如 &a; 将给出变量的实际地址。</td>\n</tr>\n<tr>\n<td>*</td>\n<td>指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。</td>\n</tr>\n</tbody></table>\n<h3 id=\"运算优先级\"><a href=\"#运算优先级\" class=\"headerlink\" title=\"运算优先级\"></a>运算优先级</h3><blockquote>\n<p>条件 ?: 从右到左</p>\n</blockquote>\n<h2 id=\"C-类与对象\"><a href=\"#C-类与对象\" class=\"headerlink\" title=\"C++类与对象\"></a>C++类与对象</h2><h3 id=\"定义类\"><a href=\"#定义类\" class=\"headerlink\" title=\"定义类\"></a>定义类</h3><p>C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。<br>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。<br>类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 class 定义 Box 数据类型，如下所示：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Box</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span>: </span><br><span class=\"line\">        <span class=\"keyword\">double</span> length; <span class=\"comment\">// 盒子的长度 </span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> breadth; <span class=\"comment\">// 盒子的宽度 </span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> height; <span class=\"comment\">// 盒子的高度 </span></span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>关键字 public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。也可以指定类的成员为 private 或 protected。</p>\n<h3 id=\"实例化对象\"><a href=\"#实例化对象\" class=\"headerlink\" title=\"实例化对象\"></a>实例化对象</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Box Box1; <span class=\"comment\">// 声明 Box1，类型为 Box </span></span><br><span class=\"line\">Box Box2; <span class=\"comment\">// 声明 Box2，类型为 Box</span></span><br></pre></td></tr></table></figure>\n\n","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"socket进程间通信及喂狗框架","date":"2019-09-13T15:24:34.248Z","path":"2019/09/13/socket进程间通信及喂狗框架/","content":"<p>简单的服务器完成以下功能：  </p>\n<ol>\n<li>与客户端创建连接建立握手  </li>\n<li>转发客户端的消息，发向指定客户端  </li>\n<li>完成客户端喂狗信号的处理  <a id=\"more\"></a>  \n\n</li>\n</ol>\n<h2 id=\"库函数\"><a href=\"#库函数\" class=\"headerlink\" title=\"库函数\"></a>库函数</h2><h3 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：<a href=\"https://blog.csdn.net/jyy305/article/details/73012706\" target=\"_blank\" rel=\"noopener\">socket编程以及select、epoll、poll示例详解</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket这个词可以表示很多概念，在TCP/IP协议中“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程，“IP+端口号”就称为socket。在TCP协议中，建立连接的两个进程各自有一个socket来标识，那么两个socket组成的socket pair就唯一标识一个连接。  </p>\n<blockquote>\n<p><strong>网络字节序</strong>：内存中多字节数据相对于内存地址有大端小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分，所以发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出，接收主机把从网络上接收到的字节按内存从低到高的顺序保存，因此网络数据流的地址应该规定：<code>先发出的数据是低地址，后发出的数据是高地址</code>。TCP/IP协议规定网络数据流应该采用大端字节序，即低地址高字节。所以发送主机和接收主机是小段字节序的在发送和接收之前需要做字节序的转换。  </p>\n</blockquote>\n<h4 id=\"tcpsocket-实现\"><a href=\"#tcpsocket-实现\" class=\"headerlink\" title=\"tcpsocket 实现\"></a>tcpsocket 实现</h4><p>实现模型：</p>\n<ol>\n<li><strong>服务器端</strong>： socket -&gt; bind -&gt; listen -&gt; accept(阻塞,三次握手)-&gt; send。  </li>\n<li><strong>客户端</strong>： socket -&gt; connect(阻塞,三次握手)-&gt; recv。  </li>\n</ol>\n<h4 id=\"socket-1\"><a href=\"#socket-1\" class=\"headerlink\" title=\"socket()\"></a>socket()</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> family, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><strong>family</strong>：指定协议的类型本次选择AF_INET（IPv4协议）；   </li>\n<li><strong>type</strong>：网络数据类型，TCP是面向字节流的—SOCK_STREAM；   </li>\n<li><strong>protocol</strong>：前两个参数一般确定了协议类型通常传0；   </li>\n<li><strong>返回值</strong>：成功返回套接字符；失败返回-1设置相关错误码。   </li>\n</ul>\n<h4 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind()\"></a>bind()</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> struct sockaddr *servaddr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><strong>sockfd</strong>：socket函数成功时候返回的套接字描述符；  </li>\n<li><strong>servaddr</strong>：服务器的IP和端口；  </li>\n<li><strong>addrlen</strong>： 长度（sizeof(servaddr)）；  </li>\n<li><strong>返回值</strong>：成功返回0；失败返回-1，并设置相关错误码。  </li>\n</ul>\n<h4 id=\"listen\"><a href=\"#listen\" class=\"headerlink\" title=\"listen()\"></a>listen()</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">listen</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> backlog)</span></span></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><strong>sockfd</strong>：socket函数成功时候返回的套接字描述符；  </li>\n<li><strong>backlog</strong>：内核中套接字排队的最大个数；  </li>\n<li><strong>返回值</strong>：成功返回0；失败返回-1，并设置相关错误码。  </li>\n</ul>\n<h4 id=\"accept\"><a href=\"#accept\" class=\"headerlink\" title=\"accept()\"></a>accept()</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">accept</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> struct sockaddr *servaddr, <span class=\"keyword\">socklen_t</span> *addrlen)</span></span></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><strong>sockfd</strong>：socket函数成功时候返回的套接字描述符；</li>\n<li><strong>servaddr</strong>：输出型参数，客户端的ip和端口；</li>\n<li><strong>addrlen</strong>：长度（sizeof(servaddr)）；</li>\n<li><strong>返回值</strong>：成功:从监听套接字返回已连接套接字；失败返回-1，并设置相关错误码。</li>\n</ul>\n<h4 id=\"connect\"><a href=\"#connect\" class=\"headerlink\" title=\"connect()\"></a>connect()</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> struct sockaddr *servaddr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><strong>sockfd</strong>：函数返回的套接字描述符；</li>\n<li><strong>servaddr</strong>：服务器的IP和端口；</li>\n<li><strong>addrlen</strong>：长度（sizeof(servaddr)）；</li>\n<li><strong>返回值</strong>：成功返回0；失败返回-1，并设置相关错误码</li>\n</ul>\n<h4 id=\"send-和recv\"><a href=\"#send-和recv\" class=\"headerlink\" title=\"send()和recv()\"></a>send()和recv()</h4><ul>\n<li><a href=\"https://blog.csdn.net/ly0303521/article/details/52290217\" target=\"_blank\" rel=\"noopener\"><strong>Socket中send()函数和recv()函数详解</strong></a>  </li>\n<li><a href=\"https://blog.csdn.net/G_BrightBoy/article/details/12854117\" target=\"_blank\" rel=\"noopener\"><strong>常用socket函数详解</strong></a>  </li>\n</ul>\n<h3 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select()\"></a>select()</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">select</span><span class=\"params\">(<span class=\"keyword\">int</span> maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><strong>maxfdp</strong>: 需要监视的最大文件描述符加1；  </li>\n<li><strong>readfds</strong>、<strong>writefds</strong>、<strong>errorfds</strong>：分别对应于需要检测的可读文件描述符的集合，可写文件描述符的集合及异常文件描述符的集合；  </li>\n<li><strong>timeout</strong>：等待时间，这个时间内，需要监视的描述符没有事件，timeout == NULL表示等待无限时长；  </li>\n<li><strong>返回值</strong>：发⽣生则函数返回，返回值为0。设为NULL 表示阻塞式等待，一直等到有事件就绪，函数才会返回，0表示非阻塞式等待，没有事件就立即返回，大于0表示等待的时间。大于0表示就绪时间的个数，等于0表示timeout等待时间到了，小于0表示调用失败。  </li>\n</ul>\n<h4 id=\"select-相关API\"><a href=\"#select-相关API\" class=\"headerlink\" title=\"select()相关API\"></a>select()相关API</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//延时结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span>      </span><br><span class=\"line\">    <span class=\"keyword\">long</span> tv_sec;   <span class=\"comment\">/*秒 */</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> tv_usec;  <span class=\"comment\">/*微秒 */</span>   </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/select.h&gt;   </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FD_ZERO</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, fd_set *fdset)</span></span>;   <span class=\"comment\">//一个 fd_set类型变量的所有位都设为 0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FD_CLR</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, fd_set *fdset)</span></span>;  <span class=\"comment\">//清除某个位时可以使用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FD_SET</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, fd_set *fd_set)</span></span>;   <span class=\"comment\">//设置变量的某个位置位</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">FD_ISSET</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, fd_set *fdset)</span></span>; <span class=\"comment\">//测试某个位是否被置位</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用范例\"><a href=\"#使用范例\" class=\"headerlink\" title=\"使用范例\"></a>使用范例</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当声明了一个文件描述符集后，必须用FD_ZERO将所有位置零。之后将我们所感兴趣的描述符所对应的位置位，操作如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd_set rset;   </span><br><span class=\"line\"><span class=\"keyword\">int</span> fd;   </span><br><span class=\"line\">FD_ZERO(&amp;rset);   </span><br><span class=\"line\">FD_SET(fd, &amp;rset);   </span><br><span class=\"line\">FD_SET(<span class=\"built_in\">stdin</span>, &amp;rset);</span><br><span class=\"line\"><span class=\"comment\">//调用select</span></span><br><span class=\"line\">select(fd+<span class=\"number\">1</span>, &amp;rset, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"comment\">//select返回后用FD_ISSET测试给定位是否置位</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(FD_ISSET(fd, &amp;rset)   </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    ... </span><br><span class=\"line\">    <span class=\"comment\">//do something  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"深入理解select\"><a href=\"#深入理解select\" class=\"headerlink\" title=\"深入理解select\"></a>深入理解select</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。<strong>但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。</strong>而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理解select模型的关键在于理解fd_set,为说明方便，取fd_set长度为1字节，fd_set中的每一bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。  </p>\n<ol>\n<li>执行fd_set set; FD_ZERO(&amp;set); 则set用位表示是0000,0000。</li>\n<li>若fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000(第5位置为1)</li>\n<li>若再加入fd＝2，fd=1,则set变为0001,0011</li>\n<li>执行select(6,&amp;set,0,0,0)阻塞等待</li>\n<li>若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。<strong>注意：没有事件发生的fd=5被清空。</strong>  </li>\n</ol>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于上面的讨论，可以轻松得出select模型的特点：  </p>\n<ol>\n<li>可监控的文件描述符个数取决与sizeof(fd_set)的值。我这边服务器上sizeof(fd_set)＝512，每bit表示一个文件描述符，则我服务器上支持的最大文件描述符是512*8=4096。据说可调，另有说虽然可调，但调整上限受于编译内核时的变量值。</li>\n<li>将fd加入select监控集的同时，还要再使用一个数据结构array保存放到select监控集中的fd，一是用于再select返回后，array作为源数据和fd_set进行FD_ISSET判断。二是select返回后会把以前加入的但并无事件发生的fd清空，则每次开始select前都要重新从array取得fd逐一加入（FD_ZERO最先），扫描array的同时取得fd最大值maxfd，用于select的第一个参数。</li>\n<li>可见select模型必须在select前循环加fd，取maxfd，select返回后利用FD_ISSET判断是否有事件发生。  </li>\n</ol>\n<blockquote>\n<p>注意：select在设置定时时，检测系统调用中的<code>SIGALARM</code>信号，会与其他的定时函数，例如alarm()、settimer()等函数。</p>\n</blockquote>\n<h4 id=\"select的优缺点\"><a href=\"#select的优缺点\" class=\"headerlink\" title=\"select的优缺点\"></a>select的优缺点</h4><ul>\n<li><strong>优点：</strong>   </li>\n</ul>\n<ol>\n<li>select的可移植性好，在某些unix下不支持poll.  </li>\n<li>select对超时值提供了很好的精度，精确到微秒，而poll式毫秒。  </li>\n</ol>\n<ul>\n<li><strong>缺点：</strong>    </li>\n</ul>\n<ol>\n<li>单个进程可监视的fd数量被限制，默认是1024。  </li>\n<li>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。  </li>\n<li>对fd进行扫描时是线性扫描，fd剧增后，IO效率降低，每次调用都对fd进行线性扫描遍历，随着fd的增加会造成遍历速度慢的问题。  </li>\n<li>select函数超时参数在返回时也是未定义的，考虑到可移植性，每次超时之后进入下一个select之前都要重新设置超时参数。  </li>\n</ol>\n<h3 id=\"pthread-create\"><a href=\"#pthread-create\" class=\"headerlink\" title=\"pthread_create()\"></a>pthread_create()</h3><h4 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h4><ol>\n<li>是操作系统能够进行调度的最小单位；  </li>\n<li>线程被包含在进程之中，是进程中的实际运作单位；  </li>\n<li>一个线程指的是进程中一个单一顺序的控制流；  </li>\n<li>一个进程可以并发多个线程，每个线程执行不同的任务。  </li>\n</ol>\n<blockquote>\n<ul>\n<li><strong>优点</strong>  </li>\n</ul>\n<ol>\n<li>创建一个新的线程的代价要比创建一个新进程的代价小得多；</li>\n<li>与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多；</li>\n<li>线程占有的资源要比进程少；</li>\n<li>线程之间共享数据更容易（线程是在一个房间中，所以相互通信比较容易，而进程之间通话需要跑到另一个房间）。</li>\n</ol>\n</blockquote>\n<blockquote>\n<ul>\n<li><strong>缺点</strong>  </li>\n</ul>\n<ol>\n<li>编码/调试难度提高，因为线程之间谁先执行不确定，在一个是共享资源的问题。  </li>\n<li>缺乏访问控制，一个线程崩溃，会导致整个进程都异常终止，一个线程中调用某些函数，会影响整个进程。  </li>\n</ol>\n</blockquote>\n<h4 id=\"线程与进程\"><a href=\"#线程与进程\" class=\"headerlink\" title=\"线程与进程\"></a>线程与进程</h4><ol>\n<li>进程：进程（或者任务）是资源分配的基本单位  </li>\n<li>线程：线程（或者轻量级进程）是调度/执行的基本单位  </li>\n<li>线程运行在进程中  </li>\n<li>一个进程至少都有一个线程   </li>\n</ol>\n<blockquote>\n<p>注：参考阮一峰的博客<a href=\"http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html\" target=\"_blank\" rel=\"noopener\"><strong>进程与线程的一个简单解释</strong></a></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>进程</th>\n<th>线程</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>fork</td>\n<td>pthread_create</td>\n<td>新建控制流</td>\n</tr>\n<tr>\n<td>waitpid</td>\n<td>pthread_join</td>\n<td>等待控制流，从当前控制流得到退出状态</td>\n</tr>\n<tr>\n<td>exit</td>\n<td>pthread_exit</td>\n<td>从当前控制流中退出</td>\n</tr>\n<tr>\n<td>getpid</td>\n<td>pthread_self</td>\n<td>获取当前控制流的ID</td>\n</tr>\n<tr>\n<td>abort</td>\n<td>pthread_cancel</td>\n<td>使指定的控制流异常退出</td>\n</tr>\n</tbody></table>\n<h4 id=\"线程创建与使用\"><a href=\"#线程创建与使用\" class=\"headerlink\" title=\"线程创建与使用\"></a>线程创建与使用</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> * <span class=\"title\">thread_test</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//test</span></span><br><span class=\"line\">    pthread(<span class=\"literal\">NULL</span>); <span class=\"comment\">//退出，也可以return</span></span><br><span class=\"line\">    <span class=\"comment\">//return (void *)1;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> thread1;</span><br><span class=\"line\">    pthread_create(&amp;thread1,<span class=\"literal\">NULL</span>,thread_test,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"comment\">//pthread_cancel(thread1); //关闭线程</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> wait_thread_end;</span><br><span class=\"line\">    <span class=\"comment\">//void *thread1_return;</span></span><br><span class=\"line\">    <span class=\"comment\">//wait_thread_end = pthread_join(thread1, &amp;thread1_return);</span></span><br><span class=\"line\">    <span class=\"comment\">//等待线程的返回，并获取返回值</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"线程传参\"><a href=\"#线程传参\" class=\"headerlink\" title=\"线程传参\"></a>线程传参</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//存储客户端sock_cli的结构体</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sock_cli[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">&#125; SERVER_SOC;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">wdt_thread</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    SERVER_SOC *wdt_sockfd;         <span class=\"comment\">//新建一个SERVER_SOC结构体指针</span></span><br><span class=\"line\">    wdt_sockfd = (SERVER_SOC *)arg; <span class=\"comment\">//接收传递来的参数结构体</span></span><br><span class=\"line\">    <span class=\"comment\">//对wdt_sockfd-&gt;元素操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//return (void *)1; //退出线程</span></span><br><span class=\"line\">    pthread_exit(<span class=\"number\">0</span>); <span class=\"comment\">//退出线程</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    pthread_create(&amp;thread2, <span class=\"literal\">NULL</span>, wdt_thread, (<span class=\"keyword\">void</span> *)sockfd);</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"线程局部变量\"><a href=\"#线程局部变量\" class=\"headerlink\" title=\"线程局部变量\"></a>线程局部变量</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个线程多次创建时，线程内定义的变量需要设置为局部变量，一种利用键值的demo如下：  </p>\n<details>\n<summary>局部变量</summary>  \n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pthread_key_t</span> key_msg;    <span class=\"comment\">//声明一个线程局部变量的共享键值</span></span><br><span class=\"line\"><span class=\"keyword\">pthread_key_t</span> key_buffer; <span class=\"comment\">//声明一个线程局部变量的共享键值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">recv_func</span><span class=\"params\">(<span class=\"keyword\">int</span> sock_cli)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    MSG_STRUCT *recv_msg = pthread_getspecific(key_msg); <span class=\"comment\">//从键值中获取局部变量</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *buffer = pthread_getspecific(key_buffer);      <span class=\"comment\">//从键值中获取局部变量</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">msg_thread</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    SERVER_SOC *msg_sockfd;                                          <span class=\"comment\">//新建一个SERVER_SOC结构体指针</span></span><br><span class=\"line\">    msg_sockfd = (SERVER_SOC *)arg;                                  <span class=\"comment\">//接收传递来的参数结构体</span></span><br><span class=\"line\">    MSG_STRUCT *recv_msg = (MSG_STRUCT *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(MSG_STRUCT)); <span class=\"comment\">//分配消息结构体指针</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *buffer = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(MSG_STRUCT));               <span class=\"comment\">//新建一个接收的缓存区域</span></span><br><span class=\"line\">    pthread_setspecific(key_msg, recv_msg);                          <span class=\"comment\">//将recv_msg与key_msg键值绑定</span></span><br><span class=\"line\">    pthread_setspecific(key_buffer, buffer);                         <span class=\"comment\">//将buffer与key_buffer键值绑定</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"线程ID为%lu\\n\"</span>, pthread_self());</span><br><span class=\"line\">    recv_func(msg_sockfd-&gt;sock_cli[msg_sockfd-&gt;num]); <span class=\"comment\">//接收服务端发来是信号</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//return (void *)1; //退出线程</span></span><br><span class=\"line\">    pthread_exit(<span class=\"number\">0</span>); <span class=\"comment\">//退出线程</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pthread_key_create(&amp;key_msg, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    pthread_key_create(&amp;key_buffer, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pthread_create(&amp;thread1, <span class=\"literal\">NULL</span>, msg_thread, (<span class=\"keyword\">void</span> *)sockfd); <span class=\"comment\">//传参</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_key_delete(key_msg);    <span class=\"comment\">//销毁键值</span></span><br><span class=\"line\">    pthread_key_delete(key_buffer); <span class=\"comment\">//销毁键值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>  \n\n<h4 id=\"线程编译\"><a href=\"#线程编译\" class=\"headerlink\" title=\"线程编译\"></a>线程编译</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -o pthread -lpthread pthread.c  <span class=\"comment\">#-lpthread调用libpthread库</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># cmake中添加链接库</span></span><br><span class=\"line\">LINK_LIBRARIES(pthread)     <span class=\"comment\">#添加链接库，gcc里面需要添加 -lpthread</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方案选择\"><a href=\"#方案选择\" class=\"headerlink\" title=\"方案选择\"></a>方案选择</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现服务器架构，综上而言，客户端较少的情况下，使用select查找法更为容易，对内存的开销较小，但是当客户端增加后服务器处理客户端消息的实时性将大打折扣。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用多进程的方式，服务端的子进程之间还需要建立通信，相对而言使用多线程更为容易，且多线程一样具有多进程的实时性。多线程开发中要注意变量的读写，如果变量比较重要且均在线程内，应当设置为局部变量。当然，变量作为全局变量，可以允许各线程加以修改，但一定要解决同步问题。对于单核的处理器而言，每个时间片只运行一个进程的一个线程的一部分，因此微观上，各线程读或者写的顺序是无法控制的，可能会出现读的线程发生在写之前，读到了旧值，这个问题需要非常重视。一个可以反映出问题的demo如下：</p>\n<details>\n<summary>test.c</summary>  \n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> g_val = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">void</span> *argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">5000</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// g_val++;</span></span><br><span class=\"line\">        <span class=\"comment\">// pthread_mutex_lock(&amp;lock);  //上锁</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = g_val;  <span class=\"comment\">//可能读取旧值，而另一个线程已经在加</span></span><br><span class=\"line\">        g_val = tmp+<span class=\"number\">1</span>;</span><br><span class=\"line\">        usleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"comment\">// pthread_mutex_unlock(&amp;lock); //解锁</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> id1,id2;</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_create(&amp;id1,<span class=\"literal\">NULL</span>,add,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    pthread_create(&amp;id2,<span class=\"literal\">NULL</span>,add,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_join(id1,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    pthread_join(id2,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,g_val);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码实际运行，各线程累加5000次，应该值为10000，但实际上如果不加锁和解锁，数值最终无法到达10000。\n\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：<a href=\"https://www.cnblogs.com/lang5230/p/5686868.html\" target=\"_blank\" rel=\"noopener\">linux多线程-互斥&amp;条件变量与同步</a>。</p>\n<h2 id=\"自定义函数及功能\"><a href=\"#自定义函数及功能\" class=\"headerlink\" title=\"自定义函数及功能\"></a>自定义函数及功能</h2><details>\n<summary>socket.c</summary>  \n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"am5728.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"sock.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @功能 : 获取指定进程的pid</span></span><br><span class=\"line\"><span class=\"comment\"> * @输入 : 进程名称</span></span><br><span class=\"line\"><span class=\"comment\"> * @返回 : 进程pid</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_other_process_pid</span><span class=\"params\">(<span class=\"keyword\">char</span> *process_name)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> popen_cmd[<span class=\"number\">50</span>] = &#123;<span class=\"string\">'\\0'</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(popen_cmd, <span class=\"string\">\"ps -a | grep \\'%s\\' | awk \\'&#123;print $1&#125;\\'\"</span>,</span><br><span class=\"line\">            process_name); <span class=\"comment\">//遍历查询PID</span></span><br><span class=\"line\">    FILE *fp = popen(popen_cmd, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> pid_buffer[<span class=\"number\">10</span>] = &#123;<span class=\"string\">'\\0'</span>&#125;;</span><br><span class=\"line\">    fgets(pid_buffer, <span class=\"number\">10</span>, fp);</span><br><span class=\"line\">    pclose(fp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> atoi(pid_buffer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @功能 : 向表中添加一个client的接收线程fd，超出范围则返回-1，当有新客户端注册接收线程sockfd时调用</span></span><br><span class=\"line\"><span class=\"comment\"> * @输入 : 客户端sockfd表结构体地址，客户端进程名称，注册的sockfd</span></span><br><span class=\"line\"><span class=\"comment\"> * @返回 : 正确添加返回1；超出范围返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add_table</span><span class=\"params\">(CLIENT_TABLE *table, <span class=\"keyword\">char</span> *client_name, <span class=\"keyword\">int</span> sock)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; CLI_NUM; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table-&gt;client_recv_sock[i] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(table-&gt;client_name[i], client_name);</span><br><span class=\"line\">            table-&gt;client_recv_sock[i] = sock;</span><br><span class=\"line\">            <span class=\"comment\">// printf(\"[server ] Add %dth data in client_sockfd:name = %s\\tsock = %d\\n\", i, table-&gt;client_name[i], table-&gt;client_recv_sock[i]);</span></span><br><span class=\"line\">            <span class=\"comment\">//break;</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @功能 : 从表中搜寻指定client_name的fd并返回，当服务器需要转发消息时调用</span></span><br><span class=\"line\"><span class=\"comment\"> * @输入 : 客户端sockfd表结构体地址，客户端进程名称</span></span><br><span class=\"line\"><span class=\"comment\"> * @返回 : 正确搜寻到返回sockfd，无法查询返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search_fd</span><span class=\"params\">(CLIENT_TABLE *table, <span class=\"keyword\">char</span> *client_name)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sock;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; CLI_NUM)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(client_name, table-&gt;client_name[i]) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sock = table-&gt;client_recv_sock[i];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sock;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @功能 : 从表中删除一组client的接收线程sockfd，在client突然断开时调用</span></span><br><span class=\"line\"><span class=\"comment\"> * @输入 : 客户端sockfd表结构体地址，注册的sockfd</span></span><br><span class=\"line\"><span class=\"comment\"> * @返回 : 正确搜寻并删除返回1，无法查找返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">delete_fd</span><span class=\"params\">(CLIENT_TABLE *table, <span class=\"keyword\">int</span> sock)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; CLI_NUM; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (table-&gt;client_recv_sock[i] == sock)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(table-&gt;client_name[i], <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">            table-&gt;client_recv_sock[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// printf(\"[server ] Delete %dth data in client_sockfd\\n\", i);</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @功能 : 客户端注册看门狗时调用，向wdt表中添加对应的进程名称，并将wdt_count置0（默认值-1）</span></span><br><span class=\"line\"><span class=\"comment\"> * @输入 : 看门狗注册表结构体地址，客户端进程名</span></span><br><span class=\"line\"><span class=\"comment\"> * @返回 : 正常添加返回1，已注册满返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add_wdt</span><span class=\"params\">(WDT_STRUCT *wdt, <span class=\"keyword\">char</span> *client_name)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; CLI_NUM; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wdt-&gt;wdt_count[i] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(wdt-&gt;wdt_client_name[i], client_name);</span><br><span class=\"line\">            wdt-&gt;wdt_count[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">// printf(\"[server ] Add %dth data in wdt_table:name = %s\\twdt_count = %d\\n\", i, wdt-&gt;wdt_client_name[i], wdt-&gt;wdt_count[i]);</span></span><br><span class=\"line\">            <span class=\"comment\">//break;</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @功能 : 将看门狗注册表中相应的客户端计数置0，在客户端喂狗时调用</span></span><br><span class=\"line\"><span class=\"comment\"> * @输入 : 看门狗注册表结构体地址，客户端进程名</span></span><br><span class=\"line\"><span class=\"comment\"> * @返回 : 成功置0返回1，无法查询返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">set_wdt_count_zero</span><span class=\"params\">(WDT_STRUCT *wdt, <span class=\"keyword\">char</span> *client_name)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; CLI_NUM)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(client_name, wdt-&gt;wdt_client_name[i]) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            wdt-&gt;wdt_count[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">// printf(\"[server ] set %s process's wdt_count to be zero\\n\", wdt-&gt;wdt_client_name[i]);</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @功能 : 将看门狗注册表中的所有计数加1，如果超出阈值kill相应进程</span></span><br><span class=\"line\"><span class=\"comment\"> * @输入 : 看门狗注册表结构体地址</span></span><br><span class=\"line\"><span class=\"comment\"> * @返回 : 1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">wdt_count</span><span class=\"params\">(WDT_STRUCT *wdt)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; CLI_NUM)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wdt-&gt;wdt_count[i] &gt;= <span class=\"number\">0</span>) <span class=\"comment\">//挑选出注册的wdt</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            wdt-&gt;wdt_count[i]++;</span><br><span class=\"line\">            <span class=\"comment\">// printf(\"[server ] 进程 %s 的计数加一，wdt_count = %d\\n\", wdt-&gt;wdt_client_name[i], wdt-&gt;wdt_count[i]);</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wdt-&gt;wdt_count[i] &gt;= <span class=\"number\">3</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"[server ] %s process's(PID = %d) wdt_count is larger than 3\\n\"</span>, wdt-&gt;wdt_client_name[i], get_other_process_pid(wdt-&gt;wdt_client_name[i]));</span><br><span class=\"line\">                kill(get_other_process_pid(wdt-&gt;wdt_client_name[i]), SIGKILL);</span><br><span class=\"line\">                wdt-&gt;wdt_count[i] = <span class=\"number\">-1</span>; <span class=\"comment\">//重置wdt_count，防止下次注册重复</span></span><br><span class=\"line\">                <span class=\"built_in\">strcpy</span>(wdt-&gt;wdt_client_name[i], <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @功能 : 服务器新建socket程序</span></span><br><span class=\"line\"><span class=\"comment\"> * @输入 : ip地址，port端口</span></span><br><span class=\"line\"><span class=\"comment\"> * @返回 : 正常建立返回sock，无法建立返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">server_socket</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *_ip, <span class=\"keyword\">int</span> _port)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sock &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"[server ] socket\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">local</span>;</span></span><br><span class=\"line\">    local.sin_family = AF_INET;</span><br><span class=\"line\">    local.sin_port = htons(_port);</span><br><span class=\"line\">    local.sin_addr.s_addr = inet_addr(_ip);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bind(sock, (struct sockaddr *)&amp;local, <span class=\"keyword\">sizeof</span>(local)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"[server ] bind\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listen(sock, <span class=\"number\">10</span>) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"[server ] listen\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sock;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @功能 : 处理服务器接收到的消息，分别有客户端接收线程fd注册，看门狗注册，看门狗置0以及消息转发</span></span><br><span class=\"line\"><span class=\"comment\"> * @输入 : 消息结构体地址，客户端sockfd表结构体地址，注册的sockfd，看门狗注册表结构体地址</span></span><br><span class=\"line\"><span class=\"comment\"> * @返回 : 正常完成返回1，错误完成返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msg_option</span><span class=\"params\">(PACKET *msg, CLIENT_TABLE *table, <span class=\"keyword\">int</span> sock, WDT_STRUCT *wdt)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (msg-&gt;cmd)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> CMD_RECV: <span class=\"comment\">//客户端建立接收线程，调用add_table向表中注册信息</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        add_table(table, msg-&gt;source_name, sock);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> CMD_WDT: <span class=\"comment\">//客户端发送看门狗消息</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (msg-&gt;wdt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> WDT_REGISTER:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//printf(\"wdt : 正在向表中注册client_name\\n\");</span></span><br><span class=\"line\">            add_wdt(wdt, msg-&gt;source_name);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> WDT_SIGNAL:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//根据source_name查询wdt_count并置零</span></span><br><span class=\"line\">            <span class=\"comment\">//printf(\"wdt : 正在计数清零\\n\");</span></span><br><span class=\"line\">            set_wdt_count_zero(wdt, msg-&gt;source_name);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> CMD_TRANSFER: <span class=\"comment\">//客户端发送转发消息，查表获取目标fd并转发</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"[server ] Transfering a message from %s to %s\\n\"</span>, msg-&gt;source_name, msg-&gt;target_name);</span><br><span class=\"line\">        <span class=\"keyword\">char</span> *buf = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(MSG_LEGHTN);</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(buf, msg, MSG_LEGHTN);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> target_sock = search_fd(table, msg-&gt;target_name);</span><br><span class=\"line\">        <span class=\"comment\">// printf(\"[server ] Searching sockfd...\\n\");</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target_sock &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"[server ] Cannot find sockfd, no route to send!\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        write(target_sock, buf, MSG_LEGHTN);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"[server ] Send successfully!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @功能 : 客户端新建socket并connect服务器函数</span></span><br><span class=\"line\"><span class=\"comment\"> * @输入 : NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * @返回 : 成功创建返回sockfd，无法连接返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">client_socket</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sock &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"socket\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">server</span>;</span></span><br><span class=\"line\">    server.sin_family = AF_INET;</span><br><span class=\"line\">    server.sin_port = htons(<span class=\"number\">8000</span>);</span><br><span class=\"line\">    server.sin_addr.s_addr = inet_addr(<span class=\"string\">\"127.1.1.1\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connect(sock, (struct sockaddr *)&amp;server, <span class=\"keyword\">sizeof</span>(server)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"connect\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sock;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @功能 : 转发消息，msg-&gt;cmd = 2</span></span><br><span class=\"line\"><span class=\"comment\"> * @输入 : 服务器sockfd，目标进程名，源进程名，消息内容</span></span><br><span class=\"line\"><span class=\"comment\"> * @返回 : 成功发送返回1，发送失败返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">transfer_msg</span><span class=\"params\">(<span class=\"keyword\">int</span> sock, <span class=\"keyword\">char</span> *target_name, <span class=\"keyword\">char</span> *source_name, <span class=\"keyword\">char</span> *content)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    PACKET *msg = (PACKET *)<span class=\"built_in\">malloc</span>(MSG_LEGHTN);</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(msg-&gt;head, <span class=\"string\">\"%s\"</span>, <span class=\"string\">\"head\"</span>);</span><br><span class=\"line\">    msg-&gt;cmd = <span class=\"number\">2</span>; <span class=\"comment\">//transfer cmd</span></span><br><span class=\"line\">    msg-&gt;wdt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(msg-&gt;target_name, <span class=\"string\">\"%s\"</span>, target_name);</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(msg-&gt;source_name, <span class=\"string\">\"%s\"</span>, source_name);</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(msg-&gt;msg, <span class=\"string\">\"%s\"</span>, content);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *buf = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(MSG_LEGHTN);</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(buf, msg, MSG_LEGHTN);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = write(sock, buf, MSG_LEGHTN);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span> (<span class=\"string\">\"[%s] Cannot send!\\n\"</span>, source_name);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @功能 : 注册看门狗信息，msg-&gt;cmd = 1，msg-&gt;wdt = 0</span></span><br><span class=\"line\"><span class=\"comment\"> * @输入 : 服务器sockfd，源进程名</span></span><br><span class=\"line\"><span class=\"comment\"> * @返回 : 成功发送返回1，发送失败返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">register_wdt</span><span class=\"params\">(<span class=\"keyword\">int</span> sock, <span class=\"keyword\">char</span> *source_name)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    PACKET *msg = (PACKET *)<span class=\"built_in\">malloc</span>(MSG_LEGHTN);</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(msg-&gt;head, <span class=\"string\">\"%s\"</span>, <span class=\"string\">\"head\"</span>);</span><br><span class=\"line\">    msg-&gt;cmd = <span class=\"number\">1</span>; <span class=\"comment\">//transfer cmd</span></span><br><span class=\"line\">    msg-&gt;wdt = <span class=\"number\">0</span>; <span class=\"comment\">//wdt register</span></span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(msg-&gt;target_name, <span class=\"string\">\"%s\"</span>, <span class=\"string\">\"null\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(msg-&gt;source_name, <span class=\"string\">\"%s\"</span>, source_name);</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(msg-&gt;msg, <span class=\"string\">\"%s\"</span>, <span class=\"string\">\"null\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *buf = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(MSG_LEGHTN);</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(buf, msg, MSG_LEGHTN);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result= write(sock, buf, MSG_LEGHTN);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span> (<span class=\"string\">\"[%s] Cannot send!\\n\"</span>, source_name);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @功能 : 喂狗，msg-&gt;cmd = 1，msg-&gt;wdt = 1</span></span><br><span class=\"line\"><span class=\"comment\"> * @输入 : 服务器sockfd，源进程名</span></span><br><span class=\"line\"><span class=\"comment\"> * @返回 : 成功发送返回1，发送失败返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">send_wdt</span><span class=\"params\">(<span class=\"keyword\">int</span> sock, <span class=\"keyword\">char</span> *source_name)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    PACKET *msg = (PACKET *)<span class=\"built_in\">malloc</span>(MSG_LEGHTN);</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(msg-&gt;head, <span class=\"string\">\"%s\"</span>, <span class=\"string\">\"head\"</span>);</span><br><span class=\"line\">    msg-&gt;cmd = <span class=\"number\">1</span>; <span class=\"comment\">//transfer cmd</span></span><br><span class=\"line\">    msg-&gt;wdt = <span class=\"number\">1</span>; <span class=\"comment\">//wdt signal</span></span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(msg-&gt;target_name, <span class=\"string\">\"%s\"</span>, <span class=\"string\">\"null\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(msg-&gt;source_name, <span class=\"string\">\"%s\"</span>, source_name);</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(msg-&gt;msg, <span class=\"string\">\"%s\"</span>, <span class=\"string\">\"null\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *buf = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(MSG_LEGHTN);</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(buf, msg, MSG_LEGHTN);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = write(sock, buf, MSG_LEGHTN);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span> (<span class=\"string\">\"[%s] Cannot send!\\n\"</span>, source_name);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>  \n\n<h3 id=\"运行框图\"><a href=\"#运行框图\" class=\"headerlink\" title=\"运行框图\"></a>运行框图</h3><p>服务端<br><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/tcpip/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AF%E4%BB%B6%E6%A1%86%E5%9B%BE.bmp\" alt=\"pic1\"><br>客户端<br><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/tcpip/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BD%AF%E4%BB%B6%E6%A1%86%E5%9B%BE.bmp\" alt=\"pic2\"></p>\n<h2 id=\"守护脚本\"><a href=\"#守护脚本\" class=\"headerlink\" title=\"守护脚本\"></a>守护脚本</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;守护脚本的功能是，当检测到某进程不存在是，立即重启该进程，对应着服务器检测到某个进程不喂狗时立即杀死该进程。两者想结合完成对客户端及服务器端的保护。守护进程中用shell语言编写了protect函数，输入参数为<code>$1</code>，即进程名。启动守护脚本后，将分先后运行服务器和客户端可执行文件并运行在后台，再在主循环中轮询守护对应的进程。</p>\n<details>\n<summary>main.sh</summary>  \n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./zhx_server &amp;</span><br><span class=\"line\">./client1 &amp;</span><br><span class=\"line\">./client2 &amp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> protect &#123;</span><br><span class=\"line\">    <span class=\"comment\"># PRO_NAME = $1   </span></span><br><span class=\"line\">    <span class=\"comment\">#用ps获取$PRO_NAME进程数量</span></span><br><span class=\"line\">    NUM=`ps aux | grep -w <span class=\"variable\">$1</span> | grep -v grep |wc -l`</span><br><span class=\"line\">    <span class=\"comment\">#echo $NUM</span></span><br><span class=\"line\">    <span class=\"comment\">#少于1，重启进程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$&#123;NUM&#125;</span>\"</span> -lt <span class=\"string\">\"1\"</span> ];<span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">\"[main.sh] <span class=\"variable\">$1</span> was killed\"</span></span><br><span class=\"line\">        ./<span class=\"variable\">$1</span> &amp;</span><br><span class=\"line\">    <span class=\"comment\">#大于1，杀掉所有进程，重启</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> [ <span class=\"string\">\"<span class=\"variable\">$&#123;NUM&#125;</span>\"</span> -gt <span class=\"string\">\"1\"</span> ];<span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">\"[main.sh] more than 1 <span class=\"variable\">$1</span>,killall <span class=\"variable\">$1</span>\"</span></span><br><span class=\"line\">        killall -9 <span class=\"variable\">$PRO_NAME</span></span><br><span class=\"line\">        ./<span class=\"variable\">$1</span> &amp;</span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"comment\">#kill僵尸进程</span></span><br><span class=\"line\">    NUM_STAT=`ps aux | grep -w <span class=\"variable\">$1</span> | grep T | grep -v grep | wc -l`</span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$&#123;NUM_STAT&#125;</span>\"</span> -gt <span class=\"string\">\"0\"</span> ];<span class=\"keyword\">then</span></span><br><span class=\"line\">        killall -9 <span class=\"variable\">$1</span></span><br><span class=\"line\">        ./<span class=\"variable\">$1</span> &amp;</span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"comment\"># sleep 1s</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># NAME=\"client1\"</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">true</span> ; <span class=\"keyword\">do</span></span><br><span class=\"line\">    protect <span class=\"string\">\"zhx_server\"</span></span><br><span class=\"line\">    protect <span class=\"string\">\"client1\"</span></span><br><span class=\"line\">    protect <span class=\"string\">\"client2\"</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"built_in\">exit</span> 0</span><br></pre></td></tr></table></figure>\n\n</details>  \n\n<h2 id=\"实现结果\"><a href=\"#实现结果\" class=\"headerlink\" title=\"实现结果\"></a>实现结果</h2><p><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/tcpip/socket%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.JPG\" alt=\"1\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[client1] Creating recv thread...                                   #客户端建立接收线程</span><br><span class=\"line\">[client2] Creating recv thread...</span><br><span class=\"line\">[server ] Transfering a message from client1 to client2             #服务端转发客户端的消息</span><br><span class=\"line\">[server ] Send successfully!                                        #转发成功</span><br><span class=\"line\">[client2] thread recv msg:&quot;this message is from client1 to client2&quot; #client2成功接收</span><br><span class=\"line\">[server ] client1 process&apos;s(PID = 5061) wdt_count is larger than 3  #client1计数超时</span><br><span class=\"line\">[main.sh] client1 was killed                                        #服务器关闭客户端</span><br><span class=\"line\">[client1] Creating recv thread...                                   #守护脚本再次重启客户端</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><details>\n<summary>server.c</summary>  \n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"am5728.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"sock.h\"</span></span></span><br><span class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class=\"line\">WDT_STRUCT wdt;          <span class=\"comment\">//新建一个客户端进程看门狗维护表的结构体，相关函数传递 &amp;wdt</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> client_sockfd[<span class=\"number\">4096</span>]; <span class=\"comment\">//所有客户端连接的fd存储数组</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @功能 : 看门狗信号处理线程，独立于主线程</span></span><br><span class=\"line\"><span class=\"comment\"> * @输入 : NULL</span></span><br><span class=\"line\"><span class=\"comment\"> * @返回 : NULL</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">wdt_opt</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">3</span>); <span class=\"comment\">//设置定时</span></span><br><span class=\"line\">        pthread_mutex_lock(&amp;lock);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"[server ] 看门狗线程正在上锁\\n\"</span>);</span><br><span class=\"line\">        wdt_count(&amp;wdt); <span class=\"comment\">//计数</span></span><br><span class=\"line\">        pthread_mutex_unlock(&amp;lock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">    <span class=\"comment\">//                                           建立socket和fd_set变量</span></span><br><span class=\"line\">    <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> listensock = server_socket(<span class=\"string\">\"127.1.1.1\"</span>, <span class=\"number\">8000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listensock &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"[server ] Create socket error!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxfd = <span class=\"number\">0</span>; <span class=\"comment\">//初始化maxfd</span></span><br><span class=\"line\">    fd_set rfds;   <span class=\"comment\">//可读</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">    <span class=\"comment\">//                                           初始化table结构体</span></span><br><span class=\"line\">    <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">    CLIENT_TABLE *table = (CLIENT_TABLE *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(CLIENT_TABLE)); <span class=\"comment\">//新建一个客户端进程与接收fd的表的结构体指针</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(table, <span class=\"string\">'\\0'</span>, <span class=\"keyword\">sizeof</span>(CLIENT_TABLE));                          <span class=\"comment\">//初始化表</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = <span class=\"number\">0</span>;                                                          <span class=\"comment\">//循环计数值</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (m = <span class=\"number\">0</span>; m &lt; CLI_NUM; m++)                                       <span class=\"comment\">//将table-&gt;client_recv_sock[10]所有内容初始化为-1</span></span><br><span class=\"line\">        table-&gt;client_recv_sock[m] = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">    <span class=\"comment\">//                                           初始化client_sockfd</span></span><br><span class=\"line\">    <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">    client_sockfd[<span class=\"number\">0</span>] = listensock;                                             <span class=\"comment\">//client_sockfd[]的第一个值为server自己的sockfd</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;                                                                 <span class=\"comment\">//client_sockfd置数循环计数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> client_sockfd_size = <span class=\"keyword\">sizeof</span>(client_sockfd) / <span class=\"keyword\">sizeof</span>(client_sockfd[<span class=\"number\">0</span>]); <span class=\"comment\">//client_sockfd_size=4096</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; i &lt; client_sockfd_size; i++)                                        <span class=\"comment\">//将保存fd的client_sockfd除去第一位，全部预先设为-1</span></span><br><span class=\"line\">        client_sockfd[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">    <span class=\"comment\">//                                           初始化wdt结构体</span></span><br><span class=\"line\">    <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;wdt, <span class=\"string\">'\\0'</span>, <span class=\"keyword\">sizeof</span>(WDT_STRUCT)); <span class=\"comment\">//初始化表</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;                              <span class=\"comment\">//循环计数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (n = <span class=\"number\">0</span>; n &lt; CLI_NUM; n++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        wdt.wdt_count[n] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">strcpy</span>(wdt.wdt_client_name[n], <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">    <span class=\"comment\">//                                           开启看门狗线程</span></span><br><span class=\"line\">    <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> thread1;                             <span class=\"comment\">//新建线程变量</span></span><br><span class=\"line\">    pthread_create(&amp;thread1, <span class=\"literal\">NULL</span>, wdt_opt, <span class=\"literal\">NULL</span>); <span class=\"comment\">//创建线程</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">    <span class=\"comment\">//                                           主循环</span></span><br><span class=\"line\">    <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        FD_ZERO(&amp;rfds);                          <span class=\"comment\">//将所有位清0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; client_sockfd_size; ++i) <span class=\"comment\">//将client_sockfd中成员与fd_set绑定</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (client_sockfd[i] &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                FD_SET(client_sockfd[i], &amp;rfds);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (client_sockfd[i] &gt; maxfd)</span><br><span class=\"line\">                    maxfd = client_sockfd[i]; <span class=\"comment\">//取出最大的fd，作为select的第一个参数</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">        <span class=\"comment\">//                                           等待select返回文件描述符变化</span></span><br><span class=\"line\">        <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (select(maxfd + <span class=\"number\">1</span>, &amp;rfds, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>)) <span class=\"comment\">//第一个参数是被监听的文件描述符的总数</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// printf(\"timeout\\t\"); //超时=0</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">-1</span>:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//perror(\"select error\"); //错误小于0</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"comment\">//大于0返回就绪的文件描述符的个数</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; j &lt; client_sockfd_size; ++j) <span class=\"comment\">//遍历查询client_sockfd[]里面所有内容，用FD_ISSET捕获变化位</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">                <span class=\"comment\">//                                           处理客户端创建连接</span></span><br><span class=\"line\">                <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j == <span class=\"number\">0</span> &amp;&amp; FD_ISSET(client_sockfd[j], &amp;rfds)) <span class=\"comment\">//判断client_sockfd[0]是否有变化</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">client</span>;</span></span><br><span class=\"line\">                    <span class=\"keyword\">socklen_t</span> len = <span class=\"keyword\">sizeof</span>(client);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> new_sock = accept(listensock, (struct sockaddr *)&amp;client, &amp;len); <span class=\"comment\">//获得accept返回值</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (new_sock &lt;= <span class=\"number\">0</span>)                                                   <span class=\"comment\">//accept failed</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        perror(<span class=\"string\">\"[server ] accept\"</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// printf(\"[server ] get a new client, sock = %d\\n\", new_sock);</span></span><br><span class=\"line\">                    fflush(<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> k = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (; k &lt; client_sockfd_size; ++k) <span class=\"comment\">//找最靠前的-1的项赋值</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (client_sockfd[k] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                        &#123;</span><br><span class=\"line\">                            client_sockfd[k] = new_sock;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (new_sock &gt; maxfd) <span class=\"comment\">//获取新的最大描述符</span></span><br><span class=\"line\">                                maxfd = new_sock;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (k == client_sockfd_size) <span class=\"comment\">//fd达到上限</span></span><br><span class=\"line\">                        close(new_sock);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">                <span class=\"comment\">//                                           处理客户端发送消息</span></span><br><span class=\"line\">                <span class=\"comment\">//******************************************************************************************************</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j != <span class=\"number\">0</span> &amp;&amp; FD_ISSET(client_sockfd[j], &amp;rfds)) <span class=\"comment\">//如果是client_sockfd[1]以后的fd有读的变化</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">char</span> *buf = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(MSG_LEGHTN);              <span class=\"comment\">//新建一个接收消息的缓冲buf</span></span><br><span class=\"line\">                    <span class=\"keyword\">ssize_t</span> s = read(client_sockfd[j], buf, MSG_LEGHTN); <span class=\"comment\">//将队列中的内容读至buf中</span></span><br><span class=\"line\">                    PACKET *msg = (PACKET *)<span class=\"built_in\">malloc</span>(MSG_LEGHTN);          <span class=\"comment\">//新建一个msg结构体地址，将消息传给消息处理函数</span></span><br><span class=\"line\">                    <span class=\"built_in\">memcpy</span>(msg, buf, MSG_LEGHTN);                        <span class=\"comment\">//将buf内容还原位结构体，保存到msg指向的结构体</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s &gt; <span class=\"number\">0</span>)                                           <span class=\"comment\">//读到正确的消息</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        pthread_mutex_lock(&amp;lock);</span><br><span class=\"line\">                        <span class=\"built_in\">printf</span>(<span class=\"string\">\"[server ] 主线程正在上锁\\n\"</span>);</span><br><span class=\"line\">                        msg_option(msg, table, client_sockfd[j], &amp;wdt);</span><br><span class=\"line\">                        pthread_mutex_unlock(&amp;lock);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == s) <span class=\"comment\">//客户端离线</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        close(client_sockfd[j]);                         <span class=\"comment\">//关闭客户端</span></span><br><span class=\"line\">                        <span class=\"keyword\">int</span> result = delete_fd(table, client_sockfd[j]); <span class=\"comment\">//先删除再把client_sockfd[j]置为-1</span></span><br><span class=\"line\">                        client_sockfd[j] = <span class=\"number\">-1</span>;                           <span class=\"comment\">//还原client_sockfd[j]</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        perror(<span class=\"string\">\"[server ] read\"</span>);</span><br><span class=\"line\">                        close(client_sockfd[j]);</span><br><span class=\"line\">                        client_sockfd[j] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details> \n\n<details>\n<summary>client1.c</summary>  \n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"am5728.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"sock.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">client_recv_thread</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sock_recv; <span class=\"comment\">//存放socket_client函数运行的返回值，也是recv函数的第一个参数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    PACKET *send_msg = (PACKET *)<span class=\"built_in\">malloc</span>(MSG_LEGHTN);</span><br><span class=\"line\">    PACKET *recv_msg = (PACKET *)<span class=\"built_in\">malloc</span>(MSG_LEGHTN);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(send_msg-&gt;head, <span class=\"string\">\"%s\"</span>, <span class=\"string\">\"head\"</span>);</span><br><span class=\"line\">    send_msg-&gt;cmd = <span class=\"number\">0</span>;</span><br><span class=\"line\">    send_msg-&gt;wdt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(send_msg-&gt;target_name, <span class=\"string\">\"%s\"</span>, <span class=\"string\">\"null\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(send_msg-&gt;source_name, <span class=\"string\">\"%s\"</span>, <span class=\"string\">\"client1\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(send_msg-&gt;msg, <span class=\"string\">\"%s\"</span>, <span class=\"string\">\"null\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *buffer = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(MSG_LEGHTN);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((sock_recv = client_socket()) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"[client1] connect failed!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">void</span> *)<span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// printf(\"客户端的sock_cli值为：%d\\n\", sock_recv);</span></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(buffer, send_msg, MSG_LEGHTN);</span><br><span class=\"line\">    write(sock_recv, buffer, MSG_LEGHTN);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(recv_msg, <span class=\"string\">'\\0'</span>, MSG_LEGHTN);</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(buffer, <span class=\"string\">'\\0'</span>, MSG_LEGHTN);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//recv(sock_recv, buffer, MSG_LEGHTN,0);  //让线程进入阻塞，此处不用read()</span></span><br><span class=\"line\">        <span class=\"keyword\">ssize_t</span> s = read(sock_recv, buffer, MSG_LEGHTN);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">memcpy</span>(recv_msg, buffer, MSG_LEGHTN);</span><br><span class=\"line\">            <span class=\"comment\">//sleep(1);</span></span><br><span class=\"line\">            <span class=\"comment\">//对接收的数据操作</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"[client1] thread recv:msg=\\\"%s\\\"\\n\"</span>, recv_msg-&gt;msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    close(sock_recv);</span><br><span class=\"line\">    pthread_exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> recv_thread;</span><br><span class=\"line\">    pthread_create(&amp;recv_thread, <span class=\"literal\">NULL</span>, client_recv_thread, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"[client1] Creating recv thread...\\n\"</span>);</span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sock = client_socket();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sock &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"[client1] Connect failed\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    register_wdt(sock, <span class=\"string\">\"client1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (get_other_process_pid(<span class=\"string\">\"zhx_server\"</span>) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// memcpy(buf, msg, MSG_LEGHTN);</span></span><br><span class=\"line\">        <span class=\"comment\">// write(sock, buf, MSG_LEGHTN);</span></span><br><span class=\"line\">        <span class=\"comment\">//sleep(4);</span></span><br><span class=\"line\">        transfer_msg(sock, <span class=\"string\">\"client2\"</span>, <span class=\"string\">\"client1\"</span>, <span class=\"string\">\"this message is from client1 to client2\"</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        send_wdt(sock,<span class=\"string\">\"client1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    close(sock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>  \n\n<details>\n<summary>sock.h</summary>  \n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"am5728.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CMD_RECV 0     <span class=\"comment\">//recv标志 0</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CMD_WDT 1      <span class=\"comment\">//wdt标志 1</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CMD_TRANSFER 2 <span class=\"comment\">//transfer标志 2</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WDT_REGISTER 0 <span class=\"comment\">//注册wdt表</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WDT_SIGNAL 1   <span class=\"comment\">//wdt发来的测试信号</span></span></span><br><span class=\"line\"><span class=\"comment\">//消息结构体</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> head[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cmd;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> wdt;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> target_name[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> source_name[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> msg[<span class=\"number\">512</span>];</span><br><span class=\"line\">&#125; PACKET;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MSG_LEGHTN sizeof(PACKET) <span class=\"comment\">//PACKET结构体的长度，也是接收和发送指定的长度</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CLI_NUM 10                <span class=\"comment\">//允许的客户端接收线程上限</span></span></span><br><span class=\"line\"><span class=\"comment\">//客户端进程与接收fd的表，结构体</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> client_name[CLI_NUM][<span class=\"number\">10</span>]; <span class=\"comment\">//存储客户端进程名的二维数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> client_recv_sock[CLI_NUM]; <span class=\"comment\">//存储客户端接收线程fd的数组</span></span><br><span class=\"line\">&#125; CLIENT_TABLE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//存放客户端看门狗计数的结构体</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> wdt_count[CLI_NUM];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> wdt_client_name[CLI_NUM][<span class=\"number\">10</span>];</span><br><span class=\"line\">&#125; WDT_STRUCT;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_other_process_pid</span><span class=\"params\">(<span class=\"keyword\">char</span> *process_name)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add_table</span><span class=\"params\">(CLIENT_TABLE *table, <span class=\"keyword\">char</span> *client_name, <span class=\"keyword\">int</span> sock)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search_fd</span><span class=\"params\">(CLIENT_TABLE *table, <span class=\"keyword\">char</span> *client_name)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">delete_fd</span><span class=\"params\">(CLIENT_TABLE *table, <span class=\"keyword\">int</span> sock)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add_wdt</span><span class=\"params\">(WDT_STRUCT *wdt, <span class=\"keyword\">char</span> *client_name)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">set_wdt_count_zero</span><span class=\"params\">(WDT_STRUCT *wdt, <span class=\"keyword\">char</span> *client_name)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">wdt_count</span><span class=\"params\">(WDT_STRUCT *wdt)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">server_socket</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *_ip, <span class=\"keyword\">int</span> _port)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msg_option</span><span class=\"params\">(PACKET *msg, CLIENT_TABLE *table, <span class=\"keyword\">int</span> sock, WDT_STRUCT *wdt)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">client_socket</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">transfer_msg</span><span class=\"params\">(<span class=\"keyword\">int</span> sock, <span class=\"keyword\">char</span> *target_name, <span class=\"keyword\">char</span> *source_name, <span class=\"keyword\">char</span> *content)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">register_wdt</span><span class=\"params\">(<span class=\"keyword\">int</span> sock, <span class=\"keyword\">char</span> *source_name)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">send_wdt</span><span class=\"params\">(<span class=\"keyword\">int</span> sock, <span class=\"keyword\">char</span> *source_name)</span></span>;</span><br></pre></td></tr></table></figure>\n\n</details>  \n\n<details>\n<summary>sock.h</summary>  \n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _AM5728_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _AM5728_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/select.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n</details>  \n","tags":[]},{"title":"知乎收藏","date":"2019-08-23T03:34:37.000Z","path":"2019/08/23/知乎收藏/","content":"<p>知乎干货类收藏汇总，收藏夹地址：<a href=\"https://www.zhihu.com/collection/407980345\" target=\"_blank\" rel=\"noopener\">干货</a></p>\n<h3 id=\"学习技巧\"><a href=\"#学习技巧\" class=\"headerlink\" title=\"学习技巧\"></a>学习技巧</h3><h4 id=\"有哪些高质量的自学网站？\"><a href=\"#有哪些高质量的自学网站？\" class=\"headerlink\" title=\"有哪些高质量的自学网站？\"></a><a href=\"https://www.zhihu.com/question/41476832\" target=\"_blank\" rel=\"noopener\">有哪些高质量的自学网站？</a></h4><h4 id=\"厉害的人是怎么分析问题的？\"><a href=\"#厉害的人是怎么分析问题的？\" class=\"headerlink\" title=\"厉害的人是怎么分析问题的？\"></a><a href=\"https://www.zhihu.com/question/304174916\" target=\"_blank\" rel=\"noopener\">厉害的人是怎么分析问题的？</a></h4><blockquote>\n<ul>\n<li><strong>问题是什么</strong><br>看问题要把握问题的本质<br>问题是期望与现状的落差部分，没有问题才是最大的问题<br>首先需要弄清楚问题，再想办法解决。问题是需要具体量化出来的，不能是含糊大概的</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>  \n<blockquote>\n<p><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/%E7%9F%A5%E4%B9%8E/1.png\" alt=\"1\"></p>\n</blockquote>\n<blockquote>\n<ul>\n<li><strong>如何描述一个问题</strong><br>明确期望值（B）<br>精准定位现状（B’）<br>用期望与现状差值（B’-B）精准描述问题<br>提出一个精准的问题，是你能找到正确答案的第一步，也是最重要的一步！<blockquote>\n<p>*<u>一个问题，就像是一盏路灯，只会照亮下方的特定区域。 你想要的答案，就像是一把遗失的钥匙，如果你想要找到它，就必须打开它上方的路灯才行。 但如果你问错了问题，就像是开错了灯，就永远也找不回那把钥匙了。*</u></p>\n</blockquote>\n</li>\n<li><strong>如何寻找答案</strong><br>表面问题，只是由本质问题导致的症状，而我们常常把症状当成了问题本身，于是急于去消除它， 而忽略了本质问题。<br>直接对着差值去找办法只能找到浅层的办法不能根治问题。这就要回到对问题的理解上去，看待问题不能只看表面问题，要着重分析问题的本质。从本质出发想办法才是解决问题正确有效的途径。</li>\n<li><strong>如何找到问题的本质</strong><br>别盯着问题看，需要做的事掌握足够多的信息来描述问题，这才是第一步；<br><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/%E7%9F%A5%E4%B9%8E/2.png\" alt=\"2\"><br><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/%E7%9F%A5%E4%B9%8E/3.png\" alt=\"3\">  <blockquote>\n<ul>\n<li>A：为了实现（B）的结果，所使用的方法。如果方法是错误的，目标自然无法达到。   </li>\n<li>B：期望值。目标设置不当，或者目标设定过高，那么即便完美做到了A，这个目标也无法达成； </li>\n<li>C：过程中出现的变量。方法和目标都没有问题，可是出现了意料之外的事，也有可能导致目标 无法达成…</li>\n</ul>\n</blockquote>\n</li>\n<li><strong>校准目标（B）</strong>。一个错误的目标，会让你的所有努力，都化为泡影遇。到问题别急着找办法找原因，首先分析看看自己的目标是否正确明朗。没有清晰的目标，问题永远不清晰，接下来怎么去解决更是一头雾水了。</li>\n<li><strong>设计目标的SMART原则</strong><blockquote>\n<ul>\n<li>Specific 明确的，具体的， 目标是否明确清晰？Measurable 可衡量的，衡量目标的完成度</li>\n<li>Achievable 可达到的 目标可达才是有效的目标</li>\n<li>Rewarding 满足感 完成一个目标获得与之难度对应的满足感是完成下一个目标的动力</li>\n<li>Time-bound 有时间限制的 做任何事设定任何目标一定要有时间限制。不同的时间限制会导致思考和指定计划的完全不同。如果没有时间限制，目标就是一句口号，起不到任何作用目标不对，什么都不对！</li>\n<li><em>用数据说话，对现象背后的数据分析的越透彻，对问题的理解对深刻*</em>。</li>\n</ul>\n</blockquote>\n</li>\n<li><strong>区别目标和手段</strong>：区分目标和手段 除了目标要遵循「SMART原则」外，你还得注意区分目标和手段。关不关窗是手段，开/关窗后想要达到的结果才是目的。在不伤害其他人的情况下，别纠结手段，达 到目的即可。所以，当你遇到一个问题的时候，第一步应该先检查一下的，你的目标是否符合SMART原则？你是否把手段本身当成了目标？</li>\n<li><strong>重构方法（A）</strong>：如果不改变原有的解决方案，现状就很难改变。<br>中国：洋务运动<br><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/%E7%9F%A5%E4%B9%8E/4.png\" alt=\"4\"><br>日本：明治维新<br><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/%E7%9F%A5%E4%B9%8E/5.png\" alt=\"5\">  </li>\n<li><em>想要大幅度改变现状，或者达成全新的目标，就得把原来的（A）一起改了，而不是在（B’）点上转弯*</em>。重复原有的方法，只能得到同样的结果；想要有不同的结果，就需要用不同的方法。</li>\n<li><strong>消除变量（C）</strong><br>要建立一个寻找问题的基本思考框架，叫做：象、数、理。任何一个「现象」背后一定有「数据」，任何「数据」的变动，背后一定有「道理」。把现象背后的数据分解的越细，看到的问题就会越精准。如果AB都没有问题，问题依然存在，一定存在着变量，你可以通过「象、数、理」这个基本框架来 寻找它，并通过5Why的提问方法，挖掘真正的原因。</li>\n<li><strong>在一秒钟内看到本质的人，和花半 辈子也看不清一件事本质的人，自然是不一样的命运。—-马里奥·普佐《教父》*</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"研究生新生要怎么看论文？\"><a href=\"#研究生新生要怎么看论文？\" class=\"headerlink\" title=\"研究生新生要怎么看论文？\"></a><a href=\"https://www.zhihu.com/question/304334959\" target=\"_blank\" rel=\"noopener\">研究生新生要怎么看论文？</a></h4><blockquote>\n<p><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/%E7%9F%A5%E4%B9%8E/6.png\" alt=\"6\">  </p>\n<ul>\n<li>如何判断手头的这篇文献和自己的领域相关值得精度？</li>\n<li>那些在阅读中遇到的生单词 (学术专业词汇除外) 真的会对通篇的理解形成严重障碍吗？</li>\n<li>“读懂”的定义是什么？没有输出反馈的文献阅读对我们的科研积累到底有没有价值？</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>列表：</p>\n<blockquote>\n<ul>\n<li>序号</li>\n<li>文献名称</li>\n<li>文献类型(期刊、硕论、博论)</li>\n<li>发表年份</li>\n<li>关键部分（用来记录本篇文章你认为关键的地方，标注好内容和页码）</li>\n<li>研究方法（可以看出此类问题，大家都是采用一个什么样的方法去解决的）</li>\n<li>存在问题（如前所述）</li>\n<li>产生原因（有些文献可能没有，没有即不写）</li>\n<li>解决方法（如前所述） </li>\n<li>创新点 </li>\n<li>下一步工作/不足之处（别人论文里的不足可能是你idea的来源）</li>\n</ul>\n</blockquote>\n</blockquote>\n<blockquote>\n<ul>\n<li><strong>学会精读和泛读</strong></li>\n<li><strong>总结提炼、吸收转化</strong><blockquote>\n<p>做review：<br><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/%E7%9F%A5%E4%B9%8E/13.png\" alt=\"13\"><br>留心总结论文中用到的求解技巧/算法<br>亲自编程/设计实验仿真再现论文中的结果</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"没有导师的指导，研究生如何阅读文献、提出创见、写论文？\"><a href=\"#没有导师的指导，研究生如何阅读文献、提出创见、写论文？\" class=\"headerlink\" title=\"没有导师的指导，研究生如何阅读文献、提出创见、写论文？\"></a><a href=\"https://www.zhihu.com/question/23647187\" target=\"_blank\" rel=\"noopener\">没有导师的指导，研究生如何阅读文献、提出创见、写论文？</a></h4><h4 id=\"科研大牛们怎么读文献？\"><a href=\"#科研大牛们怎么读文献？\" class=\"headerlink\" title=\"科研大牛们怎么读文献？\"></a><a href=\"https://www.zhihu.com/question/21278186\" target=\"_blank\" rel=\"noopener\">科研大牛们怎么读文献？</a></h4><blockquote>\n<p><strong>读文献要读人，读典和读新</strong>。</p>\n<ul>\n<li>读人<br>系统性搜寻文章——文章的阅读与归类——文章的分析和个人思考</li>\n<li>读经典（或者优秀的文章）<blockquote>\n<ol>\n<li>本领域内大家一直在讨论的、周围的人（导师、同事等等）一直推荐给你的文章，应该都没有太大的问题。</li>\n<li>平时要注意关注本领域的一些顶级科学家，比如我所在领域的Chris Voigt，James Collins等等。在谷歌建立的学者页会有列出所有相关的文章，按照引用率的排序，一般引用率比较高的都属于非常好的文章，可以作为经典来读。</li>\n<li>同时无论是谷歌学术搜索都会给出某领域或者某杂志的引用率最高的文章排序，这种以引用率为评价标准的一般问题都不大。</li>\n</ol>\n</blockquote>\n</li>\n<li>读新<br>读新读新则是对所关注领域的最新进展。利用文献订阅工具进行最新文献的获取，例如Google Scholar、Researcher App、Stork以及相关相关杂志网站的订阅服务。</li>\n</ul>\n</blockquote>\n<h4 id=\"你写论文时发现了哪些神网站？\"><a href=\"#你写论文时发现了哪些神网站？\" class=\"headerlink\" title=\"你写论文时发现了哪些神网站？\"></a><a href=\"https://www.zhihu.com/question/35931336\" target=\"_blank\" rel=\"noopener\">你写论文时发现了哪些神网站？</a></h4><h4 id=\"碎片化时代，有哪些高效的学习方法？\"><a href=\"#碎片化时代，有哪些高效的学习方法？\" class=\"headerlink\" title=\"碎片化时代，有哪些高效的学习方法？\"></a><a href=\"https://www.zhihu.com/question/301990435\" target=\"_blank\" rel=\"noopener\">碎片化时代，有哪些高效的学习方法？</a></h4><h4 id=\"你用过哪些强大的快捷键？\"><a href=\"#你用过哪些强大的快捷键？\" class=\"headerlink\" title=\"你用过哪些强大的快捷键？\"></a><a href=\"https://www.zhihu.com/question/276786944\" target=\"_blank\" rel=\"noopener\">你用过哪些强大的快捷键？</a></h4><blockquote>\n<ul>\n<li><strong>F4</strong>：重复上一次操作；</li>\n<li><strong>ctrl+P</strong>：打印，在无法复制文本的网页中开启打印预览。</li>\n</ul>\n</blockquote>\n<h4 id=\"有哪些看起来高大上，实际上却很简单的摄影技巧？\"><a href=\"#有哪些看起来高大上，实际上却很简单的摄影技巧？\" class=\"headerlink\" title=\"有哪些看起来高大上，实际上却很简单的摄影技巧？\"></a><a href=\"https://www.zhihu.com/question/38992328\" target=\"_blank\" rel=\"noopener\">有哪些看起来高大上，实际上却很简单的摄影技巧？</a></h4><h4 id=\"理工科科研结果展示怎样让-PPT-高大上？\"><a href=\"#理工科科研结果展示怎样让-PPT-高大上？\" class=\"headerlink\" title=\"理工科科研结果展示怎样让 PPT 高大上？\"></a><a href=\"https://www.zhihu.com/question/37422718\" target=\"_blank\" rel=\"noopener\">理工科科研结果展示怎样让 PPT 高大上？</a></h4><h4 id=\"有什么书值得推荐给大学生看？\"><a href=\"#有什么书值得推荐给大学生看？\" class=\"headerlink\" title=\"有什么书值得推荐给大学生看？\"></a><a href=\"https://www.zhihu.com/question/22903927\" target=\"_blank\" rel=\"noopener\">有什么书值得推荐给大学生看？</a></h4><blockquote>\n<p>《如何阅读一本书》<br>《社会心理学》<br>《金字塔原理》<br>《非暴力沟通》<br>《学习之道》<br>《明朝那些事儿》<br>《富爸爸穷爸爸》<br>《我们仨》<br>《围城》<br>《学会提问》<br>《自控力》<br>《平凡的世界》<br>《亲密关系》<br>《高效能人士的七个习惯》<br>《乌合之众》</p>\n</blockquote>\n<h3 id=\"修仙宝典\"><a href=\"#修仙宝典\" class=\"headerlink\" title=\"修仙宝典\"></a>修仙宝典</h3><h4 id=\"Linux初学者-学习资料\"><a href=\"#Linux初学者-学习资料\" class=\"headerlink\" title=\"Linux初学者(学习资料)\"></a><a href=\"https://zhuanlan.zhihu.com/p/21723250\" target=\"_blank\" rel=\"noopener\">Linux初学者(学习资料)</a></h4><h4 id=\"作为电子信息工程的学生，学完stm32后，是应该学fpga还是Linux\"><a href=\"#作为电子信息工程的学生，学完stm32后，是应该学fpga还是Linux\" class=\"headerlink\" title=\"作为电子信息工程的学生，学完stm32后，是应该学fpga还是Linux?\"></a><a href=\"https://www.zhihu.com/question/320595390\" target=\"_blank\" rel=\"noopener\">作为电子信息工程的学生，学完stm32后，是应该学fpga还是Linux?</a></h4><h4 id=\"一段鬼畜的代码\"><a href=\"#一段鬼畜的代码\" class=\"headerlink\" title=\"一段鬼畜的代码\"></a><a href=\"https://zhuanlan.zhihu.com/p/60607289\" target=\"_blank\" rel=\"noopener\">一段鬼畜的代码</a></h4><h4 id=\"程序员一般可以从什么平台接私活？\"><a href=\"#程序员一般可以从什么平台接私活？\" class=\"headerlink\" title=\"程序员一般可以从什么平台接私活？\"></a><a href=\"https://www.zhihu.com/question/275635770\" target=\"_blank\" rel=\"noopener\">程序员一般可以从什么平台接私活？</a></h4><h4 id=\"火爆网络的《神经网络与深度学习》，有人把它翻译成了中文版！\"><a href=\"#火爆网络的《神经网络与深度学习》，有人把它翻译成了中文版！\" class=\"headerlink\" title=\"火爆网络的《神经网络与深度学习》，有人把它翻译成了中文版！\"></a><a href=\"https://zhuanlan.zhihu.com/p/58144032\" target=\"_blank\" rel=\"noopener\">火爆网络的《神经网络与深度学习》，有人把它翻译成了中文版！</a></h4><h4 id=\"使用hexo，如果换了电脑怎么更新博客？\"><a href=\"#使用hexo，如果换了电脑怎么更新博客？\" class=\"headerlink\" title=\"使用hexo，如果换了电脑怎么更新博客？\"></a><a href=\"https://www.zhihu.com/question/21193762\" target=\"_blank\" rel=\"noopener\">使用hexo，如果换了电脑怎么更新博客？</a></h4><h4 id=\"怎样做一个漂亮的-GitHub-Pages-首页？\"><a href=\"#怎样做一个漂亮的-GitHub-Pages-首页？\" class=\"headerlink\" title=\"怎样做一个漂亮的 GitHub Pages 首页？\"></a><a href=\"https://www.zhihu.com/question/20376047\" target=\"_blank\" rel=\"noopener\">怎样做一个漂亮的 GitHub Pages 首页？</a></h4><h4 id=\"大家都是如何刷-LeetCode-的？\"><a href=\"#大家都是如何刷-LeetCode-的？\" class=\"headerlink\" title=\"大家都是如何刷 LeetCode 的？\"></a><a href=\"https://www.zhihu.com/question/280279208\" target=\"_blank\" rel=\"noopener\">大家都是如何刷 LeetCode 的？</a></h4><h4 id=\"数据说话：怎样的程序员最抢手？\"><a href=\"#数据说话：怎样的程序员最抢手？\" class=\"headerlink\" title=\"数据说话：怎样的程序员最抢手？\"></a><a href=\"https://zhuanlan.zhihu.com/p/19965583\" target=\"_blank\" rel=\"noopener\">数据说话：怎样的程序员最抢手？</a></h4><h4 id=\"刷-LeetCode-对于国内-IT-企业面试帮助大吗？\"><a href=\"#刷-LeetCode-对于国内-IT-企业面试帮助大吗？\" class=\"headerlink\" title=\"刷 LeetCode 对于国内 IT 企业面试帮助大吗？\"></a><a href=\"https://www.zhihu.com/question/31032841\" target=\"_blank\" rel=\"noopener\">刷 LeetCode 对于国内 IT 企业面试帮助大吗？</a></h4><h4 id=\"计算机系学生应该怎样正确管理自己的电脑？\"><a href=\"#计算机系学生应该怎样正确管理自己的电脑？\" class=\"headerlink\" title=\"计算机系学生应该怎样正确管理自己的电脑？\"></a><a href=\"https://www.zhihu.com/question/265575756\" target=\"_blank\" rel=\"noopener\">计算机系学生应该怎样正确管理自己的电脑？</a></h4><h4 id=\"编程新手如何提高编程能力？\"><a href=\"#编程新手如何提高编程能力？\" class=\"headerlink\" title=\"编程新手如何提高编程能力？\"></a><a href=\"https://www.zhihu.com/question/27574436\" target=\"_blank\" rel=\"noopener\">编程新手如何提高编程能力？</a></h4><blockquote>\n<p>要读文档，英文文档做知识输出，用文字总结自己的学习内容。多用命令行；<br>有问题，先文档，再stackoverflow，再技术文章要用实例驱动学习，不要说你会什么，要说你做了什么。</p>\n</blockquote>\n<h4 id=\"如果大学里你一开始就看了这篇文，离开时已经是高级码农\"><a href=\"#如果大学里你一开始就看了这篇文，离开时已经是高级码农\" class=\"headerlink\" title=\"如果大学里你一开始就看了这篇文，离开时已经是高级码农\"></a><a href=\"https://zhuanlan.zhihu.com/p/38338888\" target=\"_blank\" rel=\"noopener\">如果大学里你一开始就看了这篇文，离开时已经是高级码农</a></h4><h4 id=\"如何用-Github-找到需要的代码？\"><a href=\"#如何用-Github-找到需要的代码？\" class=\"headerlink\" title=\"如何用 Github 找到需要的代码？\"></a><a href=\"https://www.zhihu.com/question/324686541\" target=\"_blank\" rel=\"noopener\">如何用 Github 找到需要的代码？</a></h4><h4 id=\"GitHub-上的顶级项目都是做什么的？\"><a href=\"#GitHub-上的顶级项目都是做什么的？\" class=\"headerlink\" title=\"GitHub 上的顶级项目都是做什么的？\"></a><a href=\"https://zhuanlan.zhihu.com/p/58449931\" target=\"_blank\" rel=\"noopener\">GitHub 上的顶级项目都是做什么的？</a></h4><h3 id=\"应聘简历\"><a href=\"#应聘简历\" class=\"headerlink\" title=\"应聘简历\"></a>应聘简历</h3><h4 id=\"面试官问你的缺点是什么，应该如何回答？\"><a href=\"#面试官问你的缺点是什么，应该如何回答？\" class=\"headerlink\" title=\"面试官问你的缺点是什么，应该如何回答？\"></a><a href=\"https://www.zhihu.com/question/22357547\" target=\"_blank\" rel=\"noopener\">面试官问你的缺点是什么，应该如何回答？</a></h4><blockquote>\n<p>在谈到自己缺点的时候，尽量避开三观，性格方面的缺点。思维方式作为可选项，但不是优选项。最好还是着眼于知识和技能。因为这两点改进空间大，速度快。</p>\n<ul>\n<li><strong>往高处说：能力层次有高有低，请你挑一个与你目前所在层次相隔较远的能力缺陷来说。</strong></li>\n<li><strong>往远处说：术业有专攻，找一个与你本职工作间隔较远的专业能力缺陷来说。</strong></li>\n<li><strong>高标准、找不足</strong></li>\n</ul>\n</blockquote>\n<blockquote>\n<p>总得一句话——我的缺点就是有这个岗位的职业病，而有职业病——既说明了我有经验，又说明我比较专业，又符合别人对这个职业人士的人想象，基本无懈可击。一定要举例子！举例子！让狡猾的诚实变得更可信！</p>\n</blockquote>\n<h4 id=\"什么时候你觉得自己被面试官套路了？\"><a href=\"#什么时候你觉得自己被面试官套路了？\" class=\"headerlink\" title=\"什么时候你觉得自己被面试官套路了？\"></a><a href=\"https://www.zhihu.com/question/60999733\" target=\"_blank\" rel=\"noopener\">什么时候你觉得自己被面试官套路了？</a></h4><blockquote>\n<p><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/%E7%9F%A5%E4%B9%8E/7.png\" alt=\"7\"></p>\n</blockquote>\n<h4 id=\"三流大学和一流大学学生的简历有什么区别？\"><a href=\"#三流大学和一流大学学生的简历有什么区别？\" class=\"headerlink\" title=\"三流大学和一流大学学生的简历有什么区别？\"></a><a href=\"https://www.zhihu.com/question/296480350\" target=\"_blank\" rel=\"noopener\">三流大学和一流大学学生的简历有什么区别？</a></h4><blockquote>\n<ul>\n<li><p><strong>三流简历</strong>：<br>信息不完整<br>在简历上直接写自己的重大缺点<br>工作经历是求职重点，但全是口水话</p>\n</li>\n<li><p><strong>二流简历</strong>：<br>建议深度挖掘工作过程中，自己是怎么样思考，怎么样优化工作，以及获得了什么样的数据成果，获得了哪些能力的提升，从而增强简历的说服力。  </p>\n</li>\n<li><p><strong>一流简历</strong>:<br><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/%E7%9F%A5%E4%B9%8E/8.png\" alt=\"8\"><br>硬性条件：学校、学历、获奖经历都非常优秀工作经历：每一份工作经历的描写，都用到了STAR法则。<br>STAR法则是情境(situation)、任务(task)、行动(action)、结果(result)四项的缩写。具体含义是:  </p>\n</li>\n<li><p><em>Situation*</em>: 事情是在什么情况下发生  </p>\n</li>\n<li><p><em>Task*</em>: 你是如何明确你的任务的  </p>\n</li>\n<li><p><em>Action*</em>: 针对这样的情况分析，你采用了什么行动方式  </p>\n</li>\n<li><p><em>Result*</em>: 结果怎样，在这样的情况下你学习到了什么.  </p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"四大HR眼中的好简历是什么样子的？\"><a href=\"#四大HR眼中的好简历是什么样子的？\" class=\"headerlink\" title=\"四大HR眼中的好简历是什么样子的？\"></a><a href=\"https://www.zhihu.com/question/270327306\" target=\"_blank\" rel=\"noopener\">四大HR眼中的好简历是什么样子的？</a></h4><h4 id=\"如何评价应届生在面试中说的「虽然我没有经验，但是我非常愿意学习」这句话？\"><a href=\"#如何评价应届生在面试中说的「虽然我没有经验，但是我非常愿意学习」这句话？\" class=\"headerlink\" title=\"如何评价应届生在面试中说的「虽然我没有经验，但是我非常愿意学习」这句话？\"></a><a href=\"https://www.zhihu.com/question/26637304\" target=\"_blank\" rel=\"noopener\">如何评价应届生在面试中说的「虽然我没有经验，但是我非常愿意学习」这句话？</a></h4><h3 id=\"奇门遁甲\"><a href=\"#奇门遁甲\" class=\"headerlink\" title=\"奇门遁甲\"></a>奇门遁甲</h3><h4 id=\"有哪些堪称「神器」，却鲜为人知的软件-网站-互联网服务？\"><a href=\"#有哪些堪称「神器」，却鲜为人知的软件-网站-互联网服务？\" class=\"headerlink\" title=\"有哪些堪称「神器」，却鲜为人知的软件/网站/互联网服务？\"></a><a href=\"https://www.zhihu.com/question/36546814\" target=\"_blank\" rel=\"noopener\">有哪些堪称「神器」，却鲜为人知的软件/网站/互联网服务？</a></h4><blockquote>\n<ul>\n<li><strong>PHOTOZOOM PRO</strong>：它的原理是利用插值算法来放大图片，让分辨率较低的图片可以变得很清晰。</li>\n<li><strong>PPTMinimizer</strong>：这个压缩软件的强大之处在于，专门压缩WORD和POWERPOINT文件，压缩率高到吓死人，最高可以达到98%。</li>\n<li><strong>VideoMinimizer</strong>：视频压缩软件。</li>\n<li><strong>iSlide 插件</strong>：<a href=\"https://www.islide.cc\" target=\"_blank\" rel=\"noopener\">iSlide是一款基于PowerPoint的插件工具</a>，功能例如：环形复制、一键裁剪出相同尺寸的图片、一键统一PPT中的字体和段落、超强的图表样式库、支持自定义修改数据。<br><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/%E7%9F%A5%E4%B9%8E/9.png\" alt=\"9\">  </li>\n<li><strong>幕布</strong>：和Xmind类似的思维导图软件，兼具清单管理功能。<a href=\"https://mubu.com/apps\" target=\"_blank\" rel=\"noopener\">mubu.com</a></li>\n<li><strong>文字云</strong>：是一个支持中文的文字云生成工具，操作简单，而且方便！不需要翻墙。<a href=\"https://wordart.com\" target=\"_blank\" rel=\"noopener\">文字云地址</a></li>\n<li><strong>素材网页</strong><a href=\"https://www.iconfont.cn\" target=\"_blank\" rel=\"noopener\">Iconfont-阿里巴巴矢量图标库</a>，以及<a href=\"http://www.officeplus.cn/Template/Home.shtml\" target=\"_blank\" rel=\"noopener\">OfficePLUS，微软Office官方在线模板网站！</a></li>\n<li><strong>PPT遥控器</strong>：百度家的，<a href=\"http://ppt.baidu.com/\" target=\"_blank\" rel=\"noopener\">PPT遥控器</a>，只需电脑端安装，以备不时之需。</li>\n<li><strong>Collagelt</strong>：多图片同尺寸拼接。<br><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/%E7%9F%A5%E4%B9%8E/10.png\" alt=\"10\">  </li>\n<li><strong>Listary</strong>：和Everthing相似的文件查找工具，可以搜索软件。</li>\n<li><strong>天若OCR</strong>：文字识别工具，支持翻译，可以用于文献翻译。</li>\n<li><strong>Officelens</strong>：微软提供的扫描软件，可以一键生成word文档。</li>\n<li><strong>图片云Andrea Mosaic</strong>：小图片组合成大图片的软件。<br><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/%E7%9F%A5%E4%B9%8E/11.png\" alt=\"11\"></li>\n<li><strong>全世界优秀的网站大集合</strong>：<a href=\"http://www.world68.com\" target=\"_blank\" rel=\"noopener\">world68</a></li>\n<li><strong>SpaceSniffer</strong>：存储释放。</li>\n</ul>\n</blockquote>\n<h4 id=\"做PPT时有哪些神操作？\"><a href=\"#做PPT时有哪些神操作？\" class=\"headerlink\" title=\"做PPT时有哪些神操作？\"></a><a href=\"https://www.zhihu.com/question/65019555\" target=\"_blank\" rel=\"noopener\">做PPT时有哪些神操作？</a></h4><h4 id=\"你极力推荐的-Chrome-扩展有哪些？\"><a href=\"#你极力推荐的-Chrome-扩展有哪些？\" class=\"headerlink\" title=\"你极力推荐的 Chrome 扩展有哪些？\"></a><a href=\"https://www.zhihu.com/question/19594682\" target=\"_blank\" rel=\"noopener\">你极力推荐的 Chrome 扩展有哪些？</a></h4><h4 id=\"配眼镜，如何挑选眼镜框和镜片？有哪些常识或技巧？\"><a href=\"#配眼镜，如何挑选眼镜框和镜片？有哪些常识或技巧？\" class=\"headerlink\" title=\"配眼镜，如何挑选眼镜框和镜片？有哪些常识或技巧？\"></a><a href=\"https://www.zhihu.com/question/19856827\" target=\"_blank\" rel=\"noopener\">配眼镜，如何挑选眼镜框和镜片？有哪些常识或技巧？</a></h4><blockquote>\n<p><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/%E7%9F%A5%E4%B9%8E/12.png\" alt=\"12\"></p>\n</blockquote>\n","tags":[{"name":"知乎","slug":"知乎","permalink":"http://yoursite.com/tags/知乎/"}]},{"title":"CSDN网页收藏","date":"2019-08-21T14:44:09.000Z","path":"2019/08/21/CSDN网页收藏/","content":"<p>整理了CSDN网站上个人收藏的一堆网址！</p>\n<h2 id=\"Linux与操作系统\"><a href=\"#Linux与操作系统\" class=\"headerlink\" title=\"Linux与操作系统\"></a>Linux与操作系统</h2><hr>\n<h3 id=\"Linux操作系统\"><a href=\"#Linux操作系统\" class=\"headerlink\" title=\"Linux操作系统\"></a>Linux操作系统</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/sinat_36184075/article/details/71305568\" target=\"_blank\" rel=\"noopener\">《嵌入式linux应用开发完全手册》核心笔记(全) </a><br><a href=\"https://blog.csdn.net/qq_21794823/article/details/53196344\" target=\"_blank\" rel=\"noopener\">嵌入式linux学习路线参考（LINUX学习者必看经典）</a><br><a href=\"https://blog.csdn.net/Dreaming_My_Dreams/article/details/7750618\" target=\"_blank\" rel=\"noopener\">作为一个新人，怎样学习嵌入式Linux？</a><br><a href=\"https://blog.csdn.net/gui1259802368/article/details/72804175\" target=\"_blank\" rel=\"noopener\">linux必看书籍推荐 </a><br><a href=\"https://blog.csdn.net/gent__chen/article/details/50588328\" target=\"_blank\" rel=\"noopener\">linux下终端分屏使用</a><br><a href=\"https://blog.csdn.net/u013776495/article/details/52180676\" target=\"_blank\" rel=\"noopener\">LINUX和PC之间通过串口传文件 </a><br><a href=\"https://blog.csdn.net/a1317480843/article/details/80006028\" target=\"_blank\" rel=\"noopener\">LTP性能测试工具的使用详解</a><br><a href=\"https://blog.csdn.net/cui841923894/article/details/81463048\" target=\"_blank\" rel=\"noopener\">LTP(Linux Test Project)学习（二）——LTP下载编译执行 </a><br><a href=\"https://blog.csdn.net/kl28978113/article/details/85696545\" target=\"_blank\" rel=\"noopener\">内存稳定性测试软件(MemTest) </a><br><a href=\"https://blog.csdn.net/ugfffj/article/details/84001620\" target=\"_blank\" rel=\"noopener\">Linux性能测试工具-UnixBench–安装以及结果分析 </a><br><a href=\"https://blog.csdn.net/melody157398/article/details/24354415\" target=\"_blank\" rel=\"noopener\">LTP–linux稳定性测试 linux性能测试 ltp压力测试 —IBM 的 linux test project </a><br><a href=\"https://blog.csdn.net/encourage2011/article/details/72454582\" target=\"_blank\" rel=\"noopener\">Yocto 环境搭建 </a><br><a href=\"https://blog.csdn.net/minione_2016/article/details/53313271\" target=\"_blank\" rel=\"noopener\">ubuntu16.04安装matlab2016b </a><br><a href=\"https://blog.csdn.net/jesse_mx/article/details/53956358\" target=\"_blank\" rel=\"noopener\">Ubuntu 16.04安装Matlab 2016b教程 </a><br><a href=\"https://blog.csdn.net/yhaolpz/article/details/71375762\" target=\"_blank\" rel=\"noopener\">Ubuntu16.04 Caffe 安装步骤记录（超详尽）</a><br><a href=\"https://blog.csdn.net/baidu_27776187/article/details/78967734\" target=\"_blank\" rel=\"noopener\">secureCRT 实现windows和linux文件互传 </a><br><a href=\"https://blog.csdn.net/zhlh_xt/article/details/52458672\" target=\"_blank\" rel=\"noopener\">vim/vi 如何高效使用(键盘图打印版)</a><br><a href=\"https://blog.csdn.net/wangtaoking1/article/details/78005038\" target=\"_blank\" rel=\"noopener\">Ubuntu环境下安装nodejs和npm </a><br><a href=\"https://blog.csdn.net/gongxifacai_believe/article/details/52463126\" target=\"_blank\" rel=\"noopener\">使用Universal USB Installer创建安装Linux U盘系统</a><br><a href=\"https://blog.csdn.net/biubiuibiu/article/details/78044232\" target=\"_blank\" rel=\"noopener\">Source Insight 4.0 最简单的破解安装 </a><br><a href=\"https://blog.csdn.net/biubiuibiu/article/details/78044232\" target=\"_blank\" rel=\"noopener\">Ubuntu18.04（Gnome桌面）主题美化，Mac私人定制 </a></p>\n</blockquote>\n<a id=\"more\"></a>  \n\n<h3 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/qq_38410730/article/details/81488145\" target=\"_blank\" rel=\"noopener\"><strong>【Linux】Linux的共享内存</strong></a><br><a href=\"https://blog.csdn.net/ypt523/article/details/79958188\" target=\"_blank\" rel=\"noopener\">进程间通信——共享内存（Shared Memory）</a><br><a href=\"https://blog.csdn.net/guoping16/article/details/6584024\" target=\"_blank\" rel=\"noopener\">消息队列函数(msgget、msgctl、msgsnd、msgrcv)及其范例</a><br><a href=\"https://blog.csdn.net/e_wsq/article/details/73461835\" target=\"_blank\" rel=\"noopener\">Linux守护进程Shell脚本</a><br><a href=\"https://blog.csdn.net/hktkfly6/article/details/72585210\" target=\"_blank\" rel=\"noopener\">宋宝华的blog《Linux设备驱动开发详解》作者</a><br><a href=\"https://blog.csdn.net/21cnbao/article/details/7309757\" target=\"_blank\" rel=\"noopener\">Linux内核最新的连续内存分配器(CMA)——避免预留大块内存</a><br><a href=\"https://blog.csdn.net/itxiebo/article/details/51295881\" target=\"_blank\" rel=\"noopener\">Linux驱动开发之 三 (那些必须要了解的硬件知识 之 存储器篇) </a><br><a href=\"https://blog.csdn.net/xuyuefei1988/article/details/8635539\" target=\"_blank\" rel=\"noopener\">Make Menuconfig详解 （配置内核选择）</a><br><a href=\"https://blog.csdn.net/Tiger99111/article/details/82427425\" target=\"_blank\" rel=\"noopener\">内核配置与裁剪</a><br><a href=\"https://blog.csdn.net/R11101101/article/details/54910901\" target=\"_blank\" rel=\"noopener\">SSH工作原理</a><br><a href=\"https://blog.csdn.net/baidu_23187363/article/details/53891034\" target=\"_blank\" rel=\"noopener\">FreeRTOS实验_独立看门狗监视多线程</a><br><a href=\"https://blog.csdn.net/u012630961/article/details/79632547\" target=\"_blank\" rel=\"noopener\">Linux 多进程多线程编程</a><br><a href=\"https://blog.csdn.net/len_yue_mo_fu/article/details/83957417\" target=\"_blank\" rel=\"noopener\">检查进程存在的5种方法</a></p>\n</blockquote>\n<h3 id=\"网络编程\"><a href=\"#网络编程\" class=\"headerlink\" title=\"网络编程\"></a>网络编程</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/lisonglisonglisong/article/details/22699675\" target=\"_blank\" rel=\"noopener\">Linux网络编程：socket文件传输范例</a><br><a href=\"https://blog.csdn.net/gatieme/article/details/50615112\" target=\"_blank\" rel=\"noopener\">Linux下套接字详解（五）—-基于fork多进程的TCP套接字（阻塞/同步/并发）</a><br><a href=\"https://blog.csdn.net/a1414345/article/details/72830427\" target=\"_blank\" rel=\"noopener\">【Linux网络编程】基于TCP多进程（fork）版本客户端/服务器</a><br><a href=\"https://blog.csdn.net/shine_journey/article/details/72641313\" target=\"_blank\" rel=\"noopener\">Linux下网络编程（2）——TCP多连接，1个server，多个client</a><br><a href=\"https://blog.csdn.net/sshhiixx/article/details/47377133\" target=\"_blank\" rel=\"noopener\"><strong>Linux网络编程(2)——采用TCP的基本server的实现</strong></a><br><a href=\"https://blog.csdn.net/maopig/article/details/17193021\" target=\"_blank\" rel=\"noopener\">sockaddr_in , sockaddr , in_addr区别Socket编程函数集（非常有用）</a><br><a href=\"https://blog.csdn.net/hellocsz/article/details/79520618\" target=\"_blank\" rel=\"noopener\">Socket进程间通信</a></p>\n</blockquote>\n<h3 id=\"Uboot\"><a href=\"#Uboot\" class=\"headerlink\" title=\"Uboot\"></a>Uboot</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/lee244868149/article/details/49721063\" target=\"_blank\" rel=\"noopener\">(3)uboot详解——饿了么，我们来喂“狗”吧 </a><br>[<a href=\"https://blog.csdn.net/itxiebo/article/details/51019523\" target=\"_blank\" rel=\"noopener\">u-boot分析导读</a><br><a href=\"https://blog.csdn.net/itxiebo/article/details/50991049\" target=\"_blank\" rel=\"noopener\">u-boot分析 七 (添加u-boot命令，学习u-boot命令实现原理)</a><br><a href=\"https://blog.csdn.net/kunkliu/article/details/79259857\" target=\"_blank\" rel=\"noopener\">【uboot】（第六章）uboot流程——命令行模式以及命令处理介绍 </a><br><a href=\"https://blog.csdn.net/zqixiao_09/article/details/50805936\" target=\"_blank\" rel=\"noopener\">Exynos4412 Uboot 移植（三）—— Uboot添加自定义命令 </a><br><a href=\"https://blog.csdn.net/lg1259156776/article/details/53364714\" target=\"_blank\" rel=\"noopener\">【ARM-Linux开发】U-Boot启动过程–详细版的完全分析 </a></p>\n</blockquote>\n<h2 id=\"嵌入式驱动开发\"><a href=\"#嵌入式驱动开发\" class=\"headerlink\" title=\"嵌入式驱动开发\"></a>嵌入式驱动开发</h2><hr>\n<h3 id=\"内核与设备树\"><a href=\"#内核与设备树\" class=\"headerlink\" title=\"内核与设备树\"></a>内核与设备树</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/vc66vcc/article/details/80409479\" target=\"_blank\" rel=\"noopener\">linux内核空间和用户空间的是怎样区别的，如何交互，如何从用户空间进入内核空间 </a><br><a href=\"https://blog.csdn.net/BEYOND629310/article/details/89330978\" target=\"_blank\" rel=\"noopener\">嵌入式Linux学习步骤 </a><br><a href=\"https://blog.csdn.net/lvwenshuai/article/details/6201719\" target=\"_blank\" rel=\"noopener\">Linux——linux学习全攻略 (转) </a><br><a href=\"https://blog.csdn.net/qq_36802111/article/details/82017256\" target=\"_blank\" rel=\"noopener\">Linux教程+操作系统教程</a><br><a href=\"https://blog.csdn.net/feixiaoxing/article/details/79913476\" target=\"_blank\" rel=\"noopener\">linux驱动编写（总结篇） </a><br><a href=\"https://blog.csdn.net/huangxin8707/article/details/46430353\" target=\"_blank\" rel=\"noopener\">ARM Linux 3.x的设备树（Device Tree）</a><br><a href=\"https://blog.csdn.net/jklinux/article/details/78701702\" target=\"_blank\" rel=\"noopener\">24 设备树里描述spi设备 </a><br><a href=\"https://blog.csdn.net/zqixiao_09/article/details/50889458\" target=\"_blank\" rel=\"noopener\">Linux 设备驱动开发 —— 设备树在platform设备驱动中的使用 </a><br><a href=\"https://blog.csdn.net/cyf15238622067/article/details/80194031\" target=\"_blank\" rel=\"noopener\">Linux通过内核查看芯片gpio配置使用情况 </a><br><a href=\"https://blog.csdn.net/weixin_37058227/article/details/81665011\" target=\"_blank\" rel=\"noopener\">linux驱动开发-文件系统与设备文件 </a><br><a href=\"https://blog.csdn.net/u014650722/article/details/79076352\" target=\"_blank\" rel=\"noopener\">linux内核设备树及编译 - storyteller的博客 - CSDN博客</a><br><a href=\"https://blog.csdn.net/ffmxnjm/article/details/72933915\" target=\"_blank\" rel=\"noopener\">LINUX内核目录文件说明以及配置并编译内核的方法</a><br><a href=\"https://blog.csdn.net/A642960662/article/details/66473733\" target=\"_blank\" rel=\"noopener\">嵌入式 Linux开发Kernel移植（二）——kernel内核配置和编译 </a><br><a href=\"https://blog.csdn.net/lp542718520/article/details/52210070\" target=\"_blank\" rel=\"noopener\">嵌入式Linux内核配置、裁剪与编译浅析（ARM版）</a><br><a href=\"https://blog.csdn.net/z3256789/article/details/80697464\" target=\"_blank\" rel=\"noopener\">适配ARM处理器的Linux内核 </a><br><a href=\"https://blog.csdn.net/a3121772305/article/details/81412415\" target=\"_blank\" rel=\"noopener\">基于arm的Linux内核编译 </a><br><a href=\"https://blog.csdn.net/Evahuangchen/article/details/48436279\" target=\"_blank\" rel=\"noopener\">ubuntu更新内核切换内核启动 </a></p>\n</blockquote>\n<h3 id=\"串口通信\"><a href=\"#串口通信\" class=\"headerlink\" title=\"串口通信\"></a>串口通信</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/mochouxiyan/article/details/2839509\" target=\"_blank\" rel=\"noopener\">LINUX 简单的串口读写实例</a><br><a href=\"https://blog.csdn.net/tanqiuwei/article/details/21236069\" target=\"_blank\" rel=\"noopener\">Linux下用C实现串口读写</a><br><a href=\"https://blog.csdn.net/wangqingchuan92/article/details/73497354\" target=\"_blank\" rel=\"noopener\">串口通信——接收串口数据并处理（C语言）</a><br><a href=\"https://blog.csdn.net/ruanjianruanjianruan/article/details/51690724\" target=\"_blank\" rel=\"noopener\">基于串口uart的 xyzModem协议 的传输文件的命令</a></p>\n</blockquote>\n<h3 id=\"SPI\"><a href=\"#SPI\" class=\"headerlink\" title=\"SPI\"></a>SPI</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/encourage2011/article/details/70833308\" target=\"_blank\" rel=\"noopener\">Linux Kernl添加spidev的设备节点</a><br><a href=\"https://blog.csdn.net/BorntoX/article/details/51871480\" target=\"_blank\" rel=\"noopener\">Linux系统自带spi驱动加载及应用程序编写方法详解</a><br><a href=\"https://blog.csdn.net/jklinux/article/details/74331212\" target=\"_blank\" rel=\"noopener\">63 linux内核的SPI设备驱动模型及应用程序调用SPI控制器的方法 </a><br><a href=\"https://blog.csdn.net/wordwarwordwar/article/details/79776140\" target=\"_blank\" rel=\"noopener\">SPI最大传输速率 - 坚持 - CSDN博客</a><br><a href=\"https://blog.csdn.net/weixin_39967781/article/details/81014788\" target=\"_blank\" rel=\"noopener\">SPI 时钟和相位详解，转载！</a></p>\n</blockquote>\n<h3 id=\"PCIE接口\"><a href=\"#PCIE接口\" class=\"headerlink\" title=\"PCIE接口\"></a>PCIE接口</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/Deep_l_zh/article/details/54616924\" target=\"_blank\" rel=\"noopener\">2016年12月问题记录与总结–PCIE调试心得 </a><br><a href=\"https://blog.csdn.net/mao0514/article/details/54140193\" target=\"_blank\" rel=\"noopener\">Linux PCI/PCI-E设备配置空间读取与修改 </a><br><a href=\"https://blog.csdn.net/xsc_c/article/details/32323781\" target=\"_blank\" rel=\"noopener\">利用 PlxSdk 工具包开发 Linux 下 PCI 设备驱动 </a><br><a href=\"https://blog.csdn.net/songsm1002/article/details/73469488\" target=\"_blank\" rel=\"noopener\">PCI接口开发笔记 </a><br><a href=\"https://blog.csdn.net/snaking616/article/details/72460746\" target=\"_blank\" rel=\"noopener\">Xilinx FPGA 的PCIE 设计 </a><br><a href=\"https://blog.csdn.net/snaking616/article/details/72460746\" target=\"_blank\" rel=\"noopener\">PCI-E 1x, 4x, 8x, 16x 接口定义 </a><br><a href=\"https://blog.csdn.net/lidisha/article/details/7753361\" target=\"_blank\" rel=\"noopener\">基于PLX_SDK的Linux下的PCI9054驱动程序的开发 </a></p>\n</blockquote>\n<h3 id=\"Flash\"><a href=\"#Flash\" class=\"headerlink\" title=\"Flash\"></a>Flash</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/qq_30866297/article/details/52104197\" target=\"_blank\" rel=\"noopener\">NAND FLASH （三）硬件ECC校验码详解 </a><br><a href=\"https://blog.csdn.net/king110108/article/details/80321618\" target=\"_blank\" rel=\"noopener\">ECC内存校验算法实现 </a><br><a href=\"https://blog.csdn.net/jiayu5100687/article/details/80059368\" target=\"_blank\" rel=\"noopener\">DDR的原理和时序 </a><br><a href=\"https://blog.csdn.net/wordwarwordwar/article/details/73677692\" target=\"_blank\" rel=\"noopener\">EMIF接口 </a><br><a href=\"https://blog.csdn.net/Qinus/article/details/84654483\" target=\"_blank\" rel=\"noopener\">DDR3详解（以Micron MT41J128M8 1Gb DDR3 SDRAM为例） </a><br><a href=\"https://blog.csdn.net/Projectaker/article/details/48876469\" target=\"_blank\" rel=\"noopener\">NAND FLASH大页和小页 </a><br><a href=\"https://blog.csdn.net/fyfcauc/article/details/39576065\" target=\"_blank\" rel=\"noopener\">硬盘基本知识（磁道、扇区、柱面、磁头数、簇、MBR、DBR）</a><br><a href=\"https://blog.csdn.net/ZCMUCZX/article/details/81226017\" target=\"_blank\" rel=\"noopener\">Linux当中block块大小的面试题 </a><br><a href=\"https://blog.csdn.net/swj9099/article/details/80620001\" target=\"_blank\" rel=\"noopener\">nand flash 个人觉得写得比较好的文章 </a><br><a href=\"https://blog.csdn.net/fairy0905/article/details/82766788\" target=\"_blank\" rel=\"noopener\">SDIO </a><br><a href=\"https://blog.csdn.net/u014645605/article/details/52259887\" target=\"_blank\" rel=\"noopener\">emmc 命令协议 </a><br><a href=\"https://blog.csdn.net/u013686019/article/details/66472291\" target=\"_blank\" rel=\"noopener\">eMMC之分区管理、总线协议和工作模式</a><br><a href=\"https://blog.csdn.net/guozhidixian/article/details/79595235\" target=\"_blank\" rel=\"noopener\">emmc的读写浅析 </a></p>\n</blockquote>\n<h2 id=\"开发软件\"><a href=\"#开发软件\" class=\"headerlink\" title=\"开发软件\"></a>开发软件</h2><hr>\n<h3 id=\"Github与MarkDown\"><a href=\"#Github与MarkDown\" class=\"headerlink\" title=\"Github与MarkDown\"></a>Github与MarkDown</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/qcx321/article/details/53780672\" target=\"_blank\" rel=\"noopener\">Markdown 语法大全 包括设置字体 颜色 </a><br><a href=\"https://blog.csdn.net/wudinaniya/article/details/77508229\" target=\"_blank\" rel=\"noopener\">删除github中某个文件夹 </a><br><a href=\"https://blog.csdn.net/youzhouliu/article/details/78952453\" target=\"_blank\" rel=\"noopener\">Git使用详细教程 </a><br><a href=\"https://blog.csdn.net/gemmem/article/details/7290125\" target=\"_blank\" rel=\"noopener\">git使用详细介绍</a><br><a href=\"https://blog.csdn.net/sinat_33224091/article/details/93149403\" target=\"_blank\" rel=\"noopener\">如何在 GitHub 上找到免费且实用的软件？</a><br><a href=\"https://blog.csdn.net/linshuhe1/article/details/73013730\" target=\"_blank\" rel=\"noopener\">Hexo个人免费博客(五) 使用自己的域名</a></p>\n</blockquote>\n<h3 id=\"C语言\"><a href=\"#C语言\" class=\"headerlink\" title=\"C语言\"></a>C语言</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/qq_41681241/article/details/81189099\" target=\"_blank\" rel=\"noopener\">c语言实现系统(Linux)文件权限的修改，以及系统文件的创建，写入和读取数据 </a><br><a href=\"https://blog.csdn.net/u011270542/article/details/70052472\" target=\"_blank\" rel=\"noopener\">读华为C语言编程规范（标识符、变量）</a><br><a href=\"https://blog.csdn.net/weiqifa0/article/details/54907118\" target=\"_blank\" rel=\"noopener\">C语言变量和函数命名规范 </a><br><a href=\"https://blog.csdn.net/wzzfeitian/article/details/40963457\" target=\"_blank\" rel=\"noopener\">cmake使用示例与整理总结 </a><br><a href=\"https://blog.csdn.net/xuguangsoft/article/details/8162757\" target=\"_blank\" rel=\"noopener\">CMake使用教程 </a><br><a href=\"https://blog.csdn.net/helloworld_ptt/article/details/86509138\" target=\"_blank\" rel=\"noopener\">如何编写CMakeLists</a><br><a href=\"https://blog.csdn.net/ruglcc/article/details/7814546\" target=\"_blank\" rel=\"noopener\">Makefile经典教程(掌握这些足够) </a><br><a href=\"https://blog.csdn.net/Cashey1991/article/details/7942809\" target=\"_blank\" rel=\"noopener\">getopt和getopt_long函数 </a><br><a href=\"https://blog.csdn.net/Grace_1203/article/details/79502075\" target=\"_blank\" rel=\"noopener\">C与C++的区别；面向过程与面向对象的区别；</a></p>\n</blockquote>\n<h3 id=\"FPGA\"><a href=\"#FPGA\" class=\"headerlink\" title=\"FPGA\"></a>FPGA</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/qq_33126189/article/details/79957314\" target=\"_blank\" rel=\"noopener\">FPGA 中关于LVDS引脚的配置 </a><br><a href=\"https://blog.csdn.net/phenixyf/article/details/42873699\" target=\"_blank\" rel=\"noopener\">（Xilinx）FPGA中LVDS差分高速传输的实现</a><br><a href=\"https://blog.csdn.net/hktkfly6/article/details/78444161\" target=\"_blank\" rel=\"noopener\">LVDS，接口，时序讲解，很赞的文章 </a></p>\n</blockquote>\n<h3 id=\"软件问题\"><a href=\"#软件问题\" class=\"headerlink\" title=\"软件问题\"></a>软件问题</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/qq_37248318/article/details/80839564\" target=\"_blank\" rel=\"noopener\">node.js安装后输入“node -v”提示’node’ 不是内部或外部命令，也不是可运行的程序的解决方法</a><br><a href=\"https://blog.csdn.net/u010752600/article/details/79534910\" target=\"_blank\" rel=\"noopener\">TensorFlow Bug记录 CUBLAS_STATUS_NOT_INITIALIZED</a><br><a href=\"https://blog.csdn.net/lile777/article/details/81389098\" target=\"_blank\" rel=\"noopener\">【解决】Invalid configuration <code>aarch64-linux&#39;: machine</code>aarch64’ not recognize</a><br><a href=\"https://blog.csdn.net/tianxiawuzhei/article/details/46441327\" target=\"_blank\" rel=\"noopener\">VS2013 编译程序时提示 无法查找或打开 PDB 文件 </a><br><a href=\"https://blog.csdn.net/MR1269427885/article/details/53283257\" target=\"_blank\" rel=\"noopener\">windows 64位 VS2015 “模块计算机类型“x64”与目标计算机类型“X86”冲突解决方案 </a><br><a href=\"https://blog.csdn.net/llfjcmx/article/details/81156593\" target=\"_blank\" rel=\"noopener\">联想Y7000装双系统win10+Ubuntu16.04后在Ubuntu上Wifi被禁用的解决办法 </a><br><a href=\"https://blog.csdn.net/serena9636/article/details/52530446\" target=\"_blank\" rel=\"noopener\">Python OpenCV 解决人脸识别报错cascade.detectMultiScale error </a><br><a href=\"https://blog.csdn.net/qq_36652619/article/details/79676742\" target=\"_blank\" rel=\"noopener\">ubuntu 下Anaconda3出现 conda：未找到命令 </a><br><a href=\"https://blog.csdn.net/a19990412/article/details/81197214\" target=\"_blank\" rel=\"noopener\">【解决方案】module ‘cv2.cv2’ has no attribute ‘xfeatures2d’ </a></p>\n</blockquote>\n<h3 id=\"opencv\"><a href=\"#opencv\" class=\"headerlink\" title=\"opencv\"></a>opencv</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/qq_41175905/article/details/80560429\" target=\"_blank\" rel=\"noopener\">VS2017配置opencv教程</a><br><a href=\"https://blog.csdn.net/leviopku/article/details/82659827\" target=\"_blank\" rel=\"noopener\">win10+VS2017下配置openCV3.4.3 </a><br><a href=\"https://blog.csdn.net/liyuqian199695/article/details/53913203\" target=\"_blank\" rel=\"noopener\">Eclipse（Java）配置opencv2.4.11 </a></p>\n</blockquote>\n<h3 id=\"人工智能\"><a href=\"#人工智能\" class=\"headerlink\" title=\"人工智能\"></a>人工智能</h3><blockquote>\n<p><a href=\"https://blog.csdn.net/zhangbangqian/article/details/79315738\" target=\"_blank\" rel=\"noopener\">OpenCV-Python 摄像头实时检测人脸 </a><br><a href=\"https://blog.csdn.net/vilmaigic/article/details/81412671\" target=\"_blank\" rel=\"noopener\">Ubuntu16.04下运行YOLO3及相关环境配置 </a><br><a href=\"https://blog.csdn.net/dcrmg/article/details/78496002\" target=\"_blank\" rel=\"noopener\">darknet YOLOv2安装及数据集训练 </a><br><a href=\"https://blog.csdn.net/u011021773/article/details/81298666\" target=\"_blank\" rel=\"noopener\">Ubuntu18.04 Caffe 安装步骤记录（超详尽） </a><br><a href=\"https://blog.csdn.net/helei001/article/details/53159690\" target=\"_blank\" rel=\"noopener\">学习TensorFlow，调用预训练好的网络（Alex, VGG, ResNet etc） </a><br><a href=\"https://blog.csdn.net/Blateyang/article/details/69842071\" target=\"_blank\" rel=\"noopener\">Ubuntu 16.04 下keras安装和mnist测试 TensorFlow学习笔记（九）：CIFAR-10训练例子报错解决 </a><br><a href=\"https://blog.csdn.net/yhl_leo/article/details/50738311\" target=\"_blank\" rel=\"noopener\">TensorFlow CNN 测试CIFAR-10数据集</a><br><a href=\"https://blog.csdn.net/hereiskxm/article/details/61916676\" target=\"_blank\" rel=\"noopener\">【神经网络】VGG、ResNet、GoogleLeNet、AlexNet等常用网络代码及预训练模型 </a><br><a href=\"https://blog.csdn.net/jiawoxuexiqq30294961/article/details/84668605\" target=\"_blank\" rel=\"noopener\">【云计算／大数据／人工智能】都这么火了，我居然还不知道他们是啥？看完全明白了！</a><br><a href=\"https://blog.csdn.net/wuguangbin1230/article/details/72886903\" target=\"_blank\" rel=\"noopener\">ubuntu 监视显卡使用情况 </a><br><a href=\"https://blog.csdn.net/ksws0292756/article/details/79143460\" target=\"_blank\" rel=\"noopener\">Ubuntu16.04下Anaconda3的安装 </a><br><a href=\"https://blog.csdn.net/qq_22186119/article/details/70327179\" target=\"_blank\" rel=\"noopener\">Linux入门(18)——Ubuntu16.04下安装spyder </a><br><a href=\"https://blog.csdn.net/Sparta_117/article/details/73739980\" target=\"_blank\" rel=\"noopener\">华硕笔记本(GTX 1060显卡)安装Ubuntu16.04+Nvidia显卡驱动+Cuda8.0+cudnn6.0+ROS+Opencv3.2+Caffe+Tensorflow</a><br><a href=\"https://blog.csdn.net/JackSparrow_sjl/article/details/81878270\" target=\"_blank\" rel=\"noopener\">Ubuntu 18.04系统NVIDIA+CUDA9.1+CUDnn7.1+TensorFlow安装 </a></p>\n</blockquote>\n","tags":[{"name":"CSDN","slug":"CSDN","permalink":"http://yoursite.com/tags/CSDN/"}]},{"title":"VScode WSL开发环境配置","date":"2019-08-10T06:40:08.000Z","path":"2019/08/10/vscode-wsl开发环境配置/","content":"<p>读研期间日常写文档用windows word，工作时使用linux码代码需要来回切换操作系统，幸亏遇到wsl ubuntu解决一大难题，但配置好开发环境（<a href=\"http://jianliang-shen.cn/2019/07/22/%E4%BD%BF%E7%94%A8VScode%E5%92%8CCmake%E6%90%AD%E5%BB%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/\" target=\"_blank\" rel=\"noopener\">使用VScode和Cmake搭建嵌入式开发环境</a>），使用windows版本的VScode有一大弊端–无法查看linux的头文件内容，无法跳转相关的函数和变量定义，简直扎心！无意中发现插件中有一个remote wsl的，真的让人awsl！微软真香！具体可以参考<a href=\"https://www.cnblogs.com/nczitzk/p/develop-in-wsl-with-vscode-remote.html\" target=\"_blank\" rel=\"noopener\">搭配 VS Code Remote 远程开发扩展在 WSL 下开发</a>。  </p>\n<a id=\"more\"></a>  \n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li>在运行remote wsl时，需要重新安装插件，这些插件和Windows VScode不同；</li>\n<li>在命令输入<code>remote wsl:new window</code>进入wsl vscode；</li>\n<li>VScode WSL是在linux下工作的，新建的终端也为linux bash，代码补全、头文件均为linux版本；</li>\n<li>关于git中文显示乱码问题，参考：<br><a href=\"https://blog.csdn.net/deepxl/article/details/17802451\" target=\"_blank\" rel=\"noopener\">ubuntu下设定系统locale，支持中文zh_CN.UTF-8</a><br><a href=\"https://www.cnblogs.com/york-hust/archive/2012/03/27/2419582.html\" target=\"_blank\" rel=\"noopener\">ubuntu命令行下中文乱码的解决方案</a><br>语言支持安装：<code>sudo apt install $(check-language-support) --fix-missing</code><br>git关闭编码设置：<code>git config --global core.quotepath false</code>  </li>\n</ol>\n","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Cmder美化WSL Ubuntu","date":"2019-08-10T06:06:52.000Z","path":"2019/08/10/cmder美化wsl-ubuntu/","content":"<p>WSL Ubuntu的界面比较简陋，推荐使用cmder改良一下终端。<br><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/cmder_wsl_ubuntu.JPG\" alt=\"avatar\">  </p>\n<a id=\"more\"></a>  \n<h2 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h2><p><a href=\"https://cmder.net/\" target=\"_blank\" rel=\"noopener\">cmder</a>，下载完整版，直接运行即可。  </p>\n<h2 id=\"进入wsl-ubuntu\"><a href=\"#进入wsl-ubuntu\" class=\"headerlink\" title=\"进入wsl ubuntu\"></a>进入wsl ubuntu</h2><p>在setting &gt; start up中添加 <code>%windir%\\system32\\wsl.exe ~   -cur_console:p5</code>，进入linux子系统。<br><code>-cur_console:p5</code>是最新的为解决vim中无法使用方向键的补丁。  </p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>大多数配置依照个人习惯，分屏快捷键可以搜索split。  </p>\n<h2 id=\"修改ubutnu文件夹底色\"><a href=\"#修改ubutnu文件夹底色\" class=\"headerlink\" title=\"修改ubutnu文件夹底色\"></a>修改ubutnu文件夹底色</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">dircolors -p &gt; .dircolors</span><br><span class=\"line\">vi .dircolors</span><br><span class=\"line\">修改DIR的颜色，找到下面这段（编辑器中有配色预览和注释）</span><br><span class=\"line\"></span><br><span class=\"line\">RESET 0 <span class=\"comment\"># reset to \"normal\" color                                        </span></span><br><span class=\"line\">DIR 04;36 <span class=\"comment\"># directory                                                    </span></span><br><span class=\"line\">LINK 01;36 <span class=\"comment\"># symbolic link. (If you set this to 'target' instead of a    </span></span><br><span class=\"line\"> <span class=\"comment\"># numerical value, the color is as for the file pointed to.)            </span></span><br><span class=\"line\">MULTIHARDLINK 00 <span class=\"comment\"># regular file with more than one link                  </span></span><br><span class=\"line\">FIFO 40;33 <span class=\"comment\"># pipe                                                        </span></span><br><span class=\"line\">SOCK 01;35 <span class=\"comment\"># socket                                                      </span></span><br><span class=\"line\">DOOR 01;35 <span class=\"comment\"># door                                                        </span></span><br><span class=\"line\">BLK 40;33;01 <span class=\"comment\"># block device driver                                       </span></span><br><span class=\"line\">CHR 40;33;01 <span class=\"comment\"># character device driver                                   </span></span><br><span class=\"line\">ORPHAN 40;31;01 <span class=\"comment\"># symlink to nonexistent file, or non-stat'able file ... </span></span><br><span class=\"line\">MISSING 00 <span class=\"comment\"># ... and the files they point to                             </span></span><br><span class=\"line\">SETUID 37;41 <span class=\"comment\"># file that is setuid (u+s)                                 </span></span><br><span class=\"line\">SETGID 30;43 <span class=\"comment\"># file that is setgid (g+s)</span></span><br><span class=\"line\">CAPABILITY 30;41 <span class=\"comment\"># file with capability</span></span><br><span class=\"line\">STICKY_OTHER_WRITABLE 04;36 <span class=\"comment\"># dir that is sticky and other-writable (+t,o+w)</span></span><br><span class=\"line\">OTHER_WRITABLE 04;36 <span class=\"comment\"># dir that is other-writable (o+w) and not sticky</span></span><br><span class=\"line\">STICKY 37;44 <span class=\"comment\"># dir with the sticky bit set (+t) and not other-writable</span></span><br><span class=\"line\"><span class=\"comment\"># This is for files with execute permission:</span></span><br><span class=\"line\">EXEC 01;32</span><br></pre></td></tr></table></figure>\n\n<p>修改bashrc或者zshrc，在bashrc中有如下内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [ -x /usr/bin/dircolors ]; <span class=\"keyword\">then</span>                                                        </span><br><span class=\"line\">    <span class=\"built_in\">test</span> -r ~/.dircolors &amp;&amp; <span class=\"built_in\">eval</span> <span class=\"string\">\"<span class=\"variable\">$(dircolors -b ~/.dircolors)</span>\"</span> || <span class=\"built_in\">eval</span> <span class=\"string\">\"<span class=\"variable\">$(dircolors -b)</span>\"</span> </span><br><span class=\"line\">    <span class=\"built_in\">alias</span> ls=<span class=\"string\">'ls --color=auto'</span>                                                            </span><br><span class=\"line\">    <span class=\"comment\">#alias dir='dir --color=auto'                                                         </span></span><br><span class=\"line\">    <span class=\"comment\">#alias vdir='vdir --color=auto'                                                       </span></span><br><span class=\"line\">                                                                                          </span><br><span class=\"line\">    <span class=\"built_in\">alias</span> grep=<span class=\"string\">'grep --color=auto'</span>                                                        </span><br><span class=\"line\">    <span class=\"built_in\">alias</span> fgrep=<span class=\"string\">'fgrep --color=auto'</span>                                                      </span><br><span class=\"line\">    <span class=\"built_in\">alias</span> egrep=<span class=\"string\">'egrep --color=auto'</span>                                                      </span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<p>拷贝至zsh中，重新启动终端，ubutnu显示的文件夹再也不是亮瞎人的绿色。</p>\n","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Linux指令合集","date":"2019-08-10T05:19:56.000Z","path":"2019/08/10/跟老男孩学Linux运维/","content":"<h2 id=\"第一章-Linux命令行简介\"><a href=\"#第一章-Linux命令行简介\" class=\"headerlink\" title=\"第一章  Linux命令行简介\"></a>第一章  Linux命令行简介</h2><h3 id=\"命令行提示符\"><a href=\"#命令行提示符\" class=\"headerlink\" title=\"命令行提示符\"></a>命令行提示符</h3><p><code>#</code> 超级用户<br><code>$</code> 普通用户  </p>\n<h3 id=\"重要快捷键\"><a href=\"#重要快捷键\" class=\"headerlink\" title=\"重要快捷键\"></a>重要快捷键</h3><table>\n<thead>\n<tr>\n<th>快捷键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ctrl+k</td>\n<td>删除光标到末尾的字符</td>\n</tr>\n<tr>\n<td>ctrl+u</td>\n<td>删除光标到开头的字符</td>\n</tr>\n<tr>\n<td>ctrl+c</td>\n<td>删除行或者中断任务</td>\n</tr>\n<tr>\n<td>ctrl+l</td>\n<td>clear 命令行</td>\n</tr>\n<tr>\n<td>ctrl+r</td>\n<td>搜索历史命令</td>\n</tr>\n<tr>\n<td>!!</td>\n<td>执行上一条命令</td>\n</tr>\n</tbody></table>\n<a id=\"more\"></a>  \n<h3 id=\"查看命令帮助\"><a href=\"#查看命令帮助\" class=\"headerlink\" title=\"查看命令帮助\"></a>查看命令帮助</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man 参数选项 命令、文件</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注：参数1是用户相关命令；2是系统调用；3是C的库函数相关；4是设备和特殊文件；8是系统管理员和进程。 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令 --help</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"关机、重启等\"><a href=\"#关机、重启等\" class=\"headerlink\" title=\"关机、重启等\"></a>关机、重启等</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shutdown -r now = reboot</span><br><span class=\"line\">shutdown -h now #立即关机</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第二章-文件和目录操作命令\"><a href=\"#第二章-文件和目录操作命令\" class=\"headerlink\" title=\"第二章  文件和目录操作命令\"></a>第二章  文件和目录操作命令</h2><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pwd</code></td>\n<td>显示当前路径</td>\n<td><code>echo $PWD</code> 可以输出</td>\n</tr>\n<tr>\n<td><code>cd</code></td>\n<td>切换目录</td>\n<td><code>～</code> home；<code>..</code> 上级；<code>-</code> 上次所在目录</td>\n</tr>\n<tr>\n<td><code>tree</code></td>\n<td>树形显示文件目录</td>\n<td><code>tree -L n</code> 显示n层；<code>tree -F</code> 为特殊文件增加标记</td>\n</tr>\n<tr>\n<td><code>tree -L 1 -d</code></td>\n<td>只显示目录</td>\n<td></td>\n</tr>\n<tr>\n<td><code>mkdir</code></td>\n<td>创建目录</td>\n<td></td>\n</tr>\n<tr>\n<td><code>mkdir -p dir1/{dir1_1,dir1_2}/{dir2_1,dir2_2}/..</code></td>\n<td>可同时创建多个目录</td>\n<td>大括号满足分配率，即1_1和1_2下都各自建立2_1和2_2</td>\n</tr>\n<tr>\n<td><code>touch</code></td>\n<td>创建空文件或改变文件的时间戳属性</td>\n<td>时间戳：<code>mtime</code>，最后修改时间；<code>ctime</code>，状态改变时间；<code>atime</code>，最后访问时间</td>\n</tr>\n<tr>\n<td><code>ls</code></td>\n<td>列举目录下的内容</td>\n<td><code>-t</code>按照修改时间排序；<code>-c</code>按照状态改变时间排序；<code>-u</code>按照最后访问排序</td>\n</tr>\n<tr>\n<td><code>ls --time-style=long-iso -lt</code></td>\n<td>令人舒适的时间格式</td>\n<td></td>\n</tr>\n<tr>\n<td>`ls lrt</td>\n<td>tail -l`</td>\n<td>显示最新更新过的文件</td>\n</tr>\n<tr>\n<td><code>ls -F</code></td>\n<td>显示文件类型</td>\n<td><code>*</code>可执行文件；<code>/</code>目录；<code>=</code>套接字；`</td>\n</tr>\n<tr>\n<td><code>cp</code></td>\n<td>复制目录</td>\n<td><code>cp -r</code>递归复制，包括子目录</td>\n</tr>\n<tr>\n<td><code>mv</code></td>\n<td>移动或者重命名</td>\n<td><code>mv A B</code>若B不存在，则将A重命名为B</td>\n</tr>\n</tbody></table>\n","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/命令/"}]},{"title":"Linux内核Kconfig解读","date":"2019-07-28T12:55:44.000Z","path":"2019/07/28/Linux内核Kconfig解读/","content":"<h2 id=\"内核的编译过程\"><a href=\"#内核的编译过程\" class=\"headerlink\" title=\"内核的编译过程\"></a>内核的编译过程</h2><p>arch=arm，tisdk_am57xx-evm-rt_defconfig确定了<code>.config</code>中的配置，主目录的<code>Makefile</code>按照<code>.config</code>文件中的选择遍历所有文件中的<code>Kconfig</code>（首先是arch/arm/Kconfig），按照<code>Kconfig</code>文件中的依赖关系编译文件，再回到顶层目录生成目标文件。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Kconfig ---&gt; （每个源码目录下）提供选项</span><br><span class=\"line\">.config ---&gt; （源码顶层目录下）保存选择结果</span><br><span class=\"line\">Makefile---&gt; （每个源码目录下）根据.config中的内容来告知编译系统如何编译</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>   \n<h2 id=\"配置过程–以驱动为例\"><a href=\"#配置过程–以驱动为例\" class=\"headerlink\" title=\"配置过程–以驱动为例\"></a>配置过程–以驱动为例</h2><h3 id=\"新建Kconfig\"><a href=\"#新建Kconfig\" class=\"headerlink\" title=\"新建Kconfig\"></a>新建Kconfig</h3><p>在/drivers/test下建立<code>Kconfig</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config TEST</span><br><span class=\"line\">    bool &quot;Test driver&quot;</span><br><span class=\"line\">    help</span><br><span class=\"line\">    This driver is for test kernel making.</span><br></pre></td></tr></table></figure>\n\n<p>这里定义了TEST选项，也就是.config中的<code>CONFIG_TEST</code>，Test driver是显示在menuconfig中的名称。</p>\n<h3 id=\"新建Makefile\"><a href=\"#新建Makefile\" class=\"headerlink\" title=\"新建Makefile\"></a>新建Makefile</h3><p>建立编译规则，例如CONFIG_TEST=y，目录下源码编译进内核；CONFIG_TEST=m，目录下源码编译为模块。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj-<span class=\"variable\">$(CONFIG_TEST)</span> += test.o</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置上层Makefile和Kconfig\"><a href=\"#配置上层Makefile和Kconfig\" class=\"headerlink\" title=\"配置上层Makefile和Kconfig\"></a>配置上层Makefile和Kconfig</h3><p>修改Kconfig，增加test子项，在drivers/Kconfig中添加：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &quot;drivers/test/Kconfig&quot;</span><br></pre></td></tr></table></figure>\n\n<p>修改Makefile，添加编译规则：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj-y               += test/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Kconfig详细语法\"><a href=\"#Kconfig详细语法\" class=\"headerlink\" title=\"Kconfig详细语法\"></a>Kconfig详细语法</h2><h3 id=\"关键词\"><a href=\"#关键词\" class=\"headerlink\" title=\"关键词\"></a>关键词</h3><p>以下面为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config SMP</span><br><span class=\"line\">\tbool &quot;Symmetric Multi-Processing&quot;</span><br><span class=\"line\">\tdepends on CPU_V6K || CPU_V7</span><br><span class=\"line\">\tdepends on GENERIC_CLOCKEVENTS</span><br><span class=\"line\">\tdepends on HAVE_SMP</span><br><span class=\"line\">\tdepends on MMU || ARM_MPU</span><br><span class=\"line\">\tselect IRQ_WORK</span><br><span class=\"line\">\thelp</span><br><span class=\"line\">\t  This enables support for systems with more than one CPU. If you have</span><br><span class=\"line\">\t  a system with only one CPU, say N. If you have a system with more</span><br><span class=\"line\">\t  than one CPU, say Y.</span><br><span class=\"line\">      ......</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>关键词</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>config</td>\n<td>紧跟句柄，SMP即为CONFIG_SMP</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>表示选择，0或1 [Y]</td>\n</tr>\n<tr>\n<td>“name”</td>\n<td>在menuconfig中显示的字符串，没有则不显示</td>\n</tr>\n<tr>\n<td>depends on</td>\n<td>表示依赖某一项，支持 `</td>\n</tr>\n<tr>\n<td>select</td>\n<td>表示选中后，也会选择select指定的项（被选择的无法取消，符号为-Y-或者{Y}）</td>\n</tr>\n<tr>\n<td>help</td>\n<td>打印帮助，menuconfig可以用shift+？查看</td>\n</tr>\n<tr>\n<td>tristate</td>\n<td>模块选项，<code>&lt;M&gt;</code>或者<code>&lt;Y&gt;</code>或者<code>&lt;N&gt;</code>（三态）</td>\n</tr>\n<tr>\n<td>int/hex/string</td>\n<td>选项值为整型数或十六进制数或字符串</td>\n</tr>\n<tr>\n<td>range</td>\n<td>整型数的范围</td>\n</tr>\n<tr>\n<td>default</td>\n<td>默认值，数值或者布尔y/n或者字符串或者choice中的选项</td>\n</tr>\n<tr>\n<td>prompt</td>\n<td>出现在choice中的菜单文字</td>\n</tr>\n<tr>\n<td>source</td>\n<td>引入子目录的Kconfig</td>\n</tr>\n</tbody></table>\n<p>补充：</p>\n<ul>\n<li><p>无depends on，default 为y：默认为y，一般用于必须要设置的选项，此时不要设置prompt；  </p>\n</li>\n<li><p>有depends on，default 为y：所依赖的条目己设置，则默认为y；所依赖的条目未设置，则为n；  </p>\n</li>\n<li><p>有depends on，default 为n：所依赖的条目己设置，则默认为n；所依赖的条目未设置，则为n；  </p>\n</li>\n<li><p>无depends on，default 为n：在为设置prompt的情况下，此选项想要被设置，需要由其他选项来select它。  </p>\n</li>\n</ul>\n<h3 id=\"结构语法\"><a href=\"#结构语法\" class=\"headerlink\" title=\"结构语法\"></a>结构语法</h3><h4 id=\"if…endif\"><a href=\"#if…endif\" class=\"headerlink\" title=\"if…endif\"></a>if…endif</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ARCH_S5PC100 ---&gt;如果ARCH_S5PC100选项选中了，则在endif范围内的选项才会被选</span><br><span class=\"line\">config CPU_S5PC100</span><br><span class=\"line\">    bool &quot;选项名&quot;</span><br><span class=\"line\">    select S5P_EXT_INT</span><br><span class=\"line\">    select SAMSUNG_DMADEV</span><br><span class=\"line\">    help</span><br><span class=\"line\">      Enable S5PC100 CPU support</span><br><span class=\"line\"></span><br><span class=\"line\">endif</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"choice…endchoice\"><a href=\"#choice…endchoice\" class=\"headerlink\" title=\"choice…endchoice\"></a>choice…endchoice</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">choice      ---&gt;表示选择列表</span><br><span class=\"line\">    prompt &quot;Default I/O scheduler&quot;         //主目录名字</span><br><span class=\"line\">    default DEFAULT_CFQ                    //默认CFQ</span><br><span class=\"line\">    help</span><br><span class=\"line\">      Select the I/O scheduler which will be used by default for all</span><br><span class=\"line\">      block devices.</span><br><span class=\"line\"></span><br><span class=\"line\">    config DEFAULT_DEADLINE</span><br><span class=\"line\">        bool &quot;Deadline&quot; if IOSCHED_DEADLINE=y </span><br><span class=\"line\"></span><br><span class=\"line\">    config DEFAULT_CFQ</span><br><span class=\"line\">        bool &quot;CFQ&quot; if IOSCHED_CFQ=y</span><br><span class=\"line\"></span><br><span class=\"line\">    config DEFAULT_NOOP</span><br><span class=\"line\">        bool &quot;No-op&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">endchoice</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"menu\"><a href=\"#menu\" class=\"headerlink\" title=\"menu\"></a>menu</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu &quot;Boot options&quot;  ----&gt; menu表示该选项是`不可选`的菜单，其后是在选择列表的菜单名</span><br><span class=\"line\"></span><br><span class=\"line\">config USE_OF</span><br><span class=\"line\">    bool &quot;Flattened Device Tree support&quot;</span><br><span class=\"line\">    select IRQ_DOMAIN</span><br><span class=\"line\">    select OF</span><br><span class=\"line\">    select OF_EARLY_FLATTREE</span><br><span class=\"line\">    help</span><br><span class=\"line\">      Include support for flattened device tree machine descriptions.</span><br><span class=\"line\">....</span><br><span class=\"line\"></span><br><span class=\"line\">endmenu     ----&gt; menu菜单结束</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"menuconfig\"><a href=\"#menuconfig\" class=\"headerlink\" title=\"menuconfig\"></a>menuconfig</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menuconfig TEST ---&gt; menuconfig表示TEST是一个`可选`菜单，其选中后是CONFIG_TEST</span><br><span class=\"line\">    bool &quot;菜单名&quot;</span><br><span class=\"line\">if TEST</span><br><span class=\"line\">...</span><br><span class=\"line\">endif # TEST</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>menu 和 choice 的区别：<br>menu可以多选；choice为单选。</li>\n<li>menuconfig 和 menu 的区别：<br>menuconfig本身是可以选中，而menu只能进入子菜单选择，一般menuconfig的句柄是子项的依赖项，而menu是子项的汇总。</li>\n</ul>\n","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"kernel","slug":"kernel","permalink":"http://yoursite.com/tags/kernel/"}]},{"title":"linux内核配置--Boot options","date":"2019-07-24T12:21:19.000Z","path":"2019/07/24/linux内核配置-Boot-options/","content":"<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核的配置过程依赖Makefile和arch/arm/Kconfig以及其他文件下的Kconfig文件，通过make menuconfig或者桌面环境下的xconfig/gconfig可以手动配置内核所支持的功能。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下为Boot options启动设置的配置。  </p>\n<a id=\"more\"></a>\n<h2 id=\"Y-Flattened-Device-Tree-support\"><a href=\"#Y-Flattened-Device-Tree-support\" class=\"headerlink\" title=\"-Y- Flattened Device Tree support\"></a>-Y- Flattened Device Tree support</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支持设备树。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Include support for flattened device tree machine descriptions.  </p>\n<ul>\n<li><code>[Y] Support for the traditional ATAGS boot data passing</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支持传统的ATAGS启动数据传递。除非仅依赖设备树，否则建议选择。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ATAGS是传统的linux内核接收参数的方式，另一种是DTB。设备启动时，BOOT向内核传递三个参数，其中R0寄存器内容为一个“0”，R1是机器码（与内核匹配），R3为ATAGS或者DTB传递的地址。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is the traditional way of passing data to the kernel at boot time. If you are solely relying on the flattened device tree (or the ARM_ATAG_DTB_COMPAT option) then you may unselect this option to remove ATAGS support from your kernel binary. If unsure, leave this to y.    <ul>\n<li><code>[N] Provide old way to pass kernel parameters</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供传递内核参数的旧方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This was deprecated in 2001 and announced to live on for 5 years. Some old boot loaders still use this way.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"0x0-Compressed-ROM-boot-loader-base-address\"><a href=\"#0x0-Compressed-ROM-boot-loader-base-address\" class=\"headerlink\" title=\"(0x0) Compressed ROM boot loader base address\"></a>(0x0) Compressed ROM boot loader base address</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default “0”<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存放基地址，对zImage压缩镜像启动很重要。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The physical address at which the ROM-able zImage is to be placed in the target.  Platforms which normally make use of ROM-able zImage formats normally set this to a suitable value in their defconfig file.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If ZBOOT_ROM is not enabled, this has no effect.</p>\n<h2 id=\"0x0-Compressed-ROM-boot-loader-BSS-address\"><a href=\"#0x0-Compressed-ROM-boot-loader-BSS-address\" class=\"headerlink\" title=\"(0x0) Compressed ROM boot loader BSS address\"></a>(0x0) Compressed ROM boot loader BSS address</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default “0”<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引导的BSS地址。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The base address of an area of read/write memory in the target for the ROM-able zImage which must be available while the decompressor is running. It must be large enough to hold the entire decompressed kernel plus an additional 128 KiB.Platforms which normally make use of ROM-able zImage formats normally set this to a suitable value in their defconfig file.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If ZBOOT_ROM is not enabled, this has no effect.</p>\n<h2 id=\"Y-Use-appended-device-tree-blob-to-zImage-EXPERIMENTAL\"><a href=\"#Y-Use-appended-device-tree-blob-to-zImage-EXPERIMENTAL\" class=\"headerlink\" title=\"[Y] Use appended device tree blob to zImage (EXPERIMENTAL)\"></a>[Y] Use appended device tree blob to zImage (EXPERIMENTAL)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将附加的设备树blob用于zImage（实验）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;With this option, the boot code will look for a device tree binary (DTB) appended to zImage (e.g. cat zImage <filename>.dtb &gt; zImage_w_dtb).This is meant as a backward compatibility convenience for those systems with a bootloader that can’t be upgraded to accommodate the documented boot protocol using a device tree. Beware that there is very little in terms of protection against this option being confused by leftover garbage in memory that might look like a DTB header after a reboot if no actual DTB is appended to Image.  Do not leave this option active in a production kernel if you don’t intend to always append a DTB.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Proper passing of the location into r2 of a bootloader provided DTB is always preferable to this option.  </filename></p>\n<ul>\n<li><code>[Y] Supplement the appended DTB with traditional ATAG information</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用传统的ATAG信息补充附加的DTB<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some old bootloaders can’t be updated to a DTB capable one, yet they provide ATAGs with memory configuration, the ramdisk address, the kernel cmdline string, etc.Such information is dynamically provided by the bootloader and can’t always be stored in a static DTB. To allow a device tree enabled kernel to be used with such bootloaders, this option allows zImage to extract the information from the ATAG list and store it at run time into the appended DTB.</li>\n</ul>\n<h2 id=\"C-Kernel-command-line-type\"><a href=\"#C-Kernel-command-line-type\" class=\"headerlink\" title=\"[C] Kernel command line type\"></a>[C] Kernel command line type</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核命令行类型。  </p>\n<ul>\n<li><code>[X] Use bootloader kernel arguments if available</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优先使用bootloader（uboot）参数，如果没有就使用DTB ARGS。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为通过uboot修改环境变量比修改内核容易得多，因此使用bootloader更方便。造成的问题是内核配置的变量可能被覆盖。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uses the command-line options passed by the boot loader instead of the device tree bootargs property. If the boot loader doesn’t provide any, the device tree bootargs property will be used.  </li>\n<li><code>[N] Extend with bootloader kernel arguments</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用DTB ARGS，bootloader提供的追加在其之后。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The command-line arguments provided by the boot loader will be appended to the the device tree bootargs property.</li>\n</ul>\n<h2 id=\"N-Default-kernel-command-string\"><a href=\"#N-Default-kernel-command-string\" class=\"headerlink\" title=\"(N) Default kernel command string\"></a>(N) Default kernel command string</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认的内核命令行字符串。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;On some architectures (EBSA110 and CATS), there is currently no way for the boot loader to pass arguments to the kernel. For these architectures, you should supply some command-line options at build time by entering them here. As a minimum, you should specify the memory size and the root device (e.g., mem=64M root=/dev/nfs). </p>\n<h2 id=\"N-Build-kdump-crash-kernel-EXPERIMENTAL\"><a href=\"#N-Build-kdump-crash-kernel-EXPERIMENTAL\" class=\"headerlink\" title=\"[N] Build kdump crash kernel (EXPERIMENTAL)\"></a>[N] Build kdump crash kernel (EXPERIMENTAL)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支持core dump的内核调试工具。Kdump是系统崩溃时，通过kexec工具转储内存（运行在一个主内核不占用的额外的内存区域）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate crash dump after being started by kexec. This should be normally only set in special crash dump kernels which are loaded in the main kernel with kexec-tools into a specially reserved region and then later executed after a crash by kdump/kexec. The crash dump kernel must be compiled to a memory address not used by the main kernel. For more details see Documentation/kdump/kdump.txt</p>\n<h2 id=\"Y-Auto-calculation-of-the-decompressed-kernel-image-address\"><a href=\"#Y-Auto-calculation-of-the-decompressed-kernel-image-address\" class=\"headerlink\" title=\"-Y- Auto calculation of the decompressed kernel image address\"></a>-Y- Auto calculation of the decompressed kernel image address</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动计算解压缩的内核映像地址。如果选择，开机后内核地址为0xf8000000，即在前128MB的位置（0x8000000=128<em>1024</em>1024）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZRELADDR is the physical address where the decompressed kernel image will be placed. If AUTO_ZRELADDR is selected, the address will be determined at run-time by masking the current IP with 0xf8000000. This assumes the zImage being placed in the first 128MB from start of memory.</p>\n<h2 id=\"Y-UEFI-runtime-support\"><a href=\"#Y-UEFI-runtime-support\" class=\"headerlink\" title=\"[Y] UEFI runtime support\"></a>[Y] UEFI runtime support</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此选项提供对UEFI固件提供的运行时服务的支持（例如非易失性变量，实时时钟和平台重置）。还提供UEFI存根以允许内核作为EFI应用程序引导。这仅适用于可能在具有UEFI固件的系统上运行的内核。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This option provides support for runtime services provided by UEFI firmware (such as non-volatile variables, realtime clock, and platform reset). A UEFI stub is also provided to allow the kernel to be booted as an EFI application. This is only useful for kernels that may run on systems that have UEFI firmware.  </p>\n<ul>\n<li><code>[Y] Enable support for SMBIOS (DMI) tables</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This enables SMBIOS/DMI feature for systems. This option is only useful on systems that have UEFI firmware. However, even with this option, the resultant kernel should continue to boot on existing non-UEFI platforms.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NOTE: This does <em>NOT</em> enable or encourage the use of DMI quirks, i.e., the the practice of identifying the platform via DMI to decide whether certain workarounds for buggy hardware and/or firmware need to be enabled. This would require the DMI subsystem to be enabled much earlier than we do on ARM, which is non-trivial.</li>\n</ul>\n","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"kernel","slug":"kernel","permalink":"http://yoursite.com/tags/kernel/"}]},{"title":"编译内核用到的图形界面工具","date":"2019-07-22T09:48:33.000Z","path":"2019/07/22/编译内核用到的图形界面工具/","content":"<h2 id=\"menuconfig\"><a href=\"#menuconfig\" class=\"headerlink\" title=\"menuconfig\"></a>menuconfig</h2><p>运行在没有桌面环境的主机上，可以查看选项功能，不支持搜索，需要安装终端的图形包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make menuconfig  </span><br><span class=\"line\">$ sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>  \n<h2 id=\"xconfig\"><a href=\"#xconfig\" class=\"headerlink\" title=\"xconfig\"></a>xconfig</h2><p>可以查看选项功能，支持搜索功能，需要安装QT依赖包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make xconfig</span><br><span class=\"line\">$ CHECK   qt</span><br><span class=\"line\">$ Could not find Qt via pkg-config.</span><br><span class=\"line\">$ Please install either Qt 4.8 or 5.x. and make sure it&apos;s in PKG_CONFIG_PATH</span><br><span class=\"line\">$ apt-get install qt4-dev-tools</span><br></pre></td></tr></table></figure>\n\n<p>安装后运行如下：<br><img src=\"https://github.com/sjl3110/pictures-for-hexo/blob/master/xconfig.png?raw=true\" alt=\"avatar\"></p>\n<h2 id=\"gconfig\"><a href=\"#gconfig\" class=\"headerlink\" title=\"gconfig\"></a>gconfig</h2><p>可以查看选项功能，需要安装gtk的包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make gconfig</span><br><span class=\"line\"></span><br><span class=\"line\">$ Unable to find the GTK+ installation. Please make sure that</span><br><span class=\"line\">$ the GTK+ 2.0 development package is correctly installed...</span><br><span class=\"line\">$ You need gtk+-2.0, glib-2.0 and libglade-2.0.</span><br><span class=\"line\">$  sudo apt-get install libgtk2.0-dev libglib2.0-dev libglade2-dev</span><br></pre></td></tr></table></figure>\n\n<p>安装后运行如下：<br><img src=\"https://github.com/sjl3110/pictures-for-hexo/blob/master/gconfig.png?raw=true\" alt=\"avatar\"></p>\n","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"kernel","slug":"kernel","permalink":"http://yoursite.com/tags/kernel/"}]},{"title":"使用VScode和Cmake搭建嵌入式开发环境","date":"2019-07-22T09:45:53.000Z","path":"2019/07/22/使用VScode和Cmake搭建嵌入式开发环境/","content":"<h1 id=\"配置主机开发环境\"><a href=\"#配置主机开发环境\" class=\"headerlink\" title=\"配置主机开发环境\"></a>配置主机开发环境</h1><p>1) 安装Ubuntu 16.04操作系统，双系统、虚拟机、单系统或windows子系统<br>2) 安装TI SDK并配置交叉编译环境，并配置环境变量<br>3) 安装SecureCRT或者minicom等串口软件，运行secureCRT或者minicom均需要超级权限sudo。<br>4) 配置有线以太网地址（ipv4）  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Address:192.168.111.101</span><br><span class=\"line\">Netmask:255.255.255.0</span><br><span class=\"line\">Gateway:192.168.111.1</span><br><span class=\"line\">DNS:4.4.4.4</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>   \n<h1 id=\"配置项目工程\"><a href=\"#配置项目工程\" class=\"headerlink\" title=\"配置项目工程\"></a>配置项目工程</h1><p>Linux可以使用许多IDE，甚至可以脱离集成开发环境通过撰写Makefile管理项目文件。  </p>\n<h2 id=\"Makefile\"><a href=\"#Makefile\" class=\"headerlink\" title=\"Makefile\"></a>Makefile</h2><p>假设工程文件中包括main.c、spi.c以及head.h，为了生成可执行文件，需要生成main.c和spi.c的链接文件main.o和spi.o，而main.o和spi.o也需要编译生成。这个过程就是makefile的执行过程。以下为Makefile的内容：  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CC=gcc                  //gcc或者交叉编译gcc</span><br><span class=\"line\">OBJ=main.o spi.o          //OBJ是生成的链接文件目标，作为变量方便</span><br><span class=\"line\"><span class=\"section\">main: <span class=\"variable\">$(OBJ)</span>             //main可执行文件的生成需要OBJ中的两个文件</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> -o <span class=\"variable\">$@</span> <span class=\"variable\">$^</span>      // -o表示生成可执行文件 <span class=\"variable\">$@</span>表示目标文件（main）；<span class=\"variable\">$^</span>表示所有依赖文件（OBJ）</span><br><span class=\"line\"><span class=\"section\">spi.o: spi.c head.h </span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> -c <span class=\"variable\">$&lt;</span>         // <span class=\"variable\">$&lt;</span> 表示第一个依赖文件（spi.c）</span><br><span class=\"line\"><span class=\"section\">main.o: main.c head.h</span></span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> -c <span class=\"variable\">$&lt;</span></span><br><span class=\"line\"><span class=\"section\">clean:                  //make clean删除通过make指令生成的文件</span></span><br><span class=\"line\">\trm main <span class=\"variable\">$(OBJ)</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"VScode-Cmake\"><a href=\"#VScode-Cmake\" class=\"headerlink\" title=\"VScode + Cmake\"></a>VScode + Cmake</h2><p>当项目内容比较多时，可以通过CMake工具自动生成Makefile。Cmake主要配置CMakeLists.txt实现工程管理。推荐通过VScode生成CMake项目模板，过程如下：安装CMake插件；Ctrl+Shift+P，输入CMAKE QUICK START，选择gcc的kit，一般会自己查询到gcc或者交叉编译工具gcc，输入工程名称，再选择生成可执行文件。这样VScode就会生成项目模板。项目主要分为src、include、bin、build等文件夹，文件夹内容如下：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|——zhx_cmake_prj   #ZHX项目主要软件  </span><br><span class=\"line\">    |——bin        #可执行文件夹目录  </span><br><span class=\"line\">    |——build      #build目录  </span><br><span class=\"line\">    |——include    #头文件目录  </span><br><span class=\"line\">    |——src        #项目源文件  </span><br><span class=\"line\">        |——driver  #设备驱动源文件目录  </span><br><span class=\"line\">            |——spi  </span><br><span class=\"line\">            |——uart  </span><br><span class=\"line\">            |...  </span><br><span class=\"line\">        |——main.c    </span><br><span class=\"line\">        |——CMakeLists.txt </span><br><span class=\"line\">    |——CMakeLists.txt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CMakeLists\"><a href=\"#CMakeLists\" class=\"headerlink\" title=\"CMakeLists\"></a>CMakeLists</h3><p>主目录下的配置：  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake_minimum_required (VERSION 3.0.0)</span><br><span class=\"line\">SET(CMAKE_C_COMPILER <span class=\"string\">\"/usr/local/arm_gcc/bin/arm-linux-gnueabihf-gcc\"</span>)      //配置CMAKE GCC</span><br><span class=\"line\">SET(CMAKE_CXX_COMPILER <span class=\"string\">\"/usr/local/arm_gcc/bin/arm-linux-gnueabihf-g++\"</span>)</span><br><span class=\"line\">project(ZHX VERSION 0.1.0)</span><br><span class=\"line\">MESSAGE (STATUS  <span class=\"string\">\"This is the binary dir:  \"</span> $&#123;PROJECT_BINARY_DIR&#125;)</span><br><span class=\"line\">MESSAGE (STATUS  <span class=\"string\">\"This is the source dir:  \"</span> $&#123;PROJECT_SOURCE_DIR&#125;)</span><br><span class=\"line\">INCLUDE_DIRECTORIES (<span class=\"keyword\">include</span>)   //添加<span class=\"keyword\">include</span>路径</span><br><span class=\"line\">ADD_SUBDIRECTORY(src)           //添加src子目录</span><br></pre></td></tr></table></figure>\n\n<p>二级CMakeLists.txt（src文件夹下）：  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AUX_SOURCE_DIRECTORY(.  SRC_LIST)   //添加当前目录为源码编译目录</span><br><span class=\"line\">AUX_SOURCE_DIRECTORY(./driver/spi/  SRC_LIST)</span><br><span class=\"line\">AUX_SOURCE_DIRECTORY(./driver/i2c/  SRC_LIST)</span><br><span class=\"line\">AUX_SOURCE_DIRECTORY(../<span class=\"keyword\">include</span>/  SRC_LIST)     //添加<span class=\"keyword\">include</span>为源码编译目录</span><br><span class=\"line\">ADD_EXECUTABLE(main $&#123;SRC_LIST&#125; )               //通过源码目录中的所有依赖文件生成可执行文件main</span><br><span class=\"line\">SET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin) //将main输出至bin文件夹下</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"文件编译方式\"><a href=\"#文件编译方式\" class=\"headerlink\" title=\"文件编译方式\"></a>文件编译方式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd ($PRJ)/build  </span><br><span class=\"line\">$ cmake ..  </span><br><span class=\"line\">$ make</span><br><span class=\"line\">$ cd ($PRJ)/bin</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"配置开发板\"><a href=\"#配置开发板\" class=\"headerlink\" title=\"配置开发板\"></a>配置开发板</h1><h2 id=\"制作SD卡\"><a href=\"#制作SD卡\" class=\"headerlink\" title=\"制作SD卡\"></a>制作SD卡</h2><p>运行$tisdk/bin/creat-sdcard.sh，替换zImage以及设备树文件。  </p>\n<h2 id=\"远程登录与传递文件\"><a href=\"#远程登录与传递文件\" class=\"headerlink\" title=\"远程登录与传递文件\"></a>远程登录与传递文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ifconfig eth0 192.168.111.100</span><br><span class=\"line\">$ ssh root@192.168.111.100</span><br><span class=\"line\">$ scp file root@192.168.111.100:~</span><br></pre></td></tr></table></figure>\n\n<p>如果显示ssh无法登陆，原因是当前ip地址与开发板的上一次刷的系统配置的ip地址冲突，使用以下命令删除旧的配置：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$: ssh-keygen –f “/home/usr-name/.ssh/known_hosts” –R “192.168.111.100”</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"固定目标板的IP地址\"><a href=\"#固定目标板的IP地址\" class=\"headerlink\" title=\"固定目标板的IP地址\"></a>固定目标板的IP地址</h2><p>修改/etc/systemd/network/目录下的10-eth.network文件：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Match]</span><br><span class=\"line\">Name=eth0</span><br><span class=\"line\">KernelCommandLine=!root=/dev/nfs</span><br><span class=\"line\"></span><br><span class=\"line\">[Network]</span><br><span class=\"line\">Address=192.168.111.100/24</span><br><span class=\"line\">Gateway=192.168.111.1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"串口收发文件\"><a href=\"#串口收发文件\" class=\"headerlink\" title=\"串口收发文件\"></a>串口收发文件</h2><p>目标板没有安装ssh时，通过TCP/IP无法传输文件，在文件容量较小的情况下可以使用lrzsz工具。Lrzsz工具解压后使用./configure命令配置makefile，在主机中需要将bin、src以及根目录下的makefile中的CC均改为交叉编译链，再在主目录中make，最后将src/lrz和src/lsz拷贝至目标板的/bin文件夹下。<br>1) 主机向从机发送文件：从机运行lrz，主机选择通过zModem发送，（minicom中通过Ctrl+A-Z-S进入）文件将保存在从机当前目录下；<br>2) 从机向主机发送文件：主机运行lrz（使用主机的gcc编译），从机运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ lsz file</span><br></pre></td></tr></table></figure>","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"vscode","slug":"vscode","permalink":"http://yoursite.com/tags/vscode/"}]},{"title":"ARM Linux开发命令","date":"2019-07-22T09:45:47.000Z","path":"2019/07/22/ARM Linux开发命令/","content":"<p>使用开发板版本：TI AM5728 EVM<br>使用SDK版本：ti-processor-sdk-linux-rt-am57xx-evm-05.02.00.10<br>官方软件支持：<a href=\"http://software-dl.ti.com/processor-sdk-linux-rt/esd/AM57X/latest/index_FDS.html\" target=\"_blank\" rel=\"noopener\">RT-Linux-software</a><br>官方软件使用说明(更新至6.00.00.07,2019年7月)：<a href=\"http://software-dl.ti.com/processor-sdk-linux/esd/docs/06_00_00_07/linux/index.html\" target=\"_blank\" rel=\"noopener\">TISDK</a><br>TI中文社区：<a href=\"https://e2echina.ti.com/\" target=\"_blank\" rel=\"noopener\">e2echina.ti</a><br>创龙论坛：<a href=\"http://www.51ele.net/\" target=\"_blank\" rel=\"noopener\">51ele</a>  </p>\n<a id=\"more\"></a>  \n<h2 id=\"内核编译\"><a href=\"#内核编译\" class=\"headerlink\" title=\"内核编译\"></a>内核编译</h2><h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- tisdk_am57xx-evm-rt_defconfig </span><br><span class=\"line\">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig</span><br><span class=\"line\">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage -j16</span><br><span class=\"line\">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean</span><br></pre></td></tr></table></figure>\n\n<p>生成的zImage替换/rootfs/boot下的zImage文件。</p>\n<h3 id=\"内核源码\"><a href=\"#内核源码\" class=\"headerlink\" title=\"内核源码\"></a>内核源码</h3><h3 id=\"内核功能裁剪思路\"><a href=\"#内核功能裁剪思路\" class=\"headerlink\" title=\"内核功能裁剪思路\"></a>内核功能裁剪思路</h3><h2 id=\"设备树改写\"><a href=\"#设备树改写\" class=\"headerlink\" title=\"设备树改写\"></a>设备树改写</h2><h3 id=\"命令-1\"><a href=\"#命令-1\" class=\"headerlink\" title=\"命令\"></a>命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- am57xx-evm-reva3.dtb -j8</span><br></pre></td></tr></table></figure>\n\n<p>源码位置：$tisdk/arch/arm/boot/dts/am57xx-beagle-x15-common.dtsi等。生成的am57xx-evm-reva3.dtb替换/rootfs/boot下的设备树文件。  </p>\n<h2 id=\"编译模块\"><a href=\"#编译模块\" class=\"headerlink\" title=\"编译模块\"></a>编译模块</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modules -j16</span><br><span class=\"line\">sudo make ARCH=arm INSTALL_MOD_PATH=../rootfs modules_install</span><br></pre></td></tr></table></figure>\n\n<p>模块的版本要与内核一致，所以要编译模块。加载模块指令：insmod。卸载模块指令。</p>\n","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"arm","slug":"arm","permalink":"http://yoursite.com/tags/arm/"}]},{"title":"如何利用hexo和github搭建免费个人博客","date":"2019-07-19T14:30:53.524Z","path":"2019/07/19/如何利用hexo和github搭建免费个人博客/","content":"<p>文章转载来自<a href=\"https://blog.csdn.net/qq_40147863/article/details/84942914\" target=\"_blank\" rel=\"noopener\">使用 Hexo + Github 搭建自己的博客（图文教程）</a><br>替换主题参考<a href=\"https://blog.csdn.net/qq_40147863/article/details/84946894\" target=\"_blank\" rel=\"noopener\">Hexo 安装和替换主题、自定义博客主题</a></p>\n<a id=\"more\"></a>\n<h2 id=\"搭建过程\"><a href=\"#搭建过程\" class=\"headerlink\" title=\"搭建过程\"></a>搭建过程</h2><h3 id=\"安装git-node-js\"><a href=\"#安装git-node-js\" class=\"headerlink\" title=\"安装git node.js\"></a>安装git node.js</h3><p>查看版本命令用  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm -v</span><br><span class=\"line\">$ node -v</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"新建仓库\"><a href=\"#新建仓库\" class=\"headerlink\" title=\"新建仓库\"></a>新建仓库</h3><p>新建一个repository，名称为 <code>name.github.io</code></p>\n<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo -g</span><br><span class=\"line\">$ hexo -v</span><br><span class=\"line\">$ hexo init</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo s  <span class=\"comment\">#查看本地新建的hexo</span></span><br><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"修改-config-yml\"><a href=\"#修改-config-yml\" class=\"headerlink\" title=\"修改_config.yml\"></a>修改<code>_config.yml</code></h3><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repository:</span> <span class=\"string\">git@github.com:sjl3110/sjl3110.github.io.git</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"建立ssh密钥\"><a href=\"#建立ssh密钥\" class=\"headerlink\" title=\"建立ssh密钥\"></a>建立ssh密钥</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C <span class=\"string\">\"mail@xx.com\"</span></span><br></pre></td></tr></table></figure>\n\n<p>并将默认保存位置的<code>id_rsa.pub</code>内容存放到github网站中的SSH密钥中。</p>\n<h2 id=\"维护过程\"><a href=\"#维护过程\" class=\"headerlink\" title=\"维护过程\"></a>维护过程</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new post <span class=\"string\">\"blog-name\"</span></span><br><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure>","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"基于TCP/IP网络socket通信","date":"2019-07-19T13:55:15.200Z","path":"2019/07/19/基于TCP-IP网络socket通信/","content":"<p>网络传输文件现有的工具为ssh或者tcp指令，ssh中的scp指令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ scp file name@IP:file_path</span><br></pre></td></tr></table></figure>\n\n<p>测试在百兆带宽的情况下，可以达到5~6MB/s。<br>SSH的用户层工作原理，除去登陆密码以及公钥或者私钥的建立，底层的工作模式也需要考虑。  </p>\n<a id=\"more\"></a>  \n\n<h2 id=\"网络设备驱动\"><a href=\"#网络设备驱动\" class=\"headerlink\" title=\"网络设备驱动\"></a>网络设备驱动</h2><p>网络层次七层又可以分为应用层（应用层、表示层与会话层）、传输层、网络层、数据链路层以及物理层。<br><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/tcpip/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E5%9B%BE.png\" alt=\"avatar\"><br>网络设备驱动负责将数据包写入网络或者从网络中读取数据包，从而完成上层的请求，与其他接口开发的不同是  </p>\n<ul>\n<li>网络设备不在/dev下创建设备文件；  </li>\n<li>底层采用中断的工作方式，并将中断传递给上层应用程序（这与UART类似）。 </li>\n</ul>\n<h3 id=\"内核配置\"><a href=\"#内核配置\" class=\"headerlink\" title=\"内核配置\"></a>内核配置</h3><p>—&gt; Networking support &gt; Networking options<br><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/tcpip/kernel1.png\" alt=\"avatar\"><br>网络功能选择：在内核中配置EtherNet网口支持的功能。   </p>\n<table>\n<thead>\n<tr>\n<th>内核选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Packet socket</td>\n<td>支持Socket通信</td>\n</tr>\n<tr>\n<td>Unix domain sockets</td>\n<td>Socket进程间通信</td>\n</tr>\n<tr>\n<td>TCP/IP networking</td>\n<td>TCP/TP网络协议</td>\n</tr>\n<tr>\n<td>IP:multicasting</td>\n<td>组播，多目标发送</td>\n</tr>\n<tr>\n<td>IP:advanced router</td>\n<td>高级路由，流量控制</td>\n</tr>\n<tr>\n<td>IP:kernel level autoconfiguration</td>\n<td>内核启动时自动获取IP</td>\n</tr>\n<tr>\n<td>IP:DHCP suppo</td>\n<td>DHCP 获取动态IP协议</td>\n</tr>\n<tr>\n<td>IP:BOOTP support</td>\n<td>DHCP的前身</td>\n</tr>\n<tr>\n<td>IP:RARP support</td>\n<td>反向地址转换协议</td>\n</tr>\n</tbody></table>\n<p>— &gt; Device Drivers &gt; Network device support ─ Ethernet driver support<br><img src=\"https://raw.githubusercontent.com/sjl3110/pictures-for-hexo/master/tcpip/kernel2.png\" alt=\"avatar\"><br>配置芯片驱动：选择对应厂商的芯片，若没有需要写适配的驱动源码！  </p>\n<h3 id=\"设备树配置\"><a href=\"#设备树配置\" class=\"headerlink\" title=\"设备树配置\"></a>设备树配置</h3><p>直接引用dra7.dtsi设备树源文件中的以太网寄存器配置。  </p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">&amp;davinci_mdio</span> &#123;</span><br><span class=\"line\"><span class=\"symbol\">    phy0:</span> ethernet-<span class=\"class\">phy@1 </span>&#123;</span><br><span class=\"line\">        reg = <span class=\"params\">&lt;<span class=\"number\">1</span>&gt;</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"><span class=\"symbol\">    phy1:</span> ethernet-<span class=\"class\">phy@2 </span>&#123;</span><br><span class=\"line\">        reg = <span class=\"params\">&lt;<span class=\"number\">2</span>&gt;</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"传输协议\"><a href=\"#传输协议\" class=\"headerlink\" title=\"传输协议\"></a>传输协议</h2><h3 id=\"数据传输协议\"><a href=\"#数据传输协议\" class=\"headerlink\" title=\"数据传输协议\"></a>数据传输协议</h3><p><img src=\"https://github.com/sjl3110/pictures-for-hexo/blob/master/tcpip/%E5%8D%8F%E8%AE%AE1.png?raw=true\" alt=\"avatar\">    </p>\n<ul>\n<li>服务端accept()函数为阻塞函数，主进程执行至accept后进程阻塞，直到客户端发出连接请求；  </li>\n<li>接收请求后使用fork()函数创建子进程，这样就可以通过不同的子进程连接多个客户端；  </li>\n<li>Send()函数将指定长度数据发送至内存缓冲队列，发送后等待对方确认（客户端确认和服务端重新发送在底层完成）；  </li>\n<li>recv()函数也是阻塞函数，在队列中没有数据时，recv()进程进入阻塞，recv()成功读取则返回读取长度。  </li>\n</ul>\n<h3 id=\"文件传输协议\"><a href=\"#文件传输协议\" class=\"headerlink\" title=\"文件传输协议\"></a>文件传输协议</h3><p><img src=\"https://github.com/sjl3110/pictures-for-hexo/blob/master/tcpip/%E5%8D%8F%E8%AE%AE2.png?raw=true\" alt=\"avatar\">   </p>\n<ul>\n<li>缓冲区长度有限，若客户端不执行recv()则服务端发送一定量的数据包后停止发送；  </li>\n<li>客户端需要加入文件末尾判断的语句；  </li>\n<li>若 T1&gt;T2，则recv()函数并不能一次读取设定长度的数据，即有多少读多少，增加了客户端读取循环的次数，降低了传输效率；</li>\n</ul>\n<h3 id=\"测试与改进\"><a href=\"#测试与改进\" class=\"headerlink\" title=\"测试与改进\"></a>测试与改进</h3><p>实际测试：文件长度50160000，约50MB；网络带宽100Mb，上限约12.5MB/s。设每次发送10000Byte，测得：服务端发送5016个数据包，客户端每次接收1000–10000长度不等的包，实际接收了13000个数据包，最终传输速率为2MB/s。<br>改进：每次recv()先与对方确认包的长度，并将内容读满再返回，配置MSG_WAITALL。测试结果：服务端发送5016个数据包，客户端接收了5016个数据包，最终传输速率为10–12MB/s。  </p>\n<h3 id=\"配置数据包\"><a href=\"#配置数据包\" class=\"headerlink\" title=\"配置数据包\"></a>配置数据包</h3><p><img src=\"https://github.com/sjl3110/pictures-for-hexo/blob/master/tcpip/%E5%8D%8F%E8%AE%AE3.png?raw=true\" alt=\"avatar\"></p>\n<ul>\n<li>在应用层编写实现类似底层包的组帧结构的协议，可以完成多个文件的收发；  </li>\n<li>由于组包与解包的加入，速度略有牺牲，测试速度约为4~5MB/s。  </li>\n</ul>\n<h2 id=\"应用程序\"><a href=\"#应用程序\" class=\"headerlink\" title=\"应用程序\"></a>应用程序</h2><h3 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><details>\n<summary>server.c</summary>  \n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/shm.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PORT 8888</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> QUEUE_SIZE 10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUFFER_SIZE 10000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//传进来的sockfd，就是互相建立好连接之后的socket文件描述符</span></span><br><span class=\"line\"><span class=\"comment\">//通过这个sockfd，可以完成 [服务端]&lt;---&gt;[客户端] 互相收发数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer_file</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    FILE *fp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ch;</span><br><span class=\"line\">    <span class=\"keyword\">time_t</span> t_start, t_end;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> send_num;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//char name[LEN];    // storage for output filename</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    fp = fopen(<span class=\"string\">\"test.txt\"</span>, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fp == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"couldn't open the file \\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fseek(fp, <span class=\"number\">0L</span>, SEEK_END); <span class=\"comment\">//将文件指针移到末尾</span></span><br><span class=\"line\">    length = ftell(fp);    <span class=\"comment\">//获取文件长度</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%ld\\n\"</span>, length);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span> str[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(str, <span class=\"string\">\"%ld\"</span>, length);   <span class=\"comment\">//将文件长度转换为字符串str</span></span><br><span class=\"line\">    send(sockfd, str, <span class=\"keyword\">sizeof</span>(str), <span class=\"number\">0</span>);  <span class=\"comment\">//将文件长度发送给client</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer1[BUFFER_SIZE];</span><br><span class=\"line\">    recv(sockfd, buffer1, <span class=\"keyword\">sizeof</span>(buffer1), <span class=\"number\">0</span>);    <span class=\"comment\">//等待对方读取完长度后返回“ready”</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(buffer1, <span class=\"string\">\"ready\"</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fseek(fp, <span class=\"number\">0L</span>, SEEK_SET);          <span class=\"comment\">//文件指针移到开头</span></span><br><span class=\"line\">        <span class=\"comment\">// char buffer[1];</span></span><br><span class=\"line\">        <span class=\"comment\">// copy data</span></span><br><span class=\"line\">        <span class=\"comment\">// while ((ch = getc(fp)) != EOF)</span></span><br><span class=\"line\">        <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     buffer[0] = ch;</span></span><br><span class=\"line\">        <span class=\"comment\">//     send(sockfd, buffer, 1, 0);</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        t_start = time(<span class=\"literal\">NULL</span>);          <span class=\"comment\">//获取开始时间</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> buffer[BUFFER_SIZE];       <span class=\"comment\">//新建缓存</span></span><br><span class=\"line\">        send_num = <span class=\"number\">0</span>;                  <span class=\"comment\">//计算发送包的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fread(buffer, <span class=\"keyword\">sizeof</span>(buffer), <span class=\"number\">1</span>, fp))    <span class=\"comment\">//fread 读文件到缓存，读到末尾会EOF（-1）</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//printf(\"send%d %ld\\n\",send_num,sizeof(buffer));</span></span><br><span class=\"line\">            send(sockfd, buffer, <span class=\"keyword\">sizeof</span>(buffer), <span class=\"number\">0</span>);      <span class=\"comment\">//发送一个文件包</span></span><br><span class=\"line\">            send_num++;</span><br><span class=\"line\">            <span class=\"comment\">//break;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        t_end = time(<span class=\"literal\">NULL</span>);  <span class=\"comment\">//获取结束时间</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"send %d times\\n\"</span>, send_num);     </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"speed: %.02f MB/s\\n\"</span>, length / <span class=\"number\">1024</span> / <span class=\"number\">1024</span> / difftime(t_end, t_start));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fclose(fp) != <span class=\"number\">0</span>)        <span class=\"comment\">//关闭文件</span></span><br><span class=\"line\">            <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"Error in closing files\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"cannot get start!\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">str_echo</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd)</span>     <span class=\"comment\">//回环函数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[BUFFER_SIZE];     <span class=\"comment\">//新建内存缓冲区</span></span><br><span class=\"line\">    <span class=\"keyword\">pid_t</span> pid = getpid();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(buffer, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(buffer));    <span class=\"comment\">//将内存缓冲区清0，初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = recv(sockfd, buffer, <span class=\"keyword\">sizeof</span>(buffer), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"pid:%d receive:\\n\"</span>, pid);</span><br><span class=\"line\">        <span class=\"built_in\">fputs</span>(buffer, <span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(buffer, <span class=\"string\">\"exit\\n\"</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"child process: %d exited.\\n\"</span>, pid);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"the server shutdown.\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(buffer, <span class=\"string\">\"send\\n\"</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"start transfer.\\n\"</span>);</span><br><span class=\"line\">            transfer_file(sockfd);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"transfer end.\\n\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">//sleep(10);</span></span><br><span class=\"line\">            <span class=\"comment\">//printf(\"the server shutdown.\\n\");</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        send(sockfd, buffer, len, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    close(sockfd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义IPV4的TCP连接的套接字描述符</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> server_sockfd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//定义sockaddr_in</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">server_sockaddr</span>;</span></span><br><span class=\"line\">    server_sockaddr.sin_family = AF_INET;</span><br><span class=\"line\">    server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\">    server_sockaddr.sin_port = htons(PORT);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//bind成功返回0，出错返回-1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bind(server_sockfd, (struct sockaddr *)&amp;server_sockaddr, <span class=\"keyword\">sizeof</span>(server_sockaddr)) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"bind\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>); <span class=\"comment\">//1为异常退出</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"bind success.\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//listen成功返回0，出错返回-1，允许同时帧听的连接数为QUEUE_SIZE</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listen(server_sockfd, QUEUE_SIZE) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"listen\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"listen success.\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">client_addr</span>;</span></span><br><span class=\"line\">        <span class=\"keyword\">socklen_t</span> length = <span class=\"keyword\">sizeof</span>(client_addr);</span><br><span class=\"line\">        <span class=\"comment\">//进程阻塞在accept上，成功返回非负描述字，出错返回-1</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> conn = accept(server_sockfd, (struct sockaddr *)&amp;client_addr, &amp;length);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (conn &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            perror(<span class=\"string\">\"connect\"</span>);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"new client accepted.\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">pid_t</span> childid;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childid = fork() == <span class=\"number\">0</span>) <span class=\"comment\">//子进程</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"child process: %d created.\\n\"</span>, getpid());</span><br><span class=\"line\">            close(server_sockfd);   <span class=\"comment\">//在子进程中关闭监听</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str_echo(conn) &lt; <span class=\"number\">0</span>) <span class=\"comment\">//处理监听的连接</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);     <span class=\"comment\">//对方发送exit，返回-1，关闭子进程，主进程继续accep</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"closed.\\n\"</span>);</span><br><span class=\"line\">    close(server_sockfd);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"end\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>  \n\n<p>客户端编译后执行：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ifconfig eth0 192.168.111.101</span><br><span class=\"line\">$ ./server</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><details>\n<summary>client.c</summary>  \n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/shm.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PORT 8888</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUFFER_SIZE 10000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"usage: client IP \\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//定义IPV4的TCP连接的套接字描述符</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sock_cli = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    FILE *out;</span><br><span class=\"line\">    <span class=\"keyword\">time_t</span> t_start, t_end;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> i, receive_length, file_length, length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> receive_num;</span><br><span class=\"line\">    <span class=\"comment\">//定义sockaddr_in</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">servaddr</span>;</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;servaddr, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(servaddr));</span><br><span class=\"line\">    servaddr.sin_family = AF_INET;</span><br><span class=\"line\">    servaddr.sin_addr.s_addr = inet_addr(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    servaddr.sin_port = htons(PORT); <span class=\"comment\">//服务器端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//连接服务器，成功返回0，错误返回-1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connect(sock_cli, (struct sockaddr *)&amp;servaddr, <span class=\"keyword\">sizeof</span>(servaddr)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"connect\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"connect server(IP:%s).\\n\"</span>, argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span> sendbuf[BUFFER_SIZE];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> recvbuf[BUFFER_SIZE];</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(sendbuf, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(sendbuf));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(recvbuf, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(recvbuf));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//客户端将控制台输入的信息发送给服务器端，服务器原样返回信息</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fgets(sendbuf, <span class=\"keyword\">sizeof</span>(sendbuf), <span class=\"built_in\">stdin</span>) != <span class=\"literal\">NULL</span>)   <span class=\"comment\">//捕获命令行的字符串到sendbuf</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(recvbuf, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(recvbuf));</span><br><span class=\"line\">        send(sock_cli, sendbuf, <span class=\"built_in\">strlen</span>(sendbuf), <span class=\"number\">0</span>); <span class=\"comment\">///发送</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(sendbuf, <span class=\"string\">\"exit\\n\"</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"client exited.\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">strcmp</span>(sendbuf, <span class=\"string\">\"send\\n\"</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((out = fopen(<span class=\"string\">\"out.txt\"</span>, <span class=\"string\">\"w\"</span>)) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            &#123; <span class=\"comment\">// open file for writing</span></span><br><span class=\"line\">                <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"Can't create output file.\\n\"</span>);</span><br><span class=\"line\">                <span class=\"built_in\">exit</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            recv(sock_cli, recvbuf, <span class=\"keyword\">sizeof</span>(recvbuf), <span class=\"number\">0</span>);</span><br><span class=\"line\">            file_length = atoi(recvbuf);</span><br><span class=\"line\">            <span class=\"built_in\">memset</span>(recvbuf, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(recvbuf)); <span class=\"comment\">//获取文件长度</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">memset</span>(sendbuf, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(sendbuf));</span><br><span class=\"line\">            send(sock_cli, <span class=\"string\">\"ready\"</span>, <span class=\"number\">5</span>, <span class=\"number\">0</span>); <span class=\"comment\">//发送就绪</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"receive file start.\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            t_start = time(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">            length = <span class=\"number\">0</span>;</span><br><span class=\"line\">            receive_num = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (length &lt; file_length)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                receive_length = recv(sock_cli, recvbuf, <span class=\"keyword\">sizeof</span>(recvbuf), MSG_WAITALL); <span class=\"comment\">///接收 //MSG_WAITALL是强行等待缓冲满再结束</span></span><br><span class=\"line\">                <span class=\"comment\">//sleep(1);</span></span><br><span class=\"line\">                <span class=\"comment\">//printf(\"%d length %d\\n\", receive_num,receive_length);</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//fputs(recvbuf, stdout);</span></span><br><span class=\"line\">                <span class=\"comment\">//printf(\"run dot1\\n\");</span></span><br><span class=\"line\">                <span class=\"comment\">//for (i = 0; i &lt; receive_length; i++)</span></span><br><span class=\"line\">                <span class=\"comment\">//&#123;</span></span><br><span class=\"line\">                <span class=\"comment\">//putc(recvbuf[i], out);</span></span><br><span class=\"line\">                <span class=\"comment\">//&#125;</span></span><br><span class=\"line\">                <span class=\"built_in\">fprintf</span>(out, <span class=\"string\">\"%s\"</span>, recvbuf);</span><br><span class=\"line\">                <span class=\"comment\">//memset(sendbuf, 0, sizeof(sendbuf));</span></span><br><span class=\"line\">                <span class=\"built_in\">memset</span>(recvbuf, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(recvbuf));</span><br><span class=\"line\">                <span class=\"comment\">//printf(\"run\\n\");</span></span><br><span class=\"line\">                length = length + receive_length;</span><br><span class=\"line\">                receive_num++;</span><br><span class=\"line\">                <span class=\"comment\">//break;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"receive %d times\\n\"</span>, receive_num);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fclose(out) != <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"Error in closing files\\n\"</span>);</span><br><span class=\"line\">            t_end = time(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"time : %.2f s\\n\"</span>, difftime(t_end, t_start));</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"speed: %.02f MB/s\\n\"</span>, file_length / <span class=\"number\">1024</span> / <span class=\"number\">1024</span> / difftime(t_end, t_start));</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"receive file end.\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"client receive:\\n\"</span>);</span><br><span class=\"line\">        recv(sock_cli, recvbuf, <span class=\"keyword\">sizeof</span>(recvbuf), <span class=\"number\">0</span>); <span class=\"comment\">///接收</span></span><br><span class=\"line\">        <span class=\"built_in\">fputs</span>(recvbuf, <span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(sendbuf, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(sendbuf));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    close(sock_cli);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<p>服务端编译后执行：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ifconfig eth0 192.168.111.100</span><br><span class=\"line\">$ ./client 192.168.111.101</span><br><span class=\"line\">$ mesg   //对方回环</span><br><span class=\"line\">$ send   //对方发送文件</span><br><span class=\"line\">$ exit   //对方关闭服务子进程，客户端退出</span><br></pre></td></tr></table></figure>\n\n","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"}]},{"title":"Windows系统配置Linux子系统开发ARM","date":"2019-07-19T11:42:09.451Z","path":"2019/07/19/Windows系统配置Linux子系统开发ARM/","content":"<p>Win10可以支持Ubuntu子系统，再也不需要虚拟机！  </p>\n<h2 id=\"安装系统\"><a href=\"#安装系统\" class=\"headerlink\" title=\"安装系统\"></a>安装系统</h2><p>系统要求：最新版win10，打开应用商店安装Ubuntu应用软件，需要系统开启虚拟机功能以及LINUX子系统功能。<br>安装完成后如下：<br><img src=\"https://github.com/sjl3110/pictures-for-hexo/blob/master/wsl_ubuntu.JPG?raw=true\" alt=\"avatar\"></p>\n<a id=\"more\"></a>\n<h3 id=\"配置-Ubuntu\"><a href=\"#配置-Ubuntu\" class=\"headerlink\" title=\"配置 Ubuntu\"></a>配置 Ubuntu</h3><p>换源等操作。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /etc/apt</span><br><span class=\"line\">$ sudo cp sources.list sources.list.bak</span><br><span class=\"line\">$ sudo vi sources.list</span><br><span class=\"line\">$ add </span><br><span class=\"line\">  deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class=\"line\">  deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class=\"line\">  deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class=\"line\">  deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class=\"line\">  deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class=\"line\">  deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class=\"line\">  deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class=\"line\">  deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class=\"line\">  deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class=\"line\">  deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class=\"line\">$ sudo apt-get update</span><br><span class=\"line\">$ sudo apt-get upgrade</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装-gcc-交叉编译工具\"><a href=\"#安装-gcc-交叉编译工具\" class=\"headerlink\" title=\"安装 gcc 交叉编译工具\"></a>安装 gcc 交叉编译工具</h3><h4 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则\"></a>命名规则</h4><p>交叉编译工具链的命名规则为：<code>arch [-vendor] [-os] [-(gnu)eabi]</code></p>\n<ul>\n<li>arch - 体系架构，如ARM，MIPS</li>\n<li>vendor - 工具链提供商</li>\n<li>os - 目标操作系统</li>\n<li>eabi - 嵌入式应用二进制接口（Embedded ApplicationBinary Interface）  </li>\n</ul>\n<p>根据对操作系统的支持与否，ARM  GCC可分为支持和不支持操作系统，如<br>arm-none-eabi：这个是没有操作系统的，自然不可能支持那些跟操作系统关系密切的函数，比如fork()。使用的是newlib这个专用于嵌入式系统的C库。<br>arm-none-linux-eabi：用于Linux的，使用Glibc。<br>比如:<br>arm-none-eabi-gcc：用于编译 ARM 架构的裸机系统（包括 ARM Linux 的 boot、kernel，不适用编译 Linux 应用 Application）。<br>arm-none-linux-gnueabi-gcc：主要用于基于 ARM 架构的 Linux 系统，可用于编译 ARM 架构的 u-boot、Linux内核、Linux应用等。<br>arm-eabi-gcc：Android ARM 编译器。<br>armcc ARM：公司推出的编译工具，功能和 arm-none-eabi 类似。<br>arm-none-uclinuxeabi-gcc：用于uCLinux，使用Glibc。<br>arm-none-symbianelf-gcc：用于symbian。<br>下载链接: <a href=\"https://releases.linaro.org/components/toolchain/binaries/7.2-2017.11/arm-linux-gnueabihf/\" target=\"_blank\" rel=\"noopener\">gcc-toolchain</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar xvf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabihf.tar.xz -C /usr/<span class=\"built_in\">local</span>/arm_gcc</span><br><span class=\"line\">$ sudo vim /etc/profile</span><br><span class=\"line\">$ <span class=\"built_in\">export</span> PATH=/usr/<span class=\"built_in\">local</span>/arm_gcc/bin/:<span class=\"variable\">$PATH</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装-Minicom\"><a href=\"#安装-Minicom\" class=\"headerlink\" title=\"安装 Minicom\"></a>安装 Minicom</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apr-get install minicom</span><br><span class=\"line\">$ sudo minicom -D /dev/ttySx</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"编译代码\"><a href=\"#编译代码\" class=\"headerlink\" title=\"编译代码\"></a>编译代码</h3><p>需要在CMakelists.txt中set gcc和g++路径，其余与Linux正常。</p>\n","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"arm","slug":"arm","permalink":"http://yoursite.com/tags/arm/"}]}]